<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OMEGA: SYSTEM v2.1 (STABLE)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>

    <style>
        :root {
            --hud-primary: #00ff41;
            --hud-alert: #ff3333;
            --bg-dark: #000000;
            --font-mono: 'Consolas', 'Monaco', monospace;
        }
        body { margin: 0; overflow: hidden; background: var(--bg-dark); font-family: var(--font-mono); color: var(--hud-primary); }
        #viewport { position: relative; width: 100vw; height: 100vh; }
        
        #camera-feed {
            position: absolute; width: 100%; height: 100%; object-fit: cover; z-index: 0;
            transform: scaleX(-1); /* Mirror for selfie feeling */
        }

        #hud-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        
        #ui-layer { position: absolute; inset: 0; z-index: 20; pointer-events: none; padding: 20px; display: flex; flex-direction: column; justify-content: space-between; }
        
        .hud-panel { 
            background: rgba(0, 20, 0, 0.7); border-left: 3px solid var(--hud-primary); 
            padding: 10px; backdrop-filter: blur(4px); pointer-events: auto; margin-bottom: 10px;
        }
        .text-sm { font-size: 12px; opacity: 0.8; }
        .text-xl { font-size: 20px; font-weight: bold; }

        /* Error Overlay */
        #error-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 99999;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            color: var(--hud-alert); text-align: center; padding: 20px;
        }
        
        /* Boot Screen */
        #boot-screen {
            position: fixed; inset: 0; background: #000; z-index: 50;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        button {
            background: transparent; border: 1px solid var(--hud-primary); color: var(--hud-primary);
            padding: 15px 30px; font-family: inherit; cursor: pointer; margin-top: 20px;
            font-size: 16px; transition: 0.3s;
        }
        button:hover { background: var(--hud-primary); color: #000; }
    </style>
</head>
<body>

    <div id="error-overlay">
        <h1 style="font-size: 40px;">⚠️ SYSTEM ERROR</h1>
        <p id="error-msg" style="font-size: 16px; max-width: 600px; line-height: 1.5;">UNKNOWN ERROR</p>
        <div style="margin-top:20px; border:1px solid #ff3333; padding:10px;">
            <strong>PROTOCOL CHECK:</strong><br>
            If you see this, you might have opened the file directly.<br>
            Browsers BLOCK cameras on file://<br>
            Please use a Local Server (VS Code Live Server) or HTTPS.
        </div>
    </div>

    <div id="boot-screen">
        <div style="font-size: 40px; font-weight: bold; letter-spacing: 5px;">OMEGA</div>
        <div style="color: #666; margin-bottom: 20px;">v2.1 STABLE RELEASE</div>
        <div id="boot-log" style="font-size: 12px; color: #00ff41; margin-bottom: 20px; height: 20px;">WAITING FOR USER...</div>
        <button id="btn-start">INITIALIZE SYSTEM</button>
    </div>

    <div id="viewport">
        <video id="camera-feed" autoplay playsinline muted></video>
        <canvas id="hud-canvas"></canvas>
        
        <div id="ui-layer">
            <div>
                <div class="hud-panel">
                    <div class="text-sm">VISION ENGINE</div>
                    <div class="text-xl"><span id="fps-counter">0</span> FPS</div>
                </div>
            </div>
            <div style="align-self: flex-end;">
                 <div class="hud-panel">
                    <div class="text-sm">STATUS</div>
                    <div class="text-xl" id="status-text">STANDBY</div>
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * OMEGA v2.1 - Robust Fix Version
 * Focus: Stability, Error Handling, and Correct Tensor Shapes
 */

// Global Error Handler
window.onerror = function(msg, url, line) {
    showError(`SCRIPT ERROR: ${msg} (Line ${line})`);
    return false;
};

function showError(msg) {
    const el = document.getElementById('error-overlay');
    const txt = document.getElementById('error-msg');
    el.style.display = 'flex';
    txt.innerText = msg;
    console.error(msg);
}

function logBoot(msg) {
    document.getElementById('boot-log').innerText = `>> ${msg}`;
    console.log(`[BOOT] ${msg}`);
}

const OMEGA = {
    video: document.getElementById('camera-feed'),
    canvas: document.getElementById('hud-canvas'),
    ctx: document.getElementById('hud-canvas').getContext('2d'),
    model: null,
    isRunning: false,
    
    // Config
    width: window.innerWidth,
    height: window.innerHeight,

    init: async function() {
        try {
            document.getElementById('btn-start').style.display = 'none';
            
            // 1. Protocol Check
            if (window.location.protocol === 'file:') {
                throw new Error("Security Restriction: Browsers block camera access on 'file://'. Please run this via a local server (localhost) or HTTPS.");
            }

            // 2. Camera Setup (Robust)
            logBoot("INITIALIZING OPTICS...");
            await this.setupCamera();
            
            // 3. AI Setup (Tensor Fix Included)
            logBoot("LOADING NEURAL NETWORK...");
            await this.loadAI();

            // 4. Start Loop
            logBoot("SYSTEM ONLINE");
            this.isRunning = true;
            document.getElementById('boot-screen').style.display = 'none';
            this.resize();
            this.loop();

        } catch (e) {
            showError(e.message);
        }
    },

    setupCamera: async function() {
        const constraints = {
            audio: false,
            video: {
                facingMode: 'environment', // Try rear camera first
                width: { ideal: 1280 },
                height: { ideal: 720 }
            }
        };

        try {
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            this.video.srcObject = stream;
        } catch (e) {
            logBoot("REAR CAM FAILED, TRYING FALLBACK...");
            // Fallback to any available camera
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                this.video.srcObject = stream;
            } catch (err2) {
                throw new Error("CAMERA ACCESS DENIED: Please allow camera permissions in your browser settings.");
            }
        }

        return new Promise((resolve) => {
            this.video.onloadedmetadata = () => {
                this.video.play();
                resolve();
            };
        });
    },

    loadAI: async function() {
        // Force WebGL for performance
        try { await tf.setBackend('webgl'); } catch(e) { await tf.setBackend('cpu'); }
        
        // Load COCO-SSD
        this.model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
        
        // --- THE CRITICAL FIX ---
        // Old Code (Bug): tf.zeros([1, 224, 224, 3]) -> caused 5D tensor error
        // New Code (Fix): tf.zeros([224, 224, 3]) -> correctly becomes 4D internal batch
        const dummy = tf.zeros([224, 224, 3]); 
        await this.model.detect(dummy);
        dummy.dispose();
    }
};

// Main Loop
OMEGA.loop = async function() {
    if (!OMEGA.isRunning) return;
    
    const start = performance.now();
    
    // 1. Detection
    if (OMEGA.model && OMEGA.video.readyState === 4) {
        try {
            const predictions = await OMEGA.model.detect(OMEGA.video, 10, 0.5);
            OMEGA.draw(predictions);
            document.getElementById('status-text').innerText = `TARGETS: ${predictions.length}`;
        } catch (e) {
            console.warn("Inference skipped frame");
        }
    }

    // 2. FPS Calculation
    const end = performance.now();
    const fps = Math.round(1000 / (end - start));
    document.getElementById('fps-counter').innerText = fps;

    requestAnimationFrame(OMEGA.loop);
};

// Drawing
OMEGA.draw = function(predictions) {
    const ctx = OMEGA.ctx;
    const W = OMEGA.canvas.width;
    const H = OMEGA.canvas.height;
    
    // Clear previous frame
    ctx.clearRect(0, 0, W, H);
    
    // Draw Crosshair
    ctx.strokeStyle = "rgba(0, 255, 65, 0.5)";
    ctx.beginPath();
    ctx.moveTo(W/2 - 20, H/2); ctx.lineTo(W/2 + 20, H/2);
    ctx.moveTo(W/2, H/2 - 20); ctx.lineTo(W/2, H/2 + 20);
    ctx.stroke();

    // Draw Predictions
    // Note: Simple scaling mapping for full screen
    const vidW = OMEGA.video.videoWidth;
    const vidH = OMEGA.video.videoHeight;
    const scaleX = W / vidW;
    const scaleY = H / vidH;
    
    // Use 'cover' logic approximation for drawing boxes
    // (Simplified for robustness - works well enough for visual HUD)
    const scale = Math.max(scaleX, scaleY);
    const dx = (W - vidW * scale) / 2;
    const dy = (H - vidH * scale) / 2;

    predictions.forEach(p => {
        const [x, y, w, h] = p.bbox;
        
        // Transform coordinates
        const sx = x * scale + dx;
        const sy = y * scale + dy;
        const sw = w * scale;
        const sh = h * scale;

        // Draw Box
        ctx.strokeStyle = "#00ff41";
        ctx.lineWidth = 2;
        ctx.strokeRect(sx, sy, sw, sh);

        // Draw Label Background
        ctx.fillStyle = "rgba(0, 255, 65, 0.2)";
        ctx.fillRect(sx, sy - 20, sw, 20);
        
        // Draw Text
        ctx.fillStyle = "#fff";
        ctx.font = "bold 12px monospace";
        ctx.fillText(`${p.class.toUpperCase()} ${Math.round(p.score*100)}%`, sx + 5, sy - 5);
        
        // Draw Radar Blip (Simulation)
        // Center of box relative to screen center
        const centerX = sx + sw/2;
        const distFromCenter = (centerX - W/2);
        // ... (Radar logic kept simple for stability)
    });
};

OMEGA.resize = function() {
    OMEGA.canvas.width = window.innerWidth;
    OMEGA.canvas.height = window.innerHeight;
    OMEGA.width = window.innerWidth;
    OMEGA.height = window.innerHeight;
};

window.addEventListener('resize', OMEGA.resize);
document.getElementById('btn-start').addEventListener('click', () => OMEGA.init());

</script>
</body>
</html>
