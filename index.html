<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Project: N.A.S.A Slime</title>
    <style>
        /* --- STYLE: CYBER-ORGANIC AESTHETIC --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: #00ff9d;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* ป้องกันการ Scroll */
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            filter: blur(0.5px) contrast(1.2);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* ให้กดทะลุไปโดนสไลม์ */
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-text {
            text-shadow: 0 0 5px #00ff9d;
            font-size: 12px;
            opacity: 0.8;
        }

        #debug-console {
            background: rgba(0, 20, 10, 0.7);
            padding: 10px;
            border-left: 2px solid #00ff9d;
            max-height: 100px;
            overflow: hidden;
            font-size: 10px;
        }

        #start-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background: transparent;
            border: 2px solid #00ff9d;
            color: #00ff9d;
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 0 15px #00ff9d;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 10px #00ff9d; }
            50% { box-shadow: 0 0 25px #00ff9d, inset 0 0 10px #00ff9d; }
            100% { box-shadow: 0 0 10px #00ff9d; }
        }

        /* ซ่อน Video element (ใช้แค่ดึงข้อมูลภาพ) */
        #vision-input {
            display: none;
        }
    </style>
</head>
<body>

    <video id="vision-input" autoplay playsinline muted></video>

    <canvas id="canvas"></canvas>

    <div id="ui-layer">
        <div class="hud-text">
            <div>SYSTEM: ONLINE</div>
            <div id="battery-stat">ENERGY: DETECTING...</div>
            <div id="mood-stat">MOOD: NULL</div>
        </div>
        <div id="debug-console">
            > WAITING FOR INITIALIZATION...
        </div>
    </div>

    <button id="start-btn">INITIATE LIFEFORM</button>

    <script>
        /**
         * PROJECT N.A.S.A (Neural Autonomous Slime Agent)
         * Architecture:
         * 1. PhysicsEngine: Soft body dynamics via spring-mass system.
         * 2. VisionCortex: Pixel difference motion detection.
         * 3. BioSystem: Hardware APIs (Battery, Gyro).
         * 4. CoreBrain: State machine & Behavior logic.
         */

        // --- CONFIGURATION ---
        const CONFIG = {
            particleCount: 12,
            radius: 100,
            stiffness: 0.05,
            damping: 0.9,
            visionInterval: 5, // Check vision every 5 frames to save battery
            voiceEnabled: true
        };

        // --- UTILITIES ---
        const log = (msg) => {
            const consoleEl = document.getElementById('debug-console');
            consoleEl.innerHTML += `<div>> ${msg}</div>`;
            consoleEl.scrollTop = consoleEl.scrollHeight;
        };

        const random = (min, max) => Math.random() * (max - min) + min;

        // --- PHYSICS ENGINE (The Body) ---
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.oldx = x;
                this.oldy = y;
            }
        }

        class SlimeBody {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.points = [];
                this.color = '#00ff9d';
                this.targetRadius = CONFIG.radius;
                this.currentRadius = CONFIG.radius;
                this.eyeOpenness = 1.0;
                
                // Create particles in a circle
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / CONFIG.particleCount;
                    const px = this.x + Math.cos(angle) * CONFIG.radius;
                    const py = this.y + Math.sin(angle) * CONFIG.radius;
                    this.points.push(new Point(px, py));
                }
            }

            update(gyroX, gyroY) {
                // 1. Move center based on Gyroscope (Gravity)
                this.x += gyroX * 5;
                this.y += gyroY * 5;

                // Boundary Check
                if(this.x < 0) this.x = 0;
                if(this.x > window.innerWidth) this.x = window.innerWidth;
                if(this.y < 0) this.y = 0;
                if(this.y > window.innerHeight) this.y = window.innerHeight;

                // 2. Physics Loop (Springs)
                for (let i = 0; i < this.points.length; i++) {
                    let p = this.points[i];
                    
                    // Velocity Verlet Integration
                    const vx = (p.x - p.oldx) * CONFIG.damping;
                    const vy = (p.y - p.oldy) * CONFIG.damping;

                    p.oldx = p.x;
                    p.oldy = p.y;
                    p.x += vx;
                    p.y += vy;

                    // Pull towards ideal shape (Circle shape constraint)
                    const angle = (Math.PI * 2 * i) / CONFIG.particleCount;
                    const targetX = this.x + Math.cos(angle) * this.currentRadius;
                    const targetY = this.y + Math.sin(angle) * this.currentRadius;

                    p.x += (targetX - p.x) * CONFIG.stiffness;
                    p.y += (targetY - p.y) * CONFIG.stiffness;

                    // Mouse/Touch interaction repulsion will be handled in Main Loop
                }

                // Breathing effect
                this.currentRadius = this.targetRadius + Math.sin(Date.now() / 500) * 5;
            }

            draw(ctx) {
                // Draw Body
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                
                ctx.beginPath();
                let xc = (this.points[0].x + this.points[this.points.length - 1].x) / 2;
                let yc = (this.points[0].y + this.points[this.points.length - 1].y) / 2;
                ctx.moveTo(xc, yc);

                for (let i = 0; i < this.points.length; i++) {
                    let p = this.points[i];
                    let nextP = this.points[(i + 1) % this.points.length];
                    xc = (p.x + nextP.x) / 2;
                    yc = (p.y + nextP.y) / 2;
                    ctx.quadraticCurveTo(p.x, p.y, xc, yc);
                }
                ctx.closePath();
                ctx.fill();

                // Draw Eyes (The Sensor)
                this.drawEye(ctx, -20, -10);
                this.drawEye(ctx, 20, -10);
            }

            drawEye(ctx, offsetX, offsetY) {
                const eyeX = this.x + offsetX;
                const eyeY = this.y + offsetY;
                
                // Sclera
                ctx.fillStyle = "white";
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.ellipse(eyeX, eyeY, 12, 12 * this.eyeOpenness, 0, 0, Math.PI * 2);
                ctx.fill();

                // Pupil (Tracking Look)
                ctx.fillStyle = "black";
                ctx.shadowBlur = 0;
                ctx.beginPath();
                // Simple look-at logic (follow center screen or noise)
                const lookX = (window.innerWidth/2 - this.x) * 0.05;
                const lookY = (window.innerHeight/2 - this.y) * 0.05;
                ctx.arc(eyeX + Math.max(-5, Math.min(5, lookX)), eyeY + Math.max(-5, Math.min(5, lookY)), 5, 0, Math.PI * 2);
                ctx.fill();
            }

            shock() {
                this.currentRadius = 50; // Shrink instantly
                setTimeout(() => { this.currentRadius = CONFIG.radius + 20 }, 100); // Then expand
            }
        }

        // --- VISION CORTEX (The Eyes) ---
        class VisionCortex {
            constructor() {
                this.video = document.getElementById('vision-input');
                this.tempCanvas = document.createElement('canvas');
                this.tempCtx = this.tempCanvas.getContext('2d');
                this.prevFrame = null;
                this.motionAmount = 0;
                this.initialized = false;
            }

            async init() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
                    this.video.srcObject = stream;
                    this.tempCanvas.width = 64; // Low res for performance
                    this.tempCanvas.height = 64;
                    this.initialized = true;
                    log("VISION SENSORS ACTIVE");
                } catch (e) {
                    log("VISION ERROR: " + e.message);
                }
            }

            detectMotion() {
                if (!this.initialized || this.video.paused || this.video.ended) return 0;

                this.tempCtx.drawImage(this.video, 0, 0, 64, 64);
                const frame = this.tempCtx.getImageData(0, 0, 64, 64);
                const length = frame.data.length;
                let diff = 0;

                if (this.prevFrame) {
                    for (let i = 0; i < length; i += 4) {
                        // Compare Green channel only (optimization)
                        diff += Math.abs(frame.data[i+1] - this.prevFrame.data[i+1]);
                    }
                }

                this.prevFrame = frame;
                // Normalize motion
                this.motionAmount = diff / (64 * 64);
                return this.motionAmount;
            }
        }

        // --- BIO SYSTEM (Hardware Access) ---
        class BioSystem {
            constructor() {
                this.batteryLevel = 1.0;
                this.charging = false;
                this.gyro = { x: 0, y: 0 };
            }

            async init() {
                // Battery
                if (navigator.getBattery) {
                    const battery = await navigator.getBattery();
                    this.updateBattery(battery);
                    battery.addEventListener('levelchange', () => this.updateBattery(battery));
                    battery.addEventListener('chargingchange', () => this.updateBattery(battery));
                }

                // Gyroscope (Gravity)
                window.addEventListener('deviceorientation', (event) => {
                    // Normalize gamma (left/right) and beta (front/back)
                    this.gyro.x = event.gamma ? event.gamma / 45 : 0; 
                    this.gyro.y = event.beta ? (event.beta - 45) / 45 : 0; 
                });
            }

            updateBattery(battery) {
                this.batteryLevel = battery.level;
                this.charging = battery.charging;
                document.getElementById('battery-stat').innerText = 
                    `ENERGY: ${Math.round(this.batteryLevel * 100)}% ${this.charging ? '[CHARGING]' : ''}`;
            }
        }

        // --- CORE BRAIN (Logic) ---
        class CoreBrain {
            constructor(slime, bio, vision) {
                this.slime = slime;
                this.bio = bio;
                this.vision = vision;
                this.state = 'IDLE'; // IDLE, EXCITED, TIRED, SLEEP
                this.lastSpeakTime = 0;
                this.synth = window.speechSynthesis;
            }

            process() {
                // 1. Update Biological State
                const energy = this.bio.batteryLevel;
                const motion = this.vision.motionAmount;

                // 2. State Machine Logic
                if (energy < 0.2 && !this.bio.charging) {
                    this.setState('TIRED');
                } else if (motion > 15) {
                    this.setState('EXCITED');
                } else if (this.bio.charging) {
                    this.setState('HEALING'); // Charging
                } else {
                    this.setState('IDLE');
                }

                // 3. Apply State to Body
                this.applyStateEffects();
            }

            setState(newState) {
                if (this.state === newState) return;
                this.state = newState;
                document.getElementById('mood-stat').innerText = `MOOD: ${this.state}`;
                
                // Reaction on state change
                this.speak(); 
                log(`STATE SHIFT: ${newState}`);
            }

            applyStateEffects() {
                switch (this.state) {
                    case 'EXCITED':
                        this.slime.color = '#ff0055'; // Red
                        this.slime.eyeOpenness = 1.2; // Wide eyes
                        this.slime.targetRadius = 110;
                        break;
                    case 'TIRED':
                        this.slime.color = '#555555'; // Grey
                        this.slime.eyeOpenness = 0.2; // Sleepy eyes
                        this.slime.targetRadius = 80;
                        break;
                    case 'HEALING':
                        this.slime.color = '#00ffff'; // Cyan
                        this.slime.eyeOpenness = 0.5;
                        break;
                    case 'IDLE':
                    default:
                        this.slime.color = '#00ff9d'; // Green
                        this.slime.eyeOpenness = 1.0;
                        this.slime.targetRadius = 100;
                        break;
                }
            }

            speak() {
                if (!CONFIG.voiceEnabled || Date.now() - this.lastSpeakTime < 3000) return;
                
                const phrases = {
                    'EXCITED': ['I see you moving!', 'So much energy!', 'Wow!'],
                    'TIRED': ['Low battery...', 'I need power...', 'Getting dark...'],
                    'HEALING': ['Power surging...', 'Refueling...', 'Ahhh...'],
                    'IDLE': ['System stable.', 'Watching you.', 'Hummm...']
                };

                const text = phrases[this.state][Math.floor(Math.random() * phrases[this.state].length)];
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.pitch = this.state === 'EXCITED' ? 1.5 : 0.8;
                utterance.rate = 1.2;
                this.synth.speak(utterance);
                this.lastSpeakTime = Date.now();
            }
        }

        // --- MAIN SYSTEM ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let slime, vision, bio, brain;
        let frameCount = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);

        // Touch Interaction
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            
            // Vibrate if touched
            if (navigator.vibrate) navigator.vibrate(50);
            
            // Push Slime points away from touch
            slime.points.forEach(p => {
                const dx = p.x - touch.clientX;
                const dy = p.y - touch.clientY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if(dist < 150) {
                    p.x += dx * 0.5; // Push effect
                    p.y += dy * 0.5;
                }
            });
            
            slime.shock();
            log("TOUCH DETECTED");
        });

        function loop() {
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Run Vision less frequently
            if (frameCount % CONFIG.visionInterval === 0) {
                vision.detectMotion();
            }

            // Process Logic
            brain.process();

            // Physics Update
            slime.update(bio.gyro.x, bio.gyro.y);
            slime.draw(ctx);

            frameCount++;
            requestAnimationFrame(loop);
        }

        document.getElementById('start-btn').addEventListener('click', async function() {
            this.style.display = 'none';
            
            resize();
            
            // Initialize Modules
            slime = new SlimeBody(window.innerWidth / 2, window.innerHeight / 2);
            vision = new VisionCortex();
            bio = new BioSystem();
            brain = new CoreBrain(slime, bio, vision);

            await vision.init();
            await bio.init();

            log("SYSTEM INITIALIZED SUCCESSFULLY");
            loop();
        });

    </script>
</body>
</html>
