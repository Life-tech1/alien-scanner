<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OMEGA: HEAVY KERNEL (STABLE)</title>
    
    <!-- LIBRARIES: FIXED VERSIONS FOR STABILITY -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/facemesh@0.0.5"></script> <!-- Switched to stable Facemesh -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

    <style>
        /* --- CYBERPUNK UI STYLES --- */
        :root {
            --primary: #0affc2; --secondary: #008f7a; --accent: #00d2ff;
            --alert: #ff2a6d; --warn: #ffae00; --bg: #000502;
            --glass: rgba(0, 20, 10, 0.85);
            --font-tech: 'Courier New', monospace;
            --font-ui: 'Segoe UI', sans-serif;
        }
        body { margin: 0; overflow: hidden; background: var(--bg); color: var(--primary); font-family: var(--font-ui); }
        canvas { position: absolute; top: 0; left: 0; }
        
        #viewport { position: relative; width: 100vw; height: 100vh; }
        #camera-feed { width: 100%; height: 100%; object-fit: cover; filter: contrast(1.1) brightness(0.8) grayscale(0.2); transform: scaleX(-1); /* Mirror effect */ }
        
        /* LAYERS */
        #layer-3d { z-index: 10; opacity: 0.7; pointer-events: none; }
        #layer-hud { z-index: 20; pointer-events: none; }
        #layer-ui { z-index: 30; position: absolute; inset: 0; padding: 20px; display: flex; flex-direction: column; justify-content: space-between; pointer-events: none; }

        /* FX */
        .scanlines { position: fixed; inset: 0; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 2px, 3px 100%; pointer-events: none; z-index: 900; }
        .vignette { position: fixed; inset: 0; background: radial-gradient(circle, transparent 60%, black 100%); z-index: 901; pointer-events: none; }

        /* PANELS */
        .panel { 
            background: var(--glass); border: 1px solid var(--secondary); border-left: 4px solid var(--primary);
            padding: 15px; margin: 5px; backdrop-filter: blur(10px); pointer-events: auto;
            width: fit-content; min-width: 200px;
            box-shadow: 0 0 15px rgba(10, 255, 194, 0.15);
        }
        .panel-header { font-family: var(--font-tech); font-weight: 900; color: var(--accent); margin-bottom: 8px; letter-spacing: 2px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px; }
        .data-row { display: flex; justify-content: space-between; font-family: var(--font-tech); font-size: 12px; margin-bottom: 4px; color: rgba(255,255,255,0.8); }
        .val { color: var(--primary); font-weight: bold; text-shadow: 0 0 5px var(--primary); }
        .val.alert { color: var(--alert); text-shadow: 0 0 5px var(--alert); }

        /* RADAR */
        #radar-box {
            position: absolute; bottom: 80px; right: 20px; width: 160px; height: 160px;
            background: rgba(0,10,5,0.9); border-radius: 50%; border: 2px solid var(--secondary);
            z-index: 40; overflow: hidden; pointer-events: auto;
        }
        #radar-scan { position: absolute; inset: 0; background: conic-gradient(transparent 270deg, var(--primary)); opacity: 0.3; border-radius: 50%; animation: spin 3s linear infinite; }
        .blip { position: absolute; width: 6px; height: 6px; background: var(--alert); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 8px var(--alert); transition: all 0.2s; }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* BOOT SCREEN */
        #boot-screen {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .loader { border: 4px solid #333; border-top: 4px solid var(--primary); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px; }
        #log-output { font-family: var(--font-tech); font-size: 12px; color: #666; height: 100px; overflow: hidden; text-align: center; white-space: pre-wrap; }
        .error-msg { color: #ff2a6d !important; }
    </style>
</head>
<body>
    
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div id="viewport">
        <video id="camera-feed" autoplay playsinline muted></video>
        <canvas id="layer-3d"></canvas>
        <canvas id="layer-hud"></canvas>
        
        <div id="layer-ui">
            <!-- TOP BAR -->
            <div style="display:flex; justify-content: space-between; width: 100%;">
                <div class="panel">
                    <div class="panel-header">SYSTEM METRICS</div>
                    <div class="data-row"><span>CPU TIME</span><span class="val" id="ui-cpu">0ms</span></div>
                    <div class="data-row"><span>FPS</span><span class="val" id="ui-fps">0</span></div>
                    <div class="data-row"><span>OBJECTS</span><span class="val" id="ui-obj">0</span></div>
                    <div class="data-row"><span>FACES</span><span class="val" id="ui-face">0</span></div>
                </div>
                
                <div class="panel">
                    <div class="panel-header">PHYSICS ENGINE</div>
                    <div class="data-row"><span>DIST EST</span><span class="val" id="ui-dist">--</span></div>
                    <div class="data-row"><span>VELOCITY</span><span class="val" id="ui-vel">CALC...</span></div>
                    <div class="data-row"><span>THREAT</span><span class="val alert" id="ui-threat">NONE</span></div>
                </div>
            </div>

            <!-- BOTTOM -->
            <div style="margin-top: auto;">
                <div class="panel">
                    <div class="panel-header">TACTICAL LOG</div>
                    <div id="tactical-feed" style="font-family: var(--font-tech); font-size: 10px; height: 60px; overflow: hidden; opacity: 0.8;">
                        > KERNEL INITIALIZED...
                    </div>
                </div>
            </div>

            <div id="radar-box">
                <div id="radar-scan"></div>
            </div>
        </div>
    </div>

    <!-- BOOT OVERLAY -->
    <div id="boot-screen">
        <div style="font-size: 40px; font-weight: 900; letter-spacing: 10px; color: var(--primary); margin-bottom: 20px; text-shadow: 0 0 20px var(--primary);">OMEGA</div>
        <div class="loader"></div>
        <div id="log-output">Check Console if stuck...</div>
        <button id="btn-start" style="display:none; margin-top: 20px; padding: 15px 40px; background: transparent; border: 2px solid var(--primary); color: var(--primary); font-weight: bold; cursor: pointer; letter-spacing: 2px;">ENGAGE SYSTEM</button>
    </div>

<script>
/**
 * OMEGA: HEAVY KERNEL (STABLE EDITION)
 */

// --- CONFIGURATION ---
const CONFIG = {
    AI: {
        OBJ_CONFIDENCE: 0.6,
        MAX_OBJECTS: 15,
        FACE_MESH: true
    },
    PHYSICS: {
        FOV_H: 60, 
        FOCAL_LENGTH: 800,
        EST_PERSON_HEIGHT: 1.7 
    },
    TRACKING: {
        MAX_LOST_FRAMES: 5,
        IOU_THRESHOLD: 0.4
    }
};

// --- MATH & UTILITIES ---
const MathUtils = {
    getIOU: (box1, box2) => {
        const x1 = Math.max(box1[0], box2[0]);
        const y1 = Math.max(box1[1], box2[1]);
        const x2 = Math.min(box1[0] + box1[2], box2[0] + box2[2]);
        const y2 = Math.min(box1[1] + box1[3], box2[1] + box2[3]);
        const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
        const area1 = box1[2] * box1[3];
        const area2 = box2[2] * box2[3];
        return intersection / (area1 + area2 - intersection);
    },
    getDistance: (pixelHeight) => {
        if(pixelHeight <= 0) return 0;
        return (CONFIG.PHYSICS.EST_PERSON_HEIGHT * CONFIG.PHYSICS.FOCAL_LENGTH) / pixelHeight;
    },
    projectTo3D: (x, y, distance, width, height) => {
        const nx = (x - width / 2) / (width / 2);
        const ny = -(y - height / 2) / (height / 2); 
        const tanFOV = Math.tan((CONFIG.PHYSICS.FOV_H / 2) * Math.PI / 180);
        return {
            x: nx * distance * tanFOV * (width/height), 
            y: ny * distance * tanFOV,
            z: -distance
        };
    }
};

// --- 3D ENGINE (THREE.JS) ---
class SceneManager {
    constructor() {
        this.canvas = document.getElementById('layer-3d');
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, alpha: true, antialias: true });
        
        this.initScene();
        this.objects3D = new Map();
    }

    initScene() {
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        this.scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0x0affc2, 0.5);
        dirLight.position.set(0, 10, 0);
        this.scene.add(dirLight);

        // Grid
        const gridHelper = new THREE.GridHelper(100, 50, 0x008f7a, 0x002211);
        gridHelper.position.y = -2;
        this.scene.add(gridHelper);
    }

    updateEntities(trackedObjects) {
        const currentIds = trackedObjects.map(t => t.id);
        
        // Remove old
        for (let [id, mesh] of this.objects3D) {
            if (!currentIds.includes(id)) {
                this.scene.remove(mesh);
                this.objects3D.delete(id);
            }
        }

        // Add/Update
        trackedObjects.forEach(obj => {
            if (!this.objects3D.has(obj.id)) {
                const geometry = new THREE.WireframeGeometry(new THREE.BoxGeometry(1, 2, 1));
                const material = new THREE.LineBasicMaterial({ color: 0x0affc2, linewidth: 2 });
                const mesh = new THREE.LineSegments(geometry, material);
                this.scene.add(mesh);
                this.objects3D.set(obj.id, mesh);
            }

            const mesh = this.objects3D.get(obj.id);
            if (obj.worldPos && !isNaN(obj.worldPos.x)) {
                mesh.position.lerp(new THREE.Vector3(obj.worldPos.x, -1, obj.worldPos.z), 0.3);
                mesh.rotation.y += 0.05; 
            }
        });

        this.renderer.render(this.scene, this.camera);
    }

    resize(w, h) {
        this.renderer.setSize(w, h);
        this.camera.aspect = w / h;
        this.camera.updateProjectionMatrix();
    }
}

// --- TRACKING KERNEL ---
class TrackerKernel {
    constructor() {
        this.tracks = []; 
        this.nextId = 1;
    }

    update(detections, videoWidth, videoHeight) {
        const newTracks = [];
        
        // Match detections to tracks
        detections.forEach(det => {
            let bestMatch = null;
            let maxIOU = 0;

            this.tracks.forEach(track => {
                const iou = MathUtils.getIOU(det.bbox, track.bbox);
                if (iou > maxIOU) {
                    maxIOU = iou;
                    bestMatch = track;
                }
            });

            const distance = MathUtils.getDistance(det.bbox[3]);
            const center = [det.bbox[0] + det.bbox[2]/2, det.bbox[1] + det.bbox[3]/2];
            const worldPos = MathUtils.projectTo3D(center[0], center[1], distance, videoWidth, videoHeight);

            if (bestMatch && maxIOU > CONFIG.TRACKING.IOU_THRESHOLD) {
                bestMatch.bbox = det.bbox;
                bestMatch.score = det.score;
                bestMatch.lastSeen = 0;
                bestMatch.distance = distance;
                bestMatch.worldPos = worldPos;
                newTracks.push(bestMatch);
            } else {
                newTracks.push({
                    id: this.nextId++,
                    bbox: det.bbox,
                    label: det.class,
                    score: det.score,
                    lastSeen: 0,
                    distance: distance,
                    worldPos: worldPos
                });
            }
        });

        // Keep lost tracks briefly
        this.tracks.forEach(t => {
            if (t.lastSeen >= 0 && t.lastSeen < CONFIG.TRACKING.MAX_LOST_FRAMES) {
                // Only keep if not matched (checks if it's already in newTracks)
                if(!newTracks.find(nt => nt.id === t.id)) {
                    t.lastSeen++;
                    newTracks.push(t);
                }
            }
        });

        this.tracks = newTracks;
        return this.tracks;
    }
}

// --- MAIN SYSTEM ---
class OmegaSystem {
    constructor() {
        this.video = document.getElementById('camera-feed');
        this.hudCanvas = document.getElementById('layer-hud');
        this.hudCtx = this.hudCanvas.getContext('2d');
        
        this.sceneManager = new SceneManager();
        this.tracker = new TrackerKernel();
        this.models = { object: null, face: null };
        
        this.state = { isRunning: false, frames: 0, lastTime: 0 };
        this.logger = document.getElementById('log-output');
        
        window.addEventListener('resize', () => this.resize());
        this.resize();
    }

    log(msg, isError = false) {
        const span = isError ? `<span class="error-msg">` : `<span>`;
        this.logger.innerHTML += `<div>${span}> ${msg}</span></div>`;
        this.logger.scrollTop = this.logger.scrollHeight;
        
        const tacFeed = document.getElementById('tactical-feed');
        if(tacFeed) {
            tacFeed.innerHTML = `<div>> ${msg}</div>` + tacFeed.innerHTML;
        }
    }

    resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        this.hudCanvas.width = w;
        this.hudCanvas.height = h;
        if(this.sceneManager) this.sceneManager.resize(w, h);
    }

    async boot() {
        try {
            this.log("Loading Neural Networks...");
            
            // Parallel Load
            const loadPromises = [
                cocoSsd.load({ base: 'lite_mobilenet_v2' }).then(m => this.models.object = m)
            ];

            if (CONFIG.AI.FACE_MESH) {
                // Using Facemesh (older, more stable API for this context)
                loadPromises.push(facemesh.load().then(m => this.models.face = m));
            }

            await Promise.all(loadPromises);
            this.log("AI Models Loaded.");

            this.log("Initializing Sensors...");
            
            // Camera Check
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error("Browser does not support Camera API (or HTTP block).");
            }

            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
            });
            this.video.srcObject = stream;
            
            await new Promise((resolve) => {
                this.video.onloadedmetadata = () => {
                    this.video.play();
                    resolve();
                };
            });

            this.log("SYSTEM READY.");
            document.querySelector('.loader').style.borderTopColor = "#0affc2";
            document.getElementById('btn-start').style.display = 'block';
            
        } catch (e) {
            console.error(e);
            this.log(`CRITICAL ERROR: ${e.message}`, true);
        }
    }

    start() {
        document.getElementById('boot-screen').style.display = 'none';
        this.state.isRunning = true;
        this.runLoop();
    }

    async runLoop() {
        if (!this.state.isRunning) return;

        // Safety check for video
        if (this.video.readyState < 2 || this.video.videoWidth === 0) {
            requestAnimationFrame(() => this.runLoop());
            return;
        }

        const now = performance.now();
        this.state.frames++;
        
        // 1. DETECTION
        let faces = [];
        let objects = [];

        try {
            if(this.models.object) {
                objects = await this.models.object.detect(this.video, CONFIG.AI.MAX_OBJECTS, CONFIG.AI.OBJ_CONFIDENCE);
            }
            if (this.models.face) {
                faces = await this.models.face.estimateFaces(this.video);
            }
        } catch(e) {
            console.warn("AI Inference skipped frame");
        }

        // 2. LOGIC UPDATE
        const trackedEntities = this.tracker.update(objects, this.video.videoWidth, this.video.videoHeight);
        
        // 3. 3D UPDATE
        this.sceneManager.updateEntities(trackedEntities);

        // 4. RENDER HUD
        this.renderHUD(trackedEntities, faces);
        
        // 5. UI & STATS
        this.updateUI(trackedEntities, faces, now);

        this.state.lastTime = now;
        requestAnimationFrame(() => this.runLoop());
    }

    renderHUD(tracks, faces) {
        const ctx = this.hudCtx;
        ctx.clearRect(0, 0, this.hudCanvas.width, this.hudCanvas.height);
        
        // Mirror calculation
        const sx = this.hudCanvas.width / this.video.videoWidth;
        const sy = this.hudCanvas.height / this.video.videoHeight;

        // Draw Object Brackets
        tracks.forEach(t => {
            if (t.lastSeen > 2) return; 

            // Standardize coords
            let x = t.bbox[0] * sx;
            let y = t.bbox[1] * sy;
            let w = t.bbox[2] * sx;
            let h = t.bbox[3] * sy;
            
            // Mirror flip correction for display if using CSS transform
            x = this.hudCanvas.width - (x + w); 

            const color = t.label === 'person' ? '#ff2a6d' : '#0affc2';

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            const L = 20;
            // Bracket drawing
            ctx.moveTo(x, y+L); ctx.lineTo(x, y); ctx.lineTo(x+L, y); 
            ctx.moveTo(x+w-L, y); ctx.lineTo(x+w, y); ctx.lineTo(x+w, y+L); 
            ctx.moveTo(x+w, y+h-L); ctx.lineTo(x+w, y+h); ctx.lineTo(x+w-L, y+h); 
            ctx.moveTo(x+L, y+h); ctx.lineTo(x, y+h); ctx.lineTo(x, y+h-L); 
            ctx.stroke();

            // Label
            ctx.fillStyle = color;
            ctx.font = "bold 12px Courier New";
            ctx.fillText(`ID:${t.id} ${t.label.toUpperCase()}`, x, y - 20);
            if(t.distance) ctx.fillText(`${t.distance.toFixed(1)}M`, x, y - 8);
        });

        // Draw Face Mesh
        if (faces && faces.length > 0) {
            ctx.fillStyle = '#00d2ff';
            faces.forEach(face => {
                face.scaledMesh.forEach((pt, i) => {
                    if (i % 3 === 0) { 
                        // Mirror flip for points
                        const fx = this.hudCanvas.width - (pt[0] * sx);
                        const fy = pt[1] * sy;
                        ctx.fillRect(fx, fy, 2, 2);
                    }
                });
            });
        }
    }

    updateUI(tracks, faces, now) {
        if (this.state.frames % 10 === 0) {
            const fps = Math.round(1000 / (now - this.state.lastTime));
            document.getElementById('ui-fps').innerText = isNaN(fps) ? '--' : fps;
            document.getElementById('ui-cpu').innerText = Math.round(performance.now() - now) + "ms";
        }
        
        document.getElementById('ui-obj').innerText = tracks.length;
        document.getElementById('ui-face').innerText = faces.length;

        // Nearest Threat
        const persons = tracks.filter(t => t.label === 'person');
        if (persons.length > 0) {
            const nearest = Math.min(...persons.map(p => p.distance));
            document.getElementById('ui-dist').innerText = nearest.toFixed(1) + "m";
            const threatEl = document.getElementById('ui-threat');
            if (nearest < 2.0) {
                threatEl.innerText = "CRITICAL";
                threatEl.className = "val alert";
            } else {
                threatEl.innerText = "DETECTED";
                threatEl.className = "val";
                threatEl.style.color = "#ffae00";
            }
        } else {
            document.getElementById('ui-dist').innerText = "--";
            document.getElementById('ui-threat').innerText = "SAFE";
            document.getElementById('ui-threat').className = "val";
            document.getElementById('ui-threat').style.color = "#0affc2";
        }

        // Radar
        const radarBox = document.getElementById('radar-box');
        // Clear blips only
        const blips = radarBox.getElementsByClassName('blip');
        while(blips[0]) blips[0].parentNode.removeChild(blips[0]);
        
        tracks.forEach(t => {
            if (t.lastSeen > 2) return;
            const blip = document.createElement('div');
            blip.className = 'blip';
            
            // Map 3D to Radar
            const range = 20; 
            const scale = 80 / range; 
            
            // Invert X because of mirror effect
            let rx = 80 - (t.worldPos.x * scale);
            let ry = 80 + (-t.worldPos.z * scale); 
            
            if (Math.sqrt(Math.pow(rx-80, 2) + Math.pow(ry-80, 2)) < 80) {
                blip.style.left = `${rx}px`;
                blip.style.top = `${ry}px`;
                if (t.label !== 'person') blip.style.background = '#0affc2';
                radarBox.appendChild(blip);
            }
        });
    }
}

// --- INIT ---
const OMEGA = new OmegaSystem();
window.addEventListener('load', () => OMEGA.boot());
document.getElementById('btn-start').addEventListener('click', () => OMEGA.start());

</script>
</body>
</html>
