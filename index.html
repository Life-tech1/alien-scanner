<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <title>Geye Companion: Future Console</title>

    <!-- Core AI -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

    <style>
        :root {
            --primary: #00F0FF;
            /* Cyan Future */
            --alert: #FF2A6D;
            /* Cyber Red */
            --calm: #05D9E8;
            /* Calm Blue */
            --warn: #FFD700;
            /* Gold */
            --glass: rgba(10, 15, 30, 0.65);
            --glass-border: rgba(255, 255, 255, 0.1);
            --font-main: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'SF Mono', 'Courier New', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #000;
            color: #fff;
            font-family: var(--font-main);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            user-select: none;
        }

        /* LAYERS */
        #view-layer {
            position: absolute;
            inset: 0;
            z-index: 0;
        }

        #video-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #canvas-layer {
            position: absolute;
            inset: 0;
            z-index: 1;
            pointer-events: none;
        }

        #ui-layer {
            position: absolute;
            inset: 0;
            z-index: 10;
            pointer-events: none;
        }

        #interaction-layer {
            position: absolute;
            inset: 0;
            z-index: 20;
        }

        /* For clicks */

        /* COMPANION AURA */
        #companion-aura {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--primary);
            box-shadow: 0 0 20px var(--primary);
            opacity: 0.8;
            transition: all 0.5s ease;
            z-index: 100;
            pointer-events: auto;
            cursor: pointer;
        }

        #companion-aura.speaking {
            animation: pulse 1s infinite;
        }

        #companion-aura.alert {
            background: var(--alert);
            box-shadow: 0 0 30px var(--alert);
        }

        #companion-aura.thinking {
            animation: breathe 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.2);
            }

            100% {
                transform: translateX(-50%) scale(1);
            }
        }

        @keyframes breathe {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 0.9;
            }

            100% {
                opacity: 0.5;
            }
        }

        /* HUD CONTROLS */
        .hud-panel {
            position: absolute;
            background: var(--glass);
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 12px;
            pointer-events: auto;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        /* Top Right: System Status */
        #status-panel {
            top: 20px;
            right: 20px;
            text-align: right;
        }

        .stat-item {
            font-family: var(--font-mono);
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 4px;
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
        }

        /* Bottom Center: Mission Control */
        #mission-dock {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            padding: 8px;
            border-radius: 20px;
        }

        .mission-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #fff;
            padding: 10px 20px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mission-btn.active {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 15px var(--primary);
        }

        .mission-btn:active {
            transform: scale(0.95);
        }

        /* Bottom Left: Timeline/Log */
        #log-panel {
            bottom: 30px;
            left: 20px;
            width: 200px;
            max-height: 150px;
            overflow-y: auto;
            font-family: var(--font-mono);
            font-size: 10px;
            display: flex;
            flex-direction: column-reverse;
            /* Newest at bottom */
        }

        .log-entry {
            margin-top: 4px;
            padding-left: 8px;
            border-left: 2px solid var(--primary);
            opacity: 0.8;
        }

        .log-entry.alert {
            border-color: var(--alert);
            color: var(--alert);
        }

        .log-entry.memory {
            border-color: var(--warn);
            color: var(--warn);
        }

        /* BOOT SCREEN */
        #boot-screen {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s;
        }

        .boot-circle {
            width: 60px;
            height: 60px;
            border: 2px solid var(--primary);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }

        /* UTILS */
        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* MISSION OVERLAYS */
        .overlay-grid {
            position: absolute;
            inset: 0;
            pointer-events: none;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 33.3% 33.3%;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .overlay-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40%;
            height: 40%;
            border: 2px dashed var(--alert);
            background: rgba(255, 42, 109, 0.1);
            opacity: 0;
            transition: opacity 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        body[data-mode="film"] .overlay-grid {
            opacity: 1;
        }

        body[data-mode="security"] .overlay-zone {
            opacity: 1;
        }

        /* SNAPSHOT BUTTON (FILM MODE) */
        #snap-btn {
            position: absolute;
            right: 20px;
            bottom: 100px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #fff;
            background: rgba(255, 255, 255, 0.2);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        body[data-mode="film"] #snap-btn {
            opacity: 1;
            pointer-events: auto;
        }

        #snap-btn:active {
            background: #fff;
        }
    </style>
</head>

<body>

    <!-- BOOT SCREEN -->
    <div id="boot-screen">
        <div class="boot-circle"></div>
        <div style="font-size: 12px; letter-spacing: 2px; color: var(--primary);">INITIALIZING GEYE COMPANION</div>
        <div id="boot-log" style="font-size: 10px; color: #666; margin-top: 10px;">Loading Neural Core...</div>
        <button id="start-btn" class="mission-btn hidden" style="margin-top: 20px;">ACTIVATE</button>
    </div>

    <!-- MAIN VIEW -->
    <div id="view-layer">
        <video id="video-feed" autoplay playsinline muted></video>
    </div>

    <canvas id="canvas-layer"></canvas>

    <!-- OFFSCREEN INFERENCE CANVAS -->
    <canvas id="inference-canvas" style="display: none;"></canvas>

    <!-- UI LAYER -->
    <div id="ui-layer">
        <!-- Companion Avatar -->
        <div id="companion-aura"></div>

        <!-- Status -->
        <div id="status-panel" class="hud-panel">
            <div class="stat-item">FPS: <span id="fps-val" class="stat-value">--</span></div>
            <div class="stat-item">LATENCY: <span id="lat-val" class="stat-value">--</span>ms</div>
            <div class="stat-item">OBJECTS: <span id="obj-val" class="stat-value">0</span></div>
            <div class="stat-item">MODE: <span id="mode-val" class="stat-value">IDLE</span></div>
        </div>

        <!-- Mission Overlays -->
        <div class="overlay-grid"></div>
        <div class="overlay-zone"><span
                style="color:var(--alert); font-size:10px; background:#000; padding:2px 4px;">RESTRICTED</span></div>

        <!-- Logs -->
        <div id="log-panel" class="hud-panel">
            <!-- Logs injected here -->
        </div>

        <!-- Controls -->
        <div id="mission-dock" class="hud-panel">
            <button class="mission-btn active" data-mode="standard">Standard</button>
            <button class="mission-btn" data-mode="film">Film</button>
            <button class="mission-btn" data-mode="security">Security</button>
            <button class="mission-btn" data-mode="explorer">Explorer</button>
        </div>

        <!-- Snapshot Button -->
        <button id="snap-btn"></button>
    </div>

    <!-- INTERACTION LAYER -->
    <div id="interaction-layer"></div>

    <script>
        /**
         * GEYE COMPANION - FUTURE FIELD CONSOLE
         * Architecture: Modular Monolith
         * 1. VisionCore: Perception (TFJS, Kalman)
         * 2. ContextBrain: Understanding (Mood, Memory)
         * 3. MissionController: Action (Modes)
         * 4. HUDManager: UI/UX
         */

        // --- UTILS ---
        const $ = (sel) => document.querySelector(sel);
        const $$ = (sel) => document.querySelectorAll(sel);
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));

        // --- 1. VISION CORE (THE EYE) ---
        class VisionCore {
            constructor(app) {
                this.app = app;
                this.video = $('#video-feed');
                this.canvas = $('#canvas-layer');
                this.ctx = this.canvas.getContext('2d');
                this.infCanvas = $('#inference-canvas');
                this.infCtx = this.infCanvas.getContext('2d');

                this.model = null;
                this.isActive = false;

                // Adaptive Loop
                this.lastFrameTime = 0;
                this.inferenceInterval = 50;
                this.lastInferenceTime = 0;
                this.isInferencing = false;

                // Tracker
                this.tracks = [];
                this.nextId = 1;
                this.lockedId = null;
            }

            async init() {
                this.app.log("Loading Vision Model...");
                await tf.ready();
                try {
                    await tf.setBackend('webgl');
                } catch (e) {
                    this.app.log("WebGL unavailable, using WASM", "warn");
                    await tf.setBackend('wasm');
                }

                this.model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });

                // Warmup
                this.app.log("Warming up Neural Engine...");
                const dummy = tf.zeros([300, 300, 3]); // FIXED: 3D Tensor
                await this.model.detect(dummy);
                dummy.dispose();

                await this.setupCamera(); // FIXED: Await camera
            }

            async setupCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
                        audio: false
                    });
                    this.video.srcObject = stream;
                    await new Promise(r => this.video.onloadedmetadata = r);
                    this.app.log("Camera Active");
                    this.resize();
                    window.addEventListener('resize', () => this.resize());
                } catch (e) {
                    this.app.log("Camera Error: " + e.message, 'alert');
                }
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // Downscale for inference (Max 320px long side)
                const aspect = this.video.videoWidth / this.video.videoHeight;
                const size = 320;
                if (aspect > 1) {
                    this.infCanvas.width = size;
                    this.infCanvas.height = size / aspect;
                } else {
                    this.infCanvas.width = size * aspect;
                    this.infCanvas.height = size;
                }
                this.scaleX = this.canvas.width / this.infCanvas.width;
                this.scaleY = this.canvas.height / this.infCanvas.height;
            }

            start() {
                this.isActive = true;
                this.loop();
            }

            loop() {
                if (!this.isActive) return;
                requestAnimationFrame(() => this.loop());

                const now = performance.now();
                this.render();

                if (!this.isInferencing && (now - this.lastInferenceTime > this.inferenceInterval)) {
                    this.runInference();
                }
            }

            async runInference() {
                this.isInferencing = true;
                const start = performance.now();

                this.infCtx.drawImage(this.video, 0, 0, this.infCanvas.width, this.infCanvas.height);
                const predictions = await this.model.detect(this.infCanvas);
                this.updateTracker(predictions);

                const duration = performance.now() - start;
                this.lastInferenceTime = performance.now();
                this.isInferencing = false;

                this.inferenceInterval = Math.max(30, duration * 1.2);
                $('#lat-val').innerText = Math.round(duration);
                $('#obj-val').innerText = this.tracks.length;
            }

            updateTracker(predictions) {
                this.tracks.forEach(t => {
                    t.x += t.vx; t.y += t.vy;
                    t.missed++;
                });

                const matched = new Set();

                if (this.lockedId) {
                    const lockedTrack = this.tracks.find(t => t.id === this.lockedId);
                    if (lockedTrack) {
                        const match = this.findBestMatch(lockedTrack, predictions, matched, 0.15);
                        if (match) {
                            this.updateTrack(lockedTrack, match);
                            matched.add(match);
                        }
                    }
                }

                this.tracks.forEach(t => {
                    if (t.id === this.lockedId) return;
                    const match = this.findBestMatch(t, predictions, matched, 0.3);
                    if (match) {
                        this.updateTrack(t, match);
                        matched.add(match);
                    }
                });

                predictions.forEach(p => {
                    if (!matched.has(p)) this.createTrack(p);
                });

                this.tracks = this.tracks.filter(t => t.missed < 20);
                this.app.brain.processPerception(this.tracks);
            }

            findBestMatch(track, predictions, matchedSet, threshold) {
                let best = null;
                let maxIoU = 0;

                predictions.forEach(p => {
                    if (matchedSet.has(p)) return;
                    if (p.class !== track.class) return;

                    const pBox = this.scaleBox(p.bbox);
                    const IoU = this.getIoU(track, pBox);

                    if (IoU > threshold && IoU > maxIoU) {
                        maxIoU = IoU;
                        best = p;
                    }
                });
                return best;
            }

            updateTrack(track, prediction) {
                const box = this.scaleBox(prediction.bbox);
                const alpha = 0.3;
                const dx = box.x - track.x;
                const dy = box.y - track.y;

                track.x += dx * alpha;
                track.y += dy * alpha;
                track.w += (box.w - track.w) * alpha;
                track.h += (box.h - track.h) * alpha;

                track.vx = dx * 0.5;
                track.vy = dy * 0.5;
                track.score = prediction.score;
                track.missed = 0;
            }

            createTrack(prediction) {
                const box = this.scaleBox(prediction.bbox);
                this.tracks.push({
                    id: this.nextId++,
                    class: prediction.class,
                    score: prediction.score,
                    x: box.x, y: box.y, w: box.w, h: box.h,
                    vx: 0, vy: 0,
                    missed: 0,
                    firstSeen: Date.now()
                });
            }

            scaleBox(bbox) {
                return {
                    x: bbox[0] * this.scaleX,
                    y: bbox[1] * this.scaleY,
                    w: bbox[2] * this.scaleX,
                    h: bbox[3] * this.scaleY
                };
            }

            getIoU(boxA, boxB) {
                const xA = Math.max(boxA.x, boxB.x);
                const yA = Math.max(boxA.y, boxB.y);
                const xB = Math.min(boxA.x + boxA.w, boxB.x + boxB.w);
                const yB = Math.min(boxA.y + boxA.h, boxB.y + boxB.h);

                const interArea = Math.max(0, xB - xA) * Math.max(0, yB - yA);
                const boxAArea = boxA.w * boxA.h;
                const boxBArea = boxB.w * boxB.h;
                return interArea / (boxAArea + boxBArea - interArea);
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.app.mission.render(this.ctx, this.tracks);
            }

            lockTarget(x, y) {
                let best = null;
                let minDist = 100;

                this.tracks.forEach(t => {
                    const cx = t.x + t.w / 2;
                    const cy = t.y + t.h / 2;
                    const dist = Math.hypot(cx - x, cy - y);
                    if (dist < minDist) {
                        minDist = dist;
                        best = t;
                    }
                });

                if (best) {
                    this.lockedId = best.id;
                    this.app.speak(`Target locked. ${best.class}.`);
                    this.app.log(`Locked ID ${best.id} (${best.class})`);
                } else {
                    this.lockedId = null;
                    this.app.speak("Target released.");
                }
            }
        }

        // --- 2. CONTEXT BRAIN (THE SOUL) ---
        class ContextBrain {
            constructor(app) {
                this.app = app;
                this.mood = 'calm';
                this.memory = new MemoryStream();
            }

            async init() {
                try {
                    await this.memory.init();
                    this.loadRecentMemories();
                } catch (e) {
                    this.app.log("Memory DB unavailable (file://). Running volatile.", "warn");
                    this.memory = null;
                }
            }

            async loadRecentMemories() {
                if (!this.memory) return;
                const recent = await this.memory.getRecent(3);
                recent.reverse().forEach(m => this.app.log(m.text, 'memory'));
            }

            processPerception(tracks) {
                if (this.app.vision.lockedId) {
                    this.setMood('focused');
                } else if (this.app.mission.currentMode === 'security' && this.app.mission.isThreatDetected) {
                    this.setMood('alert');
                } else if (tracks.length > 3) {
                    this.setMood('curious');
                } else {
                    this.setMood('calm');
                }
            }

            setMood(newMood) {
                if (this.mood === newMood) return;
                this.mood = newMood;

                const aura = $('#companion-aura');
                aura.className = '';
                if (newMood === 'alert') aura.classList.add('alert');
                if (newMood === 'focused') aura.classList.add('thinking');
            }

            async addMemory(text, type = 'info', snapshot = null) {
                this.app.log(text, type);
                if (this.memory) {
                    await this.memory.add({ text, type, timestamp: Date.now(), snapshot });
                }
            }
        }

        class MemoryStream {
            constructor() {
                this.dbName = 'GeyeCompanionDB';
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(this.dbName, 1);
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('memories')) {
                            db.createObjectStore('memories', { keyPath: 'id', autoIncrement: true });
                        }
                    };
                    req.onsuccess = (e) => {
                        this.db = e.target.result;
                        resolve();
                    };
                    req.onerror = reject;
                });
            }

            async add(data) {
                if (!this.db) return;
                const tx = this.db.transaction('memories', 'readwrite');
                tx.objectStore('memories').add(data);
            }

            async getRecent(limit) {
                if (!this.db) return [];
                return new Promise(resolve => {
                    const tx = this.db.transaction('memories', 'readonly');
                    const store = tx.objectStore('memories');
                    const req = store.openCursor(null, 'prev');
                    const results = [];
                    req.onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor && results.length < limit) {
                            results.push(cursor.value);
                            cursor.continue();
                        } else {
                            resolve(results);
                        }
                    };
                });
            }
        }

        // --- 3. MISSION CONTROLLER (THE HANDS) ---
        class MissionController {
            constructor(app) {
                this.app = app;
                this.currentMode = 'standard';
                this.isThreatDetected = false;
                this.mediaRecorder = null;
                this.isRecording = false;
                this.lastExplorerSpeak = 0;
            }

            setMode(mode) {
                this.currentMode = mode;
                document.body.setAttribute('data-mode', mode);
                $('#mode-val').innerText = mode.toUpperCase();

                $$('.mission-btn').forEach(b => b.classList.remove('active'));
                $(`.mission-btn[data-mode="${mode}"]`).classList.add('active');

                this.app.speak(`${mode} mode active.`);
                this.app.brain.addMemory(`Switched to ${mode} mode`);

                this.isThreatDetected = false;
                if (this.isRecording) this.stopRecording();
            }

            render(ctx, tracks) {
                let threatFound = false;

                tracks.forEach(t => {
                    const isLocked = (t.id === this.app.vision.lockedId);

                    if (this.currentMode === 'minimal' && !isLocked) {
                        this.drawCornerBrackets(ctx, t, '#fff');
                    } else if (this.currentMode === 'security') {
                        const isThreat = this.checkThreat(t);
                        if (isThreat) threatFound = true;

                        const color = isThreat ? '#FF2A6D' : '#00F0FF';
                        this.drawBox(ctx, t, color, isLocked);
                        if (isThreat) this.drawLabel(ctx, t, `THREAT ${Math.round(t.score * 100)}%`, color);
                    } else {
                        const color = isLocked ? '#FFD700' : '#00F0FF';
                        this.drawCornerBrackets(ctx, t, color);
                        if (isLocked || this.currentMode === 'explorer') {
                            this.drawLabel(ctx, t, t.class.toUpperCase(), color);
                        }
                    }
                });

                if (this.currentMode === 'security') {
                    if (threatFound && !this.isThreatDetected) {
                        this.handleThreatStart();
                    } else if (!threatFound && this.isThreatDetected) {
                        this.isThreatDetected = false;
                    }
                }

                if (this.currentMode === 'explorer') {
                    this.handleExplorer(tracks);
                }
            }

            handleThreatStart() {
                this.isThreatDetected = true;
                this.app.speak("Security Breach Detected.");
                this.app.brain.addMemory("Security Breach Detected", "alert");
                this.startRecording();
            }

            startRecording() {
                if (this.isRecording) return;
                try {
                    const stream = this.app.vision.canvas.captureStream(30);
                    this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                    const chunks = [];
                    this.mediaRecorder.ondataavailable = e => chunks.push(e.data);
                    this.mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        this.app.brain.addMemory("Video Log Saved", "info", blob);
                    };
                    this.mediaRecorder.start();
                    this.isRecording = true;
                    this.app.log("Recording Started...", "alert");
                    setTimeout(() => this.stopRecording(), 10000);
                } catch (e) {
                    console.error("Recording failed", e);
                }
            }

            stopRecording() {
                if (!this.isRecording || !this.mediaRecorder) return;
                this.mediaRecorder.stop();
                this.isRecording = false;
                this.app.log("Recording Saved");
            }

            handleExplorer(tracks) {
                const now = Date.now();
                if (now - this.lastExplorerSpeak < 4000) return;

                const cx = window.innerWidth / 2;
                const cy = window.innerHeight / 2;
                let best = null;
                let minDist = 150;

                tracks.forEach(t => {
                    const tcx = t.x + t.w / 2;
                    const tcy = t.y + t.h / 2;
                    const dist = Math.hypot(tcx - cx, tcy - cy);
                    if (dist < minDist) {
                        minDist = dist;
                        best = t;
                    }
                });

                if (best) {
                    this.app.speak(`I see a ${best.class}`);
                    this.lastExplorerSpeak = now;
                }
            }

            takeSnapshot() {
                this.app.vision.canvas.toBlob(blob => {
                    this.app.brain.addMemory("Snapshot Taken", "info", blob);
                    this.app.speak("Snapshot saved.");
                });
            }

            drawCornerBrackets(ctx, t, color) {
                const len = 10;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(t.x, t.y + len); ctx.lineTo(t.x, t.y); ctx.lineTo(t.x + len, t.y);
                ctx.moveTo(t.x + t.w - len, t.y); ctx.lineTo(t.x + t.w, t.y); ctx.lineTo(t.x + t.w, t.y + len);
                ctx.moveTo(t.x, t.y + t.h - len); ctx.lineTo(t.x, t.y + t.h); ctx.lineTo(t.x + len, t.y + t.h);
                ctx.moveTo(t.x + t.w - len, t.y + t.h); ctx.lineTo(t.x + t.w, t.y + t.h); ctx.lineTo(t.x + t.w, t.y + t.h - len);
                ctx.stroke();
            }

            drawBox(ctx, t, color, isLocked) {
                ctx.strokeStyle = color;
                ctx.lineWidth = isLocked ? 3 : 1;
                ctx.strokeRect(t.x, t.y, t.w, t.h);
            }

            drawLabel(ctx, t, text, color) {
                ctx.fillStyle = color;
                ctx.font = '10px "SF Mono"';
                ctx.fillText(text, t.x, t.y - 5);
            }

            checkThreat(t) {
                if (t.class !== 'person') return false;
                const cx = t.x + t.w / 2;
                const cy = t.y + t.h / 2;
                const zx = window.innerWidth / 2;
                const zy = window.innerHeight / 2;
                const zw = window.innerWidth * 0.4;
                const zh = window.innerHeight * 0.4;
                return (cx > zx - zw / 2 && cx < zx + zw / 2 && cy > zy - zh / 2 && cy < zy + zh / 2);
            }
        }

        // --- 4. APP CONTROLLER (ORCHESTRATOR) ---
        class App {
            constructor() {
                this.vision = new VisionCore(this);
                this.brain = new ContextBrain(this);
                this.mission = new MissionController(this);
                this.setupUI();
            }

            async start() {
                $('#start-btn').innerText = "STARTING...";
                await this.brain.init();
                await this.vision.init();
                this.vision.start();
                $('#boot-screen').classList.add('hidden');
                this.speak("System Online.");
            }

            setupUI() {
                setTimeout(() => $('#start-btn').classList.remove('hidden'), 1000);
                $('#start-btn').onclick = () => this.start();

                $('#interaction-layer').onclick = (e) => {
                    this.vision.lockTarget(e.clientX, e.clientY);
                };

                $$('.mission-btn').forEach(btn => {
                    btn.onclick = () => this.mission.setMode(btn.dataset.mode);
                });

                $('#snap-btn').onclick = (e) => {
                    e.stopPropagation();
                    this.mission.takeSnapshot();
                };
            }

            log(msg, type = 'info') {
                const div = document.createElement('div');
                div.className = `log-entry ${type}`;
                div.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
                $('#log-panel').prepend(div);
            }

            speak(text) {
                if (!window.speechSynthesis) return;
                const u = new SpeechSynthesisUtterance(text);
                u.rate = 1.1;
                u.pitch = 1.0;
                $('#companion-aura').classList.add('speaking');
                u.onend = () => $('#companion-aura').classList.remove('speaking');
                window.speechSynthesis.speak(u);
            }
        }

        // --- BOOT ---
        window.GeyeApp = new App();

    </script>
</body>

</html>
