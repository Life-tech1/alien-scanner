<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ENTITY</title>
    
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiRW50aXR5IiwiYmFja2dyb3VuZF9jb2xvciI6IiMwMDAwMDAiLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsInRoZW1lX2NvbG9yIjoiIzAwMDAwMCIsImljb25zIjpWXX0=">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #hud {
            position: absolute; bottom: 40px; left: 0; width: 100%;
            text-align: center; pointer-events: none;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: rgba(255,255,255,0.4); font-size: 12px; letter-spacing: 2px;
            text-transform: uppercase;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; font-size: 12px; letter-spacing: 4px;
        }
    </style>
</head>
<body>

    <div id="loading">INITIALIZING NEURAL GPU...</div>
    <div id="hud">Touch to Disturb â€¢ Tilt to Flow</div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. THE SHADER (The "Soul" of the visual) ---
        // This runs on GPU, calculating pixel-by-pixel liquid physics
        const fragmentShader = `
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform vec2 u_gyro;
            
            // Noise Function
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v - i + dot(i, C.xx);
                vec2 i1;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m ;
                m = m*m ;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }

            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution.xy;
                st.x *= u_resolution.x / u_resolution.y;
                
                // Liquid Distortion based on Gyro and Mouse
                vec2 pos = st * 3.0;
                
                // Physics: Gyro shift
                pos.x += u_gyro.x * 1.5; 
                pos.y += u_gyro.y * 1.5;

                // Base Noise (The Organism)
                float df = 1.0;
                float a = 0.0;
                vec2 vel = vec2(u_time * 0.1);
                df = snoise(pos + vel) * 0.5 + 0.5;

                // Detailed noise layers
                float n1 = snoise(pos * 2.0 - u_time * 0.2);
                float n2 = snoise(pos * 4.0 + u_time * 0.1 + (u_mouse * 2.0));
                
                // Mix layers to create "Ferrofluid" look
                float liquid = smoothstep(0.4, 0.6, df + n1 * 0.4 + n2 * 0.1);
                
                // Coloring (Sci-Fi Dark Matter)
                vec3 colorBg = vec3(0.05, 0.05, 0.08); // Dark Void
                vec3 colorCore = vec3(0.0, 0.8, 0.9); // Cyan Core
                vec3 colorEdge = vec3(0.6, 0.0, 0.8); // Purple Edge

                // Gradient Mix
                vec3 finalColor = mix(colorBg, colorEdge, liquid);
                finalColor = mix(finalColor, colorCore, smoothstep(0.6, 0.8, liquid));
                
                // Add "Glow"
                finalColor += vec3(liquid * 0.2);

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // --- 3. UNIFORMS (Connecting JS to GPU) ---
        const uniforms = {
            u_time: { value: 0.0 },
            u_resolution: { value: new THREE.Vector2() },
            u_mouse: { value: new THREE.Vector2() },
            u_gyro: { value: new THREE.Vector2() }
        };

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            fragmentShader: fragmentShader
        });

        const plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
        scene.add(plane);

        // --- 4. INPUT HANDLERS ---
        let mouseTarget = { x: 0, y: 0 };
        let gyroTarget = { x: 0, y: 0 };

        window.addEventListener('mousemove', (e) => {
            mouseTarget.x = e.clientX / window.innerWidth;
            mouseTarget.y = 1.0 - (e.clientY / window.innerHeight);
        });

        window.addEventListener('touchmove', (e) => {
            mouseTarget.x = e.touches[0].clientX / window.innerWidth;
            mouseTarget.y = 1.0 - (e.touches[0].clientY / window.innerHeight);
        }, {passive: false});

        window.addEventListener('deviceorientation', (e) => {
            gyroTarget.x = e.gamma ? e.gamma / 45 : 0;
            gyroTarget.y = e.beta ? (e.beta - 45) / 45 : 0;
        });

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.u_resolution.value.x = renderer.domElement.width;
            uniforms.u_resolution.value.y = renderer.domElement.height;
        });

        // Init Resolution
        uniforms.u_resolution.value.x = renderer.domElement.width;
        uniforms.u_resolution.value.y = renderer.domElement.height;

        // Hide Loading
        document.getElementById('loading').style.display = 'none';

        // --- 5. RENDER LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();
            uniforms.u_time.value += delta;

            // Smooth interpolation (Lag adds weight/realism)
            uniforms.u_mouse.value.x += (mouseTarget.x - uniforms.u_mouse.value.x) * 0.1;
            uniforms.u_mouse.value.y += (mouseTarget.y - uniforms.u_mouse.value.y) * 0.1;
            
            uniforms.u_gyro.value.x += (gyroTarget.x - uniforms.u_gyro.value.x) * 0.05;
            uniforms.u_gyro.value.y += (gyroTarget.y - uniforms.u_gyro.value.y) * 0.05;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
