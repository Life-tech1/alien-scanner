<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
  <title>LUMEN-OPS ΩMEGA — QUANTUM HUMANOID SENSE CONSOLE</title>

  <!-- Core ML -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.22.0/dist/tf-backend-webgl.min.js"></script>

  <!-- Vision models -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@3.0.0/dist/pose-detection.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-segmentation@1.0.2/dist/body-segmentation.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.6/dist/face-landmarks-detection.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.min.js"></script>

  <!-- OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>

  <!-- MediaPipe audio tasks -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-audio@0.10.22-rc.20250304/audio_bundle.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --hud:#00ff66;
      --hud-dim:rgba(0,255,102,.15);
      --hud-dim2:rgba(0,255,102,.08);
      --bg: #020402;
      --glass: rgba(4,14,8,.55);
      --glass-strong: rgba(4,14,8,.78);
      --warn:#ffcf40;
      --danger:#ff5d5d;
      --ok:#64ff9b;
      --font: system-ui, -apple-system, Segoe UI, Inter, Roboto, sans-serif;
    }
    html,body{margin:0;height:100%;background:#000;color:var(--hud);font-family:var(--font);overflow:hidden;}
    #stage{position:fixed;inset:0;background:#000;}
    video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;background:#000;}
    canvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;}

    /* UI */
    .panel{
      position:fixed; z-index:10; color:var(--hud);
      background:linear-gradient(180deg,var(--glass),rgba(2,8,4,.2));
      border:1px solid var(--hud-dim);
      border-radius:14px; backdrop-filter: blur(8px);
      box-shadow: 0 10px 30px rgba(0,0,0,.6), inset 0 0 30px rgba(0,255,102,.05);
      padding:10px 12px; font-size:12px; letter-spacing:.3px;
      transition: transform .35s ease, opacity .35s ease;
      user-select:none;
    }
    .panel.hidden{opacity:.2}
    .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap;}
    .title{font-weight:700; font-size:12px; opacity:.9;}
    .sub{opacity:.75; font-size:11px;}
    .kv{display:grid;grid-template-columns:auto 1fr;gap:2px 8px;margin-top:6px}
    .kv div:nth-child(odd){opacity:.7}
    .chip{
      display:inline-flex;align-items:center;gap:6px;
      padding:3px 7px;border-radius:999px;
      background:var(--hud-dim2); border:1px solid var(--hud-dim); font-size:11px;
    }
    .dot{width:8px;height:8px;border-radius:50%;background:#244;box-shadow:0 0 0 1px #0f4 inset;}
    .dot.ok{background:var(--ok);box-shadow:0 0 8px var(--ok);}
    .dot.warn{background:var(--warn);box-shadow:0 0 8px var(--warn);}
    .dot.danger{background:var(--danger);box-shadow:0 0 8px var(--danger);}

    button{
      background:transparent; color:var(--hud);
      border:1px solid var(--hud-dim); border-radius:10px;
      padding:6px 10px; font-size:12px; cursor:pointer;
      transition:.2s ease; outline:none;
    }
    button:hover{background:var(--hud-dim2)}
    button.active{background:var(--hud-dim); box-shadow:0 0 0 1px var(--hud) inset;}
    button.danger{border-color:rgba(255,93,93,.5); color:var(--danger);}
    button.warn{border-color:rgba(255,207,64,.5); color:var(--warn);}

    #hudTop{top:10px;left:10px;max-width:58vw;}
    #hudRight{top:10px;right:10px;max-width:36vw;}
    #hudBottom{bottom:10px;left:10px;max-width:75vw;}
    #radarPanel{bottom:10px;right:10px;width:220px;}
    #radarCanvas{width:100%;height:150px;display:block;border-radius:10px;background:#0008;border:1px dashed var(--hud-dim);}
    #heatCanvas{width:100%;height:90px;display:block;border-radius:10px;background:#0008;border:1px dashed var(--hud-dim);margin-top:6px;}

    #reticle{
      position:fixed; inset:0; pointer-events:none; z-index:9;
      background:
        radial-gradient(closest-side,rgba(0,255,102,.12),transparent 60%),
        radial-gradient(circle at center, transparent 0 30%, rgba(0,255,102,.1) 31% 31.5%, transparent 33%);
      mix-blend-mode:screen; opacity:.6;
    }

    #toast{
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      background:var(--glass-strong); border:1px solid var(--hud-dim);
      padding:8px 12px; border-radius:12px; font-size:12px; z-index:30;
      opacity:0; transition:.25s ease;
    }
    #toast.show{opacity:1; transform:translateX(-50%) translateY(-4px);}

    #zoneOverlay{
      position:fixed; inset:0; z-index:8; pointer-events:none;
    }
    #zoneOverlay.edit{pointer-events:auto; cursor:crosshair;}

    .list{max-height:130px; overflow:auto; padding-right:4px;}
    .list::-webkit-scrollbar{width:6px}
    .list::-webkit-scrollbar-thumb{background:var(--hud-dim);border-radius:6px}

    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
    .tiny{font-size:10px; opacity:.75}

    /* Corner docking via transforms */
    .dock-tl{transform:translate(0,0);}
    .dock-tr{transform:translate(0,0);}
    .dock-bl{transform:translate(0,0);}
    .dock-br{transform:translate(0,0);}
  </style>
</head>

<body>
  <div id="stage">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
    <canvas id="segCanvas"></canvas>
    <canvas id="zoneOverlay"></canvas>
    <div id="reticle"></div>
  </div>

  <!-- TOP LEFT -->
  <div id="hudTop" class="panel">
    <div class="row" style="justify-content:space-between">
      <div>
        <div class="title">LUMEN-OPS ΩMEGA</div>
        <div class="sub">Quantum Humanoid Sense Console · v5.0</div>
      </div>
      <div class="chip mono"><span id="fps">0</span> FPS</div>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="btnInit">INITIALIZE</button>
      <button id="btnPause" class="warn">PAUSE</button>
      <button id="btnLock">MAG-LOCK</button>
      <button id="btnZones">ZONES</button>
      <button id="btnOCR">OCR SNAP</button>
      <button id="btnAudio">AUDIO</button>
      <button id="btnExport">EXPORT</button>
    </div>
    <div class="kv mono" id="statusKV"></div>
  </div>

  <!-- TOP RIGHT -->
  <div id="hudRight" class="panel">
    <div class="title">MODULES</div>
    <div class="row" style="margin-top:6px">
      <div class="chip"><span class="dot" id="dotDet"></span> DETECT</div>
      <div class="chip"><span class="dot" id="dotPose"></span> POSE</div>
      <div class="chip"><span class="dot" id="dotSeg"></span> SEG</div>
      <div class="chip"><span class="dot" id="dotFace"></span> FACE</div>
      <div class="chip"><span class="dot" id="dotHand"></span> HAND</div>
      <div class="chip"><span class="dot" id="dotIMU"></span> IMU</div>
      <div class="chip"><span class="dot" id="dotGPS"></span> GPS</div>
      <div class="chip"><span class="dot" id="dotAud"></span> AUD</div>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="tglPose" class="active">POSE ON</button>
      <button id="tglSeg">SEG OFF</button>
      <button id="tglFace">FACE OFF</button>
      <button id="tglHand">HAND OFF</button>
    </div>
    <div class="kv mono" id="imuKV"></div>
  </div>

  <!-- BOTTOM LEFT -->
  <div id="hudBottom" class="panel">
    <div class="title">TARGET MEMORY</div>
    <div id="memoryList" class="list mono tiny" style="margin-top:6px"></div>
  </div>

  <!-- BOTTOM RIGHT -->
  <div id="radarPanel" class="panel">
    <div class="title">RADAR · HEATMAP</div>
    <canvas id="radarCanvas" width="220" height="150"></canvas>
    <canvas id="heatCanvas" width="220" height="90"></canvas>
    <div class="kv mono tiny" id="threatKV"></div>
    <div class="tiny" id="audioLine" style="margin-top:6px"></div>
  </div>

  <div id="toast" class="mono"></div>

<script>
(() => {
  "use strict";

  // ===== Utilities =====
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const now=()=>performance.now();
  const fmt=(n,d=2)=>Number.isFinite(n)?n.toFixed(d):"--";
  const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy};

  function toast(msg, ms=1600){
    const t=document.getElementById("toast");
    t.textContent=msg;
    t.classList.add("show");
    clearTimeout(toast._tm);
    toast._tm=setTimeout(()=>t.classList.remove("show"),ms);
  }
  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

  // ===== SensorHub (from v4, extended) =====
  class SensorHub {
    constructor(){
      this.pitch=0; this.roll=0; this.heading=0;
      this.gForce=1.0;
      this.rotationRate={alpha:0,beta:0,gamma:0};
      this.accel={x:0,y:0,z:0}; this.gyro={x:0,y:0,z:0};
      this.mag={x:0,y:0,z:0}; this.lightLux=null;
      this.geo={lat:null,lon:null,acc:null,speed:null};
      this.batt={level:null,charging:null};
      this.net={type:null,downlink:null,rtt:null};
      this.isAvailable={imu:false,genericImu:false,mag:false,light:false,geo:false,battery:false,network:false};
    }
    async init(){
      if(!window.isSecureContext){
        toast("Sensors blocked: use HTTPS / localhost (not file://)");
        console.warn("Sensors blocked: not on secure context");
        return false;
      }
      try{
        if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
          const s=await DeviceOrientationEvent.requestPermission();
          if(s!=="granted") throw new Error("orientation denied");
        }
        if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
          const s=await DeviceMotionEvent.requestPermission();
          if(s!=="granted") throw new Error("motion denied");
        }
      }catch(e){ console.warn("iOS permission", e); }

      window.addEventListener("deviceorientation",(e)=>{
        this.pitch=e.beta||0; this.roll=e.gamma||0; this.heading=e.alpha||0;
        this.isAvailable.imu=true;
      },{passive:true});
      window.addEventListener("devicemotion",(e)=>{
        const accG=e.accelerationIncludingGravity, acc=e.acceleration;
        if(acc) this.accel={x:acc.x||0,y:acc.y||0,z:acc.z||0};
        if(accG){
          const {x,y,z}=accG;
          this.gForce=Math.sqrt(x*x+y*y+z*z)/9.81;
        }
        if(e.rotationRate){
          this.rotationRate={alpha:e.rotationRate.alpha||0,beta:e.rotationRate.beta||0,gamma:e.rotationRate.gamma||0};
        }
        this.isAvailable.imu=true;
      },{passive:true});

      try{
        if("Accelerometer" in window){
          const a=new Accelerometer({frequency:30});
          a.addEventListener("reading",()=>{
            this.accel={x:a.x||0,y:a.y||0,z:a.z||0}; this.isAvailable.genericImu=true;
          }); a.start();
        }
        if("Gyroscope" in window){
          const g=new Gyroscope({frequency:30});
          g.addEventListener("reading",()=>{
            this.gyro={x:g.x||0,y:g.y||0,z:g.z||0}; this.isAvailable.genericImu=true;
          }); g.start();
        }
        if("Magnetometer" in window){
          const m=new Magnetometer({frequency:10});
          m.addEventListener("reading",()=>{
            this.mag={x:m.x||0,y:m.y||0,z:m.z||0}; this.isAvailable.mag=true;
          }); m.start();
        }
        if("AmbientLightSensor" in window){
          const l=new AmbientLightSensor({frequency:2});
          l.addEventListener("reading",()=>{
            this.lightLux=l.illuminance; this.isAvailable.light=true;
          }); l.start();
        }
      }catch(e){ console.warn("Generic sensors", e); }

      try{
        if(navigator.geolocation){
          navigator.geolocation.watchPosition((pos)=>{
            this.geo.lat=pos.coords.latitude;
            this.geo.lon=pos.coords.longitude;
            this.geo.acc=pos.coords.accuracy;
            this.geo.speed=pos.coords.speed;
            this.isAvailable.geo=true;
          },(err)=>console.warn("GPS error", err),{enableHighAccuracy:true, maximumAge:1000, timeout:8000});
        }
      }catch(e){}

      try{
        if(navigator.getBattery){
          const b=await navigator.getBattery();
          const upd=()=>{
            this.batt.level=b.level; this.batt.charging=b.charging; this.isAvailable.battery=true;
          };
          upd(); b.addEventListener("levelchange",upd); b.addEventListener("chargingchange",upd);
        }
      }catch(e){}
      try{
        const c=navigator.connection||navigator.mozConnection||navigator.webkitConnection;
        if(c){
          const upd=()=>{
            this.net.type=c.effectiveType||c.type||null;
            this.net.downlink=c.downlink||null;
            this.net.rtt=c.rtt||null;
            this.isAvailable.network=true;
          };
          upd(); c.addEventListener("change",upd);
        }
      }catch(e){}
      return true;
    }
    getOrientation(){return {pitch:this.pitch,roll:this.roll,heading:this.heading};}
    getMotion(){return {gForce:this.gForce,rotationRate:{...this.rotationRate},accel:{...this.accel},gyro:{...this.gyro},mag:{...this.mag}};}
    getGeo(){return {...this.geo};}
    getBattery(){return {...this.batt};}
    getNetwork(){return {...this.net};}
    getLight(){return this.lightLux;}
  }

  // ===== Video Manager =====
  class VideoManager{
    constructor(video){
      this.video=video;
      this.stream=null;
      this.ready=false;
    }
    async start(){
      const constraints={
        audio:false,
        video:{
          facingMode:"environment",
          width:{ideal:1280}, height:{ideal:720}
        }
      };
      this.stream=await navigator.mediaDevices.getUserMedia(constraints);
      this.video.srcObject=this.stream;
      await this.video.play();
      this.ready=true;
      return true;
    }
    stop(){
      if(this.stream) this.stream.getTracks().forEach(t=>t.stop());
      this.ready=false;
    }
  }

  // ===== Detection + Tracking (SORT-lite) =====
  class Kalman1D {
    constructor(x0=0, v0=0){
      this.x=x0; this.v=v0;
      this.pxx=1; this.pvv=1; this.pxv=0;
      this.q=0.05; this.r=0.8;
    }
    predict(dt){
      this.x += this.v*dt;
      this.pxx += dt*(2*this.pxv + dt*this.pvv) + this.q;
      this.pxv += dt*this.pvv;
      this.pvv += this.q;
    }
    update(z){
      const y=z-this.x;
      const s=this.pxx+this.r;
      const kx=this.pxx/s;
      const kv=this.pxv/s;
      this.x += kx*y;
      this.v += kv*y;
      this.pxx = (1-kx)*this.pxx;
      this.pxv = (1-kx)*this.pxv;
      // pvv stays
    }
  }

  class Track{
    constructor(det, id){
      const [x,y,w,h]=det.bbox;
      this.id=id;
      this.label=det.class;
      this.score=det.score;
      this.kx=new Kalman1D(x+w/2,0);
      this.ky=new Kalman1D(y+h/2,0);
      this.kw=new Kalman1D(w,0);
      this.kh=new Kalman1D(h,0);
      this.age=0; this.missed=0; this.hit=1;
      this.lastUpdate=now();
      this.history=[];
      this.lockMag=0;
    }
    predict(t){
      const dt=Math.max(0.001,(t-this.lastUpdate)/1000);
      this.kx.predict(dt); this.ky.predict(dt); this.kw.predict(dt); this.kh.predict(dt);
      this.lastUpdate=t; this.age++; this.missed++;
    }
    update(det){
      const [x,y,w,h]=det.bbox;
      this.kx.update(x+w/2); this.ky.update(y+h/2); this.kw.update(w); this.kh.update(h);
      this.label=det.class; this.score=det.score;
      this.missed=0; this.hit++;
      this.history.push({t:now(), cx:this.cx, cy:this.cy});
      if(this.history.length>30) this.history.shift();
    }
    get cx(){return this.kx.x;}
    get cy(){return this.ky.x;}
    get w(){return Math.max(2,this.kw.x);}
    get h(){return Math.max(2,this.kh.x);}
    get bbox(){return [this.cx-this.w/2, this.cy-this.h/2, this.w, this.h];}
    iou(det){
      const [x,y,w,h]=det.bbox;
      const [tx,ty,tw,th]=this.bbox;
      const x1=Math.max(x,tx), y1=Math.max(y,ty), x2=Math.min(x+w,tx+tw), y2=Math.min(y+h,ty+th);
      const inter=Math.max(0,x2-x1)*Math.max(0,y2-y1);
      if(inter<=0) return 0;
      const u=w*h+tw*th-inter;
      return inter/u;
    }
  }

  class Tracker {
    constructor(){
      this.tracks=[];
      this.nextId=1;
      this.iouThresh=0.22;
      this.maxMiss=18;
    }
    step(dets){
      const t=now();
      // predict all
      for(const tr of this.tracks) tr.predict(t);

      // greedy association by IoU
      const used=new Set();
      for(const tr of this.tracks){
        let best=-1, bestIou=0;
        for(let i=0;i<dets.length;i++){
          if(used.has(i)) continue;
          const iou=tr.iou(dets[i]);
          if(iou>bestIou){bestIou=iou; best=i;}
        }
        if(best>=0 && bestIou>this.iouThresh){
          tr.update(dets[best]); used.add(best);
        }
      }
      // new tracks
      for(let i=0;i<dets.length;i++){
        if(!used.has(i)){
          this.tracks.push(new Track(dets[i], this.nextId++));
        }
      }
      // prune
      this.tracks=this.tracks.filter(tr=>tr.missed<=this.maxMiss);
      return this.tracks;
    }
  }

  // ===== Vision Modules =====
  class VisionStack {
    constructor(video){
      this.video=video;
      this.detector=null;
      this.poseDetector=null;
      this.segModel=null;
      this.faceDetector=null;
      this.handDetector=null;

      this.enablePose=true;
      this.enableSeg=false;
      this.enableFace=false;
      this.enableHand=false;

      this.poseEvery=2; // run pose every N frames
      this.frame=0;
    }

    async init(){
      await tf.setBackend("webgl");
      await tf.ready();

      this.detector = await cocoSsd.load({base:"lite_mobilenet_v2"});
      this.poseDetector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        {modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING, enableSmoothing:true}
      );

      this.segModel = await bodySegmentation.createSegmenter(
        bodySegmentation.SupportedModels.MediaPipeSelfieSegmentation,
        {runtime:"mediapipe", modelType:"general", solutionPath:"https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation"}
      );

      this.faceDetector = await faceLandmarksDetection.createDetector(
        faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh,
        {runtime:"mediapipe", refineLandmarks:true, solutionPath:"https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"}
      );

      this.handDetector = await handPoseDetection.createDetector(
        handPoseDetection.SupportedModels.MediaPipeHands,
        {runtime:"mediapipe", modelType:"lite", solutionPath:"https://cdn.jsdelivr.net/npm/@mediapipe/hands"}
      );
    }

    async detect(){
      if(!this.detector) return [];
      return await this.detector.detect(this.video, 25, 0.5);
    }

    async pose(){
      if(!this.enablePose || !this.poseDetector) return [];
      this.frame++;
      if(this.frame % this.poseEvery !== 0) return this._lastPose || [];
      this._lastPose = await this.poseDetector.estimatePoses(this.video, {maxPoses:1, flipHorizontal:false});
      return this._lastPose;
    }

    async segment(){
      if(!this.enableSeg || !this.segModel) return null;
      return await this.segModel.segmentPeople(this.video, {multiSegmentation:false, segmentBodyParts:false});
    }

    async faces(){
      if(!this.enableFace || !this.faceDetector) return [];
      return await this.faceDetector.estimateFaces(this.video, {flipHorizontal:false});
    }

    async hands(){
      if(!this.enableHand || !this.handDetector) return [];
      return await this.handDetector.estimateHands(this.video, {flipHorizontal:false});
    }
  }

  // ===== OCR Module =====
  class OCRStack{
    constructor(){
      this.worker=null;
      this.busy=false;
      this.lang="eng";
    }
    async init(){
      if(this.worker) return;
      this.worker = await Tesseract.createWorker(this.lang);
    }
    async snap(video){
      if(this.busy) return null;
      this.busy=true;
      try{
        await this.init();
        const off=document.createElement("canvas");
        off.width=video.videoWidth; off.height=video.videoHeight;
        const octx=off.getContext("2d");
        octx.drawImage(video,0,0);
        toast("OCR running…");
        const { data } = await this.worker.recognize(off);
        const text=(data.text||"").trim();
        return text;
      } finally{
        this.busy=false;
      }
    }
  }

  // ===== Audio Classifier (MediaPipe) =====
  class AudioStack{
    constructor(){
      this.classifier=null;
      this.audioCtx=null;
      this.stream=null;
      this.running=false;
      this.lastTop=null;
    }
    async init(){
      if(this.classifier) return;
      const { FilesetResolver, AudioClassifier } = window;
      const audioFileset = await FilesetResolver.forAudioTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-audio@0.10.22-rc.20250304/wasm"
      );
      // default yamnet-like model hosted by MediaPipe (may change in future)
      const modelPath = "https://storage.googleapis.com/mediapipe-models/audio_classifier/yamnet/float32/1/yamnet.tflite";
      this.classifier = await AudioClassifier.createFromOptions(audioFileset,{
        baseOptions:{ modelAssetPath:modelPath },
        runningMode:"AUDIO_STREAM",
        maxResults:3, scoreThreshold:0.2
      });
    }
    async start(){
      await this.init();
      this.stream = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
      this.audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const source=this.audioCtx.createMediaStreamSource(this.stream);
      const processor=this.audioCtx.createScriptProcessor(4096,1,1);
      source.connect(processor); processor.connect(this.audioCtx.destination);
      this.running=true;

      processor.onaudioprocess = (e) => {
        if(!this.running) return;
        const input=e.inputBuffer.getChannelData(0);
        const audioData = { audioBuffer: input.slice(0), sampleRate: this.audioCtx.sampleRate };
        try{
          const res=this.classifier.classify(audioData);
          if(res && res.classifications && res.classifications[0]){
            const cats=res.classifications[0].categories;
            if(cats && cats[0]) this.lastTop=cats.slice(0,3);
          }
        }catch(err){ /* ignore frame errors */ }
      };
    }
    stop(){
      this.running=false;
      if(this.stream) this.stream.getTracks().forEach(t=>t.stop());
      if(this.audioCtx) this.audioCtx.close();
    }
  }

  // ===== Zone/Tripwire =====
  class ZoneManager{
    constructor(canvas){
      this.canvas=canvas;
      this.ctx=canvas.getContext("2d");
      this.zones=[];
      this.edit=false;
      this._drag=null;
      this.onChange=()=>{};
      this._bind();
    }
    resize(w,h){this.canvas.width=w; this.canvas.height=h;}
    toggleEdit(){
      this.edit=!this.edit;
      this.canvas.classList.toggle("edit", this.edit);
      toast(this.edit?"Zone edit: drag to draw":"Zone edit off");
    }
    _bind(){
      const c=this.canvas;
      c.addEventListener("pointerdown",(e)=>{
        if(!this.edit) return;
        const r=c.getBoundingClientRect();
        const x=(e.clientX-r.left)/r.width*c.width;
        const y=(e.clientY-r.top)/r.height*c.height;
        this._drag={x0:x,y0:y,x1:x,y1:y};
      });
      c.addEventListener("pointermove",(e)=>{
        if(!this.edit || !this._drag) return;
        const r=c.getBoundingClientRect();
        const x=(e.clientX-r.left)/r.width*c.width;
        const y=(e.clientY-r.top)/r.height*c.height;
        this._drag.x1=x; this._drag.y1=y;
      });
      c.addEventListener("pointerup",()=>{
        if(!this.edit || !this._drag) return;
        const d=this._drag; this._drag=null;
        const x=Math.min(d.x0,d.x1), y=Math.min(d.y0,d.y1);
        const w=Math.abs(d.x1-d.x0), h=Math.abs(d.y1-d.y0);
        if(w>10 && h>10){
          this.zones.push({x,y,w,h, id:Date.now()});
          this.onChange(this.zones);
        }
      });
      window.addEventListener("keydown",(e)=>{
        if(e.key==="Backspace" && this.edit){
          this.zones.pop(); this.onChange(this.zones);
        }
      });
    }
    draw(){
      const {ctx,canvas}=this;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      for(const z of this.zones){
        ctx.strokeStyle="rgba(0,255,102,0.7)";
        ctx.setLineDash([6,6]);
        ctx.lineWidth=2;
        ctx.strokeRect(z.x,z.y,z.w,z.h);
        ctx.fillStyle="rgba(0,255,102,0.06)";
        ctx.fillRect(z.x,z.y,z.w,z.h);
      }
      if(this._drag){
        const d=this._drag;
        const x=Math.min(d.x0,d.x1), y=Math.min(d.y0,d.y1);
        const w=Math.abs(d.x1-d.x0), h=Math.abs(d.y1-d.y0);
        ctx.strokeStyle="rgba(255,207,64,0.9)";
        ctx.setLineDash([4,4]);
        ctx.strokeRect(x,y,w,h);
      }
      ctx.restore();
    }
    check(track){
      const [x,y,w,h]=track.bbox;
      const cx=x+w/2, cy=y+h/2;
      for(const z of this.zones){
        if(cx>=z.x && cx<=z.x+z.w && cy>=z.y && cy<=z.y+z.h) return z;
      }
      return null;
    }
  }

  // ===== Memory / Heatmap =====
  class MemoryCore{
    constructor(w=40,h=24){
      this.gridW=w; this.gridH=h;
      this.grid=new Array(w*h).fill(0);
      this.events=[];
      this.maxEvents=80;
    }
    pushEvent(type, payload){
      this.events.unshift({t:Date.now(), type, payload});
      if(this.events.length>this.maxEvents) this.events.pop();
    }
    addPoint(nx,ny){
      const x=Math.floor(clamp(nx,0,0.999)*this.gridW);
      const y=Math.floor(clamp(ny,0,0.999)*this.gridH);
      this.grid[y*this.gridW+x]++;
    }
    drawHeat(ctx,w,h){
      ctx.clearRect(0,0,w,h);
      const max=Math.max(1,...this.grid);
      const cellW=w/this.gridW, cellH=h/this.gridH;
      for(let y=0;y<this.gridH;y++){
        for(let x=0;x<this.gridW;x++){
          const v=this.grid[y*this.gridW+x]/max;
          if(v<=0) continue;
          ctx.fillStyle=`rgba(0,255,102,${v*0.8})`;
          ctx.fillRect(x*cellW,y*cellH,cellW,cellH);
        }
      }
      ctx.strokeStyle="rgba(0,255,102,0.2)";
      ctx.strokeRect(0,0,w,h);
    }
  }

  // ===== OPAL Bridge (BroadcastChannel) =====
  class OpalBridge{
    constructor(name="OMEGA_OPAL_BUS"){
      this.bc=("BroadcastChannel" in window)? new BroadcastChannel(name): null;
      this.enabled=true;
    }
    send(payload){
      if(!this.enabled||!this.bc) return;
      this.bc.postMessage(payload);
    }
    toggle(){ this.enabled=!this.enabled; toast("OPAL bridge " + (this.enabled?"ON":"OFF")); }
  }

  // ===== Main Orchestrator =====
  const videoEl=document.getElementById("video");
  const overlay=document.getElementById("overlay");
  const segCanvas=document.getElementById("segCanvas");
  const zCanvas=document.getElementById("zoneOverlay");
  const ctx=overlay.getContext("2d");
  const segCtx=segCanvas.getContext("2d");

  const vm=new VideoManager(videoEl);
  const sensors=new SensorHub();
  const vision=new VisionStack(videoEl);
  const tracker=new Tracker();
  const ocr=new OCRStack();
  const audio=new AudioStack();
  const zones=new ZoneManager(zCanvas);
  const memory=new MemoryCore();
  const bridge=new OpalBridge();

  let running=false, paused=false;
  let lockedId=null;
  let lockSticky=0.7; // hysteresis
  let lastFrameT=now();
  let fpsSmooth=0;

  // heat/radar canvases
  const radarCanvas=document.getElementById("radarCanvas");
  const heatCanvas=document.getElementById("heatCanvas");
  const rctx=radarCanvas.getContext("2d");
  const hctx=heatCanvas.getContext("2d");
  const threatKV=document.getElementById("threatKV");
  const audioLine=document.getElementById("audioLine");

  function resize(){
    const w=videoEl.videoWidth||window.innerWidth;
    const h=videoEl.videoHeight||window.innerHeight;
    overlay.width=w; overlay.height=h;
    segCanvas.width=w; segCanvas.height=h;
    zones.resize(w,h);
    radarCanvas.width=220; radarCanvas.height=150;
    heatCanvas.width=220; heatCanvas.height=90;
  }

  // ===== UI bind =====
  const btnInit=document.getElementById("btnInit");
  const btnPause=document.getElementById("btnPause");
  const btnLock=document.getElementById("btnLock");
  const btnZones=document.getElementById("btnZones");
  const btnOCR=document.getElementById("btnOCR");
  const btnAudio=document.getElementById("btnAudio");
  const btnExport=document.getElementById("btnExport");

  const tglPose=document.getElementById("tglPose");
  const tglSeg=document.getElementById("tglSeg");
  const tglFace=document.getElementById("tglFace");
  const tglHand=document.getElementById("tglHand");

  btnPause.onclick=()=>{paused=!paused; btnPause.classList.toggle("active",paused); toast(paused?"Paused":"Resumed");};
  btnLock.onclick=()=>{lockedId=null; btnLock.classList.toggle("active",false); toast("Mag-lock cleared");};
  btnZones.onclick=()=>{zones.toggleEdit(); btnZones.classList.toggle("active",zones.edit);};
  btnExport.onclick=()=>exportSnapshot();
  btnOCR.onclick=async()=>doOCR();
  btnAudio.onclick=async()=>toggleAudio();

  tglPose.onclick=()=>{vision.enablePose=!vision.enablePose; tglPose.classList.toggle("active",vision.enablePose); tglPose.textContent=vision.enablePose?"POSE ON":"POSE OFF";};
  tglSeg.onclick=()=>{vision.enableSeg=!vision.enableSeg; tglSeg.classList.toggle("active",vision.enableSeg); tglSeg.textContent=vision.enableSeg?"SEG ON":"SEG OFF";};
  tglFace.onclick=()=>{vision.enableFace=!vision.enableFace; tglFace.classList.toggle("active",vision.enableFace); tglFace.textContent=vision.enableFace?"FACE ON":"FACE OFF";};
  tglHand.onclick=()=>{vision.enableHand=!vision.enableHand; tglHand.classList.toggle("active",vision.enableHand); tglHand.textContent=vision.enableHand?"HAND ON":"HAND OFF";};

  btnInit.onclick=async()=>{
    if(running) return;
    try{
      toast("Booting sensors…");
      await vm.start();
      await sensors.init();
      await vision.init();
      resize();
      running=true;
      btnInit.classList.add("active");
      toast("ΩMEGA online");
      loop();
    }catch(e){
      console.error(e);
      toast("Init failed: "+(e.message||e));
    }
  };

  overlay.addEventListener("pointerdown",(e)=>{
    if(!running || zones.edit) return;
    const r=overlay.getBoundingClientRect();
    const x=(e.clientX-r.left)/r.width*overlay.width;
    const y=(e.clientY-r.top)/r.height*overlay.height;
    // find nearest track within radius
    let best=null, bestD=1e12;
    for(const tr of tracker.tracks){
      const [bx,by,bw,bh]=tr.bbox;
      if(x>=bx && x<=bx+bw && y>=by && y<=by+bh){
        const d=dist2(x,y,tr.cx,tr.cy);
        if(d<bestD){best=tr; bestD=d;}
      }
    }
    if(best){
      lockedId=best.id;
      btnLock.classList.add("active");
      toast("Mag-lock T#"+lockedId);
    }
  });

  // ===== Dots update =====
  const dot=(id)=>document.getElementById(id);
  function setDot(d, on, warn=false){
    d.className="dot " + (on?(warn?"warn":"ok"):"");
  }

  // ===== UI auto-dock =====
  const panels=[document.getElementById("hudTop"), document.getElementById("hudRight"), document.getElementById("hudBottom"), document.getElementById("radarPanel")];
  function autoDock(targetRect){
    if(!targetRect) return;
    const vw=window.innerWidth, vh=window.innerHeight;
    const corners=[
      {name:"tl", x:0, y:0},
      {name:"tr", x:vw, y:0},
      {name:"bl", x:0, y:vh},
      {name:"br", x:vw, y:vh},
    ];
    for(const p of panels){
      const pr=p.getBoundingClientRect();
      let best=corners[0], bestScore=-1;
      for(const c of corners){
        const dx=Math.max(0, Math.abs(c.x-(targetRect.left+targetRect.width/2))-pr.width/2);
        const dy=Math.max(0, Math.abs(c.y-(targetRect.top+targetRect.height/2))-pr.height/2);
        const score=dx*dx+dy*dy; // farther is better
        if(score>bestScore){bestScore=score; best=c;}
      }
      const pad=10;
      let tx=0, ty=0;
      if(best.name==="tl"){tx=pad - pr.left; ty=pad - pr.top;}
      if(best.name==="tr"){tx=vw - pr.right - pad; ty=pad - pr.top;}
      if(best.name==="bl"){tx=pad - pr.left; ty=vh - pr.bottom - pad;}
      if(best.name==="br"){tx=vw - pr.right - pad; ty=vh - pr.bottom - pad;}
      p.style.transform=`translate(${tx}px,${ty}px)`;
    }
  }

  // ===== Radar drawing =====
  function drawRadar(tracks, locked){
    rctx.clearRect(0,0,radarCanvas.width, radarCanvas.height);
    const W=radarCanvas.width, H=radarCanvas.height;
    const cx=W/2, cy=H*0.9;
    // rings
    rctx.strokeStyle="rgba(0,255,102,0.25)";
    rctx.lineWidth=1;
    for(let i=1;i<=3;i++){
      rctx.beginPath();
      rctx.arc(cx,cy, i*H/3.2, Math.PI, 2*Math.PI);
      rctx.stroke();
    }
    rctx.beginPath(); rctx.moveTo(cx,cy); rctx.lineTo(cx,cy-H*0.95); rctx.stroke();

    for(const tr of tracks){
      const nx=tr.cx/overlay.width, ny=tr.cy/overlay.height;
      const bearing=(nx-0.5)*Math.PI; // crude
      const dist=clamp(1-ny,0,1);
      const rx=cx + Math.sin(bearing)*dist*H*0.9;
      const ry=cy - Math.cos(bearing)*dist*H*0.9;
      rctx.fillStyle= (locked && tr.id===locked.id) ? "rgba(255,207,64,0.95)" : "rgba(0,255,102,0.9)";
      rctx.beginPath(); rctx.arc(rx,ry, (tr.id===locked?.id)?5:3, 0, Math.PI*2); rctx.fill();
    }
  }

  // ===== Threat scoring =====
  function threatScore(tr){
    const distNorm=1-(tr.cy/overlay.height);
    const speed=Math.sqrt(tr.kx.v*tr.kx.v + tr.ky.v*tr.ky.v);
    let s=distNorm*0.7 + clamp(speed/600,0,1)*0.3;
    return s;
  }

  // ===== OCR action =====
  async function doOCR(){
    if(!running) return;
    const text=await ocr.snap(videoEl);
    if(text){
      memory.pushEvent("OCR", text.slice(0,140));
      toast("OCR: " + text.slice(0,40).replace(/\s+/g," ") + (text.length>40?"…":""));
    }else{
      toast("OCR: no text");
    }
  }

  // ===== Audio toggle =====
  async function toggleAudio(){
    if(audio.running){
      audio.stop();
      btnAudio.classList.remove("active");
      toast("Audio off");
    }else{
      try{
        await audio.start();
        btnAudio.classList.add("active");
        toast("Audio on");
      }catch(e){
        console.warn(e);
        toast("Audio init failed");
      }
    }
  }

  // ===== Export snapshot =====
  function exportSnapshot(){
    const tracks = tracker.tracks.map(t=>({
      id:t.id, label:t.label, score:t.score,
      bbox:t.bbox, velocity:{vx:t.kx.v, vy:t.ky.v}
    }));
    const payload={
      t:Date.now(),
      tracks,
      lockedId,
      imu:sensors.getOrientation(),
      motion:sensors.getMotion(),
      geo:sensors.getGeo(),
      audioTop:audio.lastTop||null,
      zones:zones.zones
    };
    memory.pushEvent("EXPORT", `tracks=${tracks.length}`);
    bridge.send({type:"OMEGA_SNAPSHOT", payload});
    const blob=new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download="omega_snapshot.json";
    a.click();
    toast("Exported snapshot");
  }

  // ===== Render helpers =====
  function drawBox(tr, color="rgba(0,255,102,0.9)", thick=2){
    const [x,y,w,h]=tr.bbox;
    ctx.strokeStyle=color; ctx.lineWidth=thick;
    ctx.strokeRect(x,y,w,h);
    // label
    ctx.fillStyle="rgba(0,0,0,0.5)";
    ctx.fillRect(x, y-16, ctx.measureText("").width+120, 16);
    ctx.fillStyle=color;
    ctx.fillText(`#${tr.id} ${tr.label} ${(tr.score*100).toFixed(0)}%`, x+4, y-4);
  }

  function drawPrediction(tr, dt=0.75){
    const px=tr.cx + tr.kx.v*dt*1000;
    const py=tr.cy + tr.ky.v*dt*1000;
    const [x,y,w,h]=tr.bbox;
    const nx=px-w/2, ny=py-h/2;
    ctx.save();
    ctx.strokeStyle="rgba(0,255,102,0.5)";
    ctx.setLineDash([6,4]); ctx.lineWidth=1.5;
    ctx.strokeRect(nx,ny,w,h);
    ctx.restore();
  }

  function drawPose(poses){
    if(!poses || !poses[0]) return;
    const kp=poses[0].keypoints || poses[0].keypoints3D || [];
    ctx.save();
    ctx.fillStyle="rgba(0,255,102,0.9)";
    for(const p of kp){
      if(p.score>0.35){
        ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill();
      }
    }
    // simple skeleton connections
    const pairs=[[5,7],[7,9],[6,8],[8,10],[5,6],[5,11],[6,12],[11,12],[11,13],[13,15],[12,14],[14,16]];
    ctx.strokeStyle="rgba(0,255,102,0.7)"; ctx.lineWidth=2;
    for(const [a,b] of pairs){
      const pa=kp[a], pb=kp[b];
      if(pa?.score>0.35 && pb?.score>0.35){
        ctx.beginPath(); ctx.moveTo(pa.x,pa.y); ctx.lineTo(pb.x,pb.y); ctx.stroke();
      }
    }
    ctx.restore();
  }

  function drawFaces(faces){
    ctx.save();
    for(const f of faces){
      const box=f.box;
      if(!box) continue;
      ctx.strokeStyle="rgba(125,200,255,0.8)";
      ctx.lineWidth=1.5;
      ctx.strokeRect(box.xMin,box.yMin,box.width,box.height);
      const pts=f.keypoints || [];
      ctx.fillStyle="rgba(125,200,255,0.8)";
      for(const p of pts){
        ctx.beginPath(); ctx.arc(p.x,p.y,1.2,0,Math.PI*2); ctx.fill();
      }
    }
    ctx.restore();
  }

  function drawHands(hands){
    ctx.save();
    ctx.strokeStyle="rgba(255,207,64,0.9)";
    ctx.fillStyle="rgba(255,207,64,0.9)";
    for(const h of hands){
      const pts=h.keypoints || [];
      for(const p of pts){
        ctx.beginPath(); ctx.arc(p.x,p.y,2,0,Math.PI*2); ctx.fill();
      }
    }
    ctx.restore();
  }

  function drawSegmentation(seg){
    segCtx.clearRect(0,0,segCanvas.width, segCanvas.height);
    if(!seg || !seg[0]) return;
    const mask = seg[0].mask;
    if(!mask) return;
    bodySegmentation.drawMask(
      segCanvas, videoEl, mask, 0.6, 0.1, false
    );
  }

  // ===== main loop =====
  async function loop(){
    requestAnimationFrame(loop);
    if(!running || paused || !vm.ready) return;

    const t=now();
    const dt=(t-lastFrameT)/1000;
    lastFrameT=t;
    const fps=1/Math.max(1e-6,dt);
    fpsSmooth=lerp(fpsSmooth,fps,0.08);
    document.getElementById("fps").textContent=fpsSmooth.toFixed(0);

    ctx.clearRect(0,0,overlay.width, overlay.height);
    zones.draw();

    // step 1: detect objects
    let dets=await vision.detect();
    setDot(dot("dotDet"), true);

    const tracks=tracker.step(dets);

    // step 2: mag-lock & scoring
    let locked=null;
    if(lockedId!=null){
      locked=tracks.find(t=>t.id===lockedId)||null;
      if(!locked){
        // attempt sticky re-lock to nearest similar class
        let best=null, bestScore=0;
        for(const tr of tracks){
          const s=tr.label==="person"?1:0.6;
          const i=locked?tr.iou(locked):0;
          const score=s*(0.6+i*0.4);
          if(score>bestScore){bestScore=score; best=tr;}
        }
        if(best && bestScore>lockSticky){
          lockedId=best.id; locked=best;
        }else{
          lockedId=null;
          btnLock.classList.remove("active");
        }
      }
    }

    // step 3: zones & memory
    for(const tr of tracks){
      const z=zones.check(tr);
      if(z){
        memory.pushEvent("ZONE", `T#${tr.id} entered`);
        bridge.send({type:"ZONE_EVENT", payload:{trackId:tr.id, zone:z}});
        toast(`Tripwire: T#${tr.id}`);
      }
      memory.addPoint(tr.cx/overlay.width, tr.cy/overlay.height);
    }

    // draw tracks + prediction
    let topThreat=null, topScore=0;
    for(const tr of tracks){
      const s=threatScore(tr);
      if(s>topScore){topScore=s; topThreat=tr;}
      drawPrediction(tr, 0.75);
      drawBox(tr, (locked && tr.id===locked.id) ? "rgba(255,207,64,0.95)" : "rgba(0,255,102,0.9)", (locked && tr.id===locked.id)?3:2);
      // trajectory
      if(tr.history.length>1){
        ctx.save();
        ctx.strokeStyle="rgba(0,255,102,0.35)";
        ctx.lineWidth=1.2;
        ctx.beginPath();
        tr.history.forEach((p,i)=>{ i?ctx.lineTo(p.cx,p.cy):ctx.moveTo(p.cx,p.cy); });
        ctx.stroke();
        ctx.restore();
      }
    }

    // step 4: pose, seg, face, hands
    const poses=await vision.pose();
    setDot(dot("dotPose"), vision.enablePose);
    drawPose(poses);

    const seg=await vision.segment();
    setDot(dot("dotSeg"), vision.enableSeg);
    if(vision.enableSeg) drawSegmentation(seg);

    const faces=await vision.faces();
    setDot(dot("dotFace"), vision.enableFace);
    if(vision.enableFace) drawFaces(faces);

    const hands=await vision.hands();
    setDot(dot("dotHand"), vision.enableHand);
    if(vision.enableHand) drawHands(hands);

    // radar + threats
    drawRadar(tracks, locked);
    memory.drawHeat(hctx, heatCanvas.width, heatCanvas.height);

    threatKV.innerHTML=`
      <div>TOP THREAT</div><div>${topThreat?`#${topThreat.id} ${topThreat.label}`:"--"}</div>
      <div>SCORE</div><div>${fmt(topScore,2)}</div>
      <div>LOCK</div><div>${locked?("#"+locked.id):"--"}</div>
    `;

    // audio line
    setDot(dot("dotAud"), audio.running);
    if(audio.lastTop){
      audioLine.textContent = audio.lastTop.map(c=>`${c.categoryName} ${(c.score*100).toFixed(0)}%`).join(" · ");
      bridge.send({type:"AUDIO_TOP", payload: audio.lastTop});
    }else audioLine.textContent="";

    // IMU / GPS dots
    setDot(dot("dotIMU"), sensors.isAvailable.imu || sensors.isAvailable.genericImu, sensors.isAvailable.imu===false && isMobile);
    setDot(dot("dotGPS"), sensors.isAvailable.geo);

    // UI readouts
    const o=sensors.getOrientation();
    const m=sensors.getMotion();
    const g=sensors.getGeo();
    document.getElementById("imuKV").innerHTML=`
      <div>PITCH</div><div>${fmt(o.pitch,1)}</div>
      <div>ROLL</div><div>${fmt(o.roll,1)}</div>
      <div>HEAD</div><div>${fmt(o.heading,1)}</div>
      <div>G-F</div><div>${fmt(m.gForce,2)}</div>
      <div>LAT</div><div>${g.lat?fmt(g.lat,5):"--"}</div>
      <div>LON</div><div>${g.lon?fmt(g.lon,5):"--"}</div>
    `;

    const batt=sensors.getBattery();
    const net=sensors.getNetwork();
    document.getElementById("statusKV").innerHTML=`
      <div>TRACKS</div><div>${tracks.length}</div>
      <div>BACKEND</div><div>${tf.getBackend()}</div>
      <div>BAT</div><div>${batt.level!=null?Math.round(batt.level*100)+"%":"--"} ${batt.charging?"⚡":""}</div>
      <div>NET</div><div>${net.type||"--"} ${net.downlink?net.downlink+"Mb/s":""}</div>
      <div>SECURE</div><div>${window.isSecureContext?"YES":"NO"}</div>
    `;

    // memory list UI
    const memEl=document.getElementById("memoryList");
    memEl.innerHTML=memory.events.map(ev=>{
      const time=new Date(ev.t).toLocaleTimeString();
      return `[${time}] ${ev.type}: ${String(ev.payload)}`;
    }).join("<br>");

    // send bridge frame
    bridge.send({
      type:"OMEGA_FRAME",
      payload:{
        t:Date.now(),
        tracks:tracks.map(tr=>({id:tr.id,label:tr.label,score:tr.score,bbox:tr.bbox,vel:[tr.kx.v,tr.ky.v]})),
        poses:poses?.[0]?.keypoints || null,
        faces:faces.length?faces.map(f=>f.box):null,
        hands:hands.length?hands.map(h=>h.keypoints):null,
        lockedId,
        imu:o, motion:m, geo:g
      }
    });

    // auto dock UI away from locked/center mass
    if(locked){
      const rect = overlay.getBoundingClientRect();
      const [bx,by,bw,bh]=locked.bbox;
      const tx = rect.left + (bx/overlay.width)*rect.width;
      const ty = rect.top + (by/overlay.height)*rect.height;
      const tw = (bw/overlay.width)*rect.width;
      const th = (bh/overlay.height)*rect.height;
      autoDock({left:tx, top:ty, width:tw, height:th});
    }

  }

})();
</script>
</body>
</html>
