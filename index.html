<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>OMEGA: ADVANCED HUMANOID VISION SYSTEM</title>

  <!-- Allowed CDNs only -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

  <style>
    :root {
      --hud-primary: #00ff41;
      --hud-secondary: #008f11;
      --hud-alert: #ff0000;
      --hud-warn: #ffcc00;
      --hud-info: #0080ff;
      --bg-dark: #050505;
      --glass: rgba(0, 20, 0, 0.8);
      --glass-dark: rgba(0, 10, 0, 0.9);
      --panel-bg: rgba(8, 18, 8, 0.92);
      --panel-border: rgba(0, 255, 65, 0.35);
    }

    * {
      box-sizing: border-box;
      user-select: none;
      -webkit-touch-callout: none;
      font-family: 'Consolas', 'Monaco', monospace;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: var(--bg-dark);
      color: var(--hud-primary);
      width: 100vw;
      height: 100vh;
    }

    #viewport {
      position: relative;
      width: 100%;
      height: 100%;
      background: #000;
    }

    #camera-feed {
      position: absolute;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      filter: sepia(0.5) hue-rotate(70deg) contrast(1.2) brightness(0.8);
      opacity: 0.6;
    }

    #hud-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
    }

    #ui-layer {
      position: absolute;
      inset: 0;
      z-index: 20;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: max(16px, env(safe-area-inset-top));
    }

    .hud-panel {
      background: var(--glass);
      border-left: 3px solid var(--hud-primary);
      padding: 8px 12px;
      margin: 10px;
      width: fit-content;
      backdrop-filter: blur(4px);
      box-shadow: 0 0 15px rgba(0, 255, 65, 0.1);
    }
    .hud-panel-wide { width:auto; max-width:320px; }

    .hud-text {
      font-size: 12px;
      letter-spacing: 1px;
      margin-bottom: 4px;
      text-shadow: 0 0 5px var(--hud-primary);
    }
    .hud-value { font-weight:bold; color:#fff; }
    .hud-label { color: var(--hud-secondary); }

    /* Radar */
    #radar-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 140px;
      height: 140px;
      border-radius: 50%;
      background: rgba(0, 20, 0, 0.9);
      border: 2px solid var(--hud-primary);
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
      overflow: hidden;
      z-index: 30;
      pointer-events: none;
    }
    #radar-container::after {
      content: '';
      position: absolute;
      inset: 0;
      background: conic-gradient(from 0deg, transparent 0deg, transparent 270deg, rgba(0,255,65,0.35) 360deg);
      border-radius: 50%;
      animation: radar-scan 2s linear infinite;
      pointer-events: none;
    }
    .radar-grid {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid rgba(0,255,65,0.25);
      border-radius: 50%;
      pointer-events:none;
    }
    .radar-cross {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 100%; height: 1px;
      background: rgba(0,255,65,0.25);
      pointer-events:none;
    }
    .radar-blip {
      position: absolute;
      border-radius: 50%;
      transform: translate(-50%,-50%);
      box-shadow: 0 0 6px currentColor;
      transition: transform .12s ease-out, opacity .12s ease-out;
      will-change: transform, opacity, left, top;
      pointer-events:none;
    }
    @keyframes radar-scan { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }
    @keyframes pulse {
      0% { opacity:1; transform:translate(-50%,-50%) scale(1); }
      50% { opacity:.65; transform:translate(-50%,-50%) scale(1.25); }
      100% { opacity:1; transform:translate(-50%,-50%) scale(1); }
    }

    /* Boot */
    #boot-overlay {
      position: fixed;
      inset: 0;
      background: #000;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--hud-primary);
    }
    #btn-init {
      background: transparent;
      color: var(--hud-primary);
      border: 2px solid var(--hud-primary);
      padding: 14px 44px;
      font-size: 16px;
      font-weight: 800;
      letter-spacing: 3px;
      cursor: pointer;
      margin-top: 20px;
      transition: .25s;
      clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
    }
    #btn-init:hover {
      background: var(--hud-primary);
      color: #000;
      box-shadow: 0 0 30px var(--hud-primary);
    }
    .status-led {
      display:inline-block; width:8px; height:8px;
      background:#333; border-radius:50%; margin-right:8px;
    }
    .status-led.active { background:var(--hud-primary); box-shadow:0 0 10px var(--hud-primary); }
    .status-led.error { background:var(--hud-alert); box-shadow:0 0 10px var(--hud-alert); }
    .status-led.warning { background:var(--hud-warn); box-shadow:0 0 10px var(--hud-warn); }

    /* Status bar */
    #system-status {
      position:absolute; bottom:0; left:0; width:100%;
      background: var(--glass-dark);
      border-top: 1px solid var(--hud-secondary);
      padding: 6px 12px;
      display:flex; justify-content:space-between;
      font-size: 11px; z-index:25;
      pointer-events:none;
    }
    .status-item { display:flex; align-items:center; margin-right:15px; }
    .status-indicator { width:6px; height:6px; border-radius:50%; margin-right:5px; }
    .status-ok { background:var(--hud-primary); }
    .status-warn { background:var(--hud-warn); }
    .status-error { background:var(--hud-alert); }
    .status-offline { background:#444; }

    /* Control Toggle + Panel (pointer-events ON) */
    #control-toggle {
      position: absolute;
      top: 12px; left: 12px;
      z-index: 60;
      pointer-events: auto;
      background: rgba(0,0,0,0.55);
      border: 1px solid var(--panel-border);
      color: var(--hud-primary);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      letter-spacing: 1px;
      backdrop-filter: blur(8px);
      cursor:pointer;
      display:flex; align-items:center; gap:8px;
    }
    #control-panel {
      position:absolute;
      top: 50px; left: 12px;
      width: 290px;
      max-height: calc(100vh - 90px);
      overflow: auto;
      z-index: 60;
      pointer-events: auto;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      padding: 12px;
      display: none;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      backdrop-filter: blur(10px);
    }
    #control-panel.open { display:block; }
    .cp-title { font-size:12px; opacity:.9; margin-bottom:8px; letter-spacing:1px; }
    .cp-row { display:flex; align-items:center; justify-content:space-between; margin:6px 0; }
    .cp-row small{opacity:.8;}
    .cp-btn, .cp-select, .cp-input {
      background: rgba(0,0,0,0.6);
      border: 1px solid var(--panel-border);
      color: var(--hud-primary);
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 12px;
      cursor:pointer;
      outline:none;
    }
    .cp-btn:active { transform: translateY(1px); }
    .cp-btn.secondary { color:#d9ffd9; border-color:rgba(0,255,65,0.2); }
    .cp-pill {
      display:inline-flex; gap:6px; flex-wrap:wrap;
    }
    .cp-chip {
      border:1px solid var(--panel-border);
      background: rgba(0,0,0,0.6);
      padding:4px 8px; border-radius:999px; font-size:11px; cursor:pointer;
    }
    .cp-chip.active { background: rgba(0,255,65,0.12); }

    /* Calibrate Modal */
    #calibrate-modal {
      position: fixed; inset: 0; z-index: 80;
      display: none; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.65);
      pointer-events: auto;
    }
    #calibrate-modal.open { display:flex; }
    .modal-card {
      width: min(92vw, 360px);
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.75);
    }
    .modal-card h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      letter-spacing: 1px;
      color: #eaffea;
    }
    .modal-card label { font-size: 12px; opacity:.9; display:block; margin-top:8px; }
    .modal-actions { display:flex; justify-content:flex-end; gap:8px; margin-top:12px; }
    .modal-note { font-size:11px; opacity:.8; margin-top:8px; line-height:1.4; }

    /* Error Overlay */
    #error-overlay {
      position: fixed; inset:0; z-index:70;
      display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.9);
      color: #eaffea;
      pointer-events:auto;
      padding: 18px;
      text-align:center;
    }
    #error-overlay.open { display:flex; }
    #error-overlay .card {
      max-width: 520px;
      background: rgba(10,20,10,0.9);
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      padding: 16px;
    }
    #error-overlay h2 { font-size:16px; margin:0 0 8px 0; }
    #error-overlay p { font-size:12px; opacity:.9; line-height:1.45; }

    /* Toast */
    #toast {
      position: fixed;
      bottom: 52px; left: 50%;
      transform: translateX(-50%);
      z-index: 90;
      background: rgba(0,0,0,0.8);
      border: 1px solid var(--panel-border);
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 12px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .2s ease;
      backdrop-filter: blur(6px);
    }
    #toast.show { opacity: 1; }
  </style>
</head>
<body>

<div id="viewport">
  <video id="camera-feed" autoplay playsinline muted></video>
  <canvas id="hud-canvas"></canvas>

  <div id="ui-layer">
    <div style="display:flex; justify-content:space-between; width:100%;">
      <div class="hud-panel">
        <div class="hud-text">SYSTEM CPU: <span id="val-cpu" class="hud-value">0</span> ms</div>
        <div class="hud-text">AI FPS / RENDER FPS: <span id="val-ai-fps" class="hud-value">0</span> / <span id="val-render-fps" class="hud-value">0</span></div>
        <div class="hud-text">TRACKED: <span id="val-tracked" class="hud-value">0</span></div>
      </div>
      <div class="hud-panel" style="text-align:right;">
        <div class="hud-text">PITCH: <span id="val-pitch" class="hud-value">0</span>°</div>
        <div class="hud-text">ROLL: <span id="val-roll" class="hud-value">0</span>°</div>
        <div class="hud-text">HEADING: <span id="val-heading" class="hud-value">0</span>°</div>
        <div class="hud-text">G-FORCE: <span id="val-g" class="hud-value">1.00</span></div>
      </div>
    </div>

    <div class="hud-panel hud-panel-wide" style="margin-top: auto; margin-bottom: 160px;">
      <div class="hud-text">ANALYTICS</div>
      <div class="hud-text">ACTIVE: <span id="val-active" class="hud-value">0</span> | PERSONS (5M): <span id="val-persons" class="hud-value">0</span></div>
      <div class="hud-text">CLOSEST PERSON: <span id="val-closest-person" class="hud-value">--</span></div>
      <div class="hud-text">TOP LABEL: <span id="val-top-label" class="hud-value">--</span></div>
    </div>

    <div class="hud-panel hud-panel-wide" style="margin-left: auto; margin-right: 160px;">
      <div class="hud-text">PRIMARY TARGET</div>
      <div class="hud-text"><span id="val-target-label" class="hud-value">--</span></div>
      <div class="hud-text">DIST: <span id="val-target-dist" class="hud-value">--</span> | BEAR: <span id="val-target-bearing" class="hud-value">--</span></div>
      <div class="hud-text">STATE: <span id="val-target-state" class="hud-value">--</span></div>
    </div>

    <div id="radar-container">
      <div class="radar-grid" style="width: 33%; height: 33%;"></div>
      <div class="radar-grid" style="width: 66%; height: 66%;"></div>
      <div class="radar-cross"></div>
      <div class="radar-cross" style="transform: translate(-50%, -50%) rotate(90deg);"></div>
      <div id="radar-blips"></div>
    </div>
  </div>

  <!-- Control -->
  <button id="control-toggle">☰ CONTROL</button>

  <div id="control-panel">
    <div class="cp-title">SYSTEM CONTROL PANEL</div>

    <div class="cp-row">
      <small>Preset</small>
      <select id="cp-preset" class="cp-select">
        <option value="Low">Low</option>
        <option value="Balanced" selected>Balanced</option>
        <option value="High">High</option>
      </select>
    </div>

    <div class="cp-row">
      <small>AI Engine</small>
      <button id="cp-ai-toggle" class="cp-btn">Pause AI</button>
    </div>

    <div class="cp-row">
      <small>Camera</small>
      <button id="cp-cam-toggle" class="cp-btn">Stop Camera</button>
    </div>

    <div class="cp-row">
      <small>HUD Elements</small>
      <div class="cp-pill">
        <button id="cp-toggle-horizon" class="cp-chip active">Horizon</button>
        <button id="cp-toggle-radar" class="cp-chip active">Radar</button>
        <button id="cp-toggle-boxes" class="cp-chip active">Boxes</button>
      </div>
    </div>

    <hr style="border:0;border-top:1px solid rgba(0,255,65,0.2); margin:10px 0;">

    <div class="cp-title">DEPTH CALIBRATION</div>
    <div class="cp-row">
      <small>Status</small>
      <span id="cp-calib-status" style="font-size:12px;">NOT CALIBRATED</span>
    </div>
    <div class="cp-row">
      <small>Calibrate using primary target</small>
      <button id="cp-open-calib" class="cp-btn secondary">Open CALIBRATE</button>
    </div>

    <hr style="border:0;border-top:1px solid rgba(0,255,65,0.2); margin:10px 0;">

    <div class="cp-title">MEMORY / KB</div>
    <div class="cp-row">
      <small>Export Memory</small>
      <button id="cp-export" class="cp-btn secondary">Export JSON</button>
    </div>
    <div class="cp-row">
      <small>Import Memory</small>
      <input id="cp-import" type="file" accept="application/json" class="cp-input" />
    </div>
    <div class="cp-row">
      <small>Clear Memory</small>
      <button id="cp-clear" class="cp-btn">Clear</button>
    </div>
  </div>

  <!-- Status bar -->
  <div id="system-status">
    <div style="display:flex;">
      <div class="status-item"><span class="status-indicator" id="status-cam"></span><span>CAM</span></div>
      <div class="status-item"><span class="status-indicator" id="status-ai"></span><span>AI</span></div>
      <div class="status-item"><span class="status-indicator" id="status-gyro"></span><span>GYRO</span></div>
      <div class="status-item"><span class="status-indicator" id="status-tracker"></span><span>TRACKER</span></div>
      <div class="status-item"><span class="status-indicator" id="status-memory"></span><span>MEMORY</span></div>
    </div>
    <div><span id="status-message">SYSTEM INITIALIZING</span></div>
  </div>
</div>

<!-- Boot overlay -->
<div id="boot-overlay">
  <div style="font-size: 40px; font-weight: 900; margin-bottom: 10px; letter-spacing: 5px;">OMEGA</div>
  <div style="opacity: 0.7; margin-bottom: 30px;">ADVANCED HUMANOID VISION SYSTEM</div>
  <div style="text-align: left; font-size: 12px; line-height: 1.6; opacity: 0.8;">
    <div><span class="status-led" id="led-cam"></span> OPTICAL SENSORS</div>
    <div><span class="status-led" id="led-ai"></span> NEURAL ENGINE (COCO-SSD)</div>
    <div><span class="status-led" id="led-gyro"></span> AVIONICS / GYRO</div>
    <div><span class="status-led" id="led-tracker"></span> OBJECT TRACKER</div>
    <div><span class="status-led" id="led-memory"></span> KNOWLEDGE BASE</div>
  </div>
  <button id="btn-init">INITIALIZE SYSTEM</button>
</div>

<!-- Calibrate modal -->
<div id="calibrate-modal">
  <div class="modal-card">
    <h3>CALIBRATE DEPTH (PINHOLE MODEL)</h3>

    <label>Target Type</label>
    <select id="calib-type" class="cp-select" style="width:100%;">
      <option value="person" selected>Person (full body)</option>
      <option value="vehicle">Vehicle</option>
    </select>

    <label>Real Distance to Target (meters)</label>
    <input id="calib-distance" type="number" min="0.5" step="0.1" class="cp-input" style="width:100%;" value="3.0"/>

    <label>Real Target Height (meters)</label>
    <input id="calib-height" type="number" min="0.3" step="0.01" class="cp-input" style="width:100%;" value="1.70"/>

    <div class="modal-note">
      วางเป้า “เต็มตัว” ไว้กลางจอ → ให้ Primary Target จับได้ → กด Calibrate.  
      สูตร: f ≈ (h_px * Z_real) / H_real, แล้วใช้ Z_est ≈ (f * H_real) / h_px
    </div>

    <div class="modal-actions">
      <button id="calib-cancel" class="cp-btn">Cancel</button>
      <button id="calib-apply" class="cp-btn secondary">Calibrate</button>
    </div>
  </div>
</div>

<!-- Error overlay -->
<div id="error-overlay">
  <div class="card">
    <h2 id="error-title">CAMERA ERROR</h2>
    <p id="error-msg">Unable to access camera.</p>
    <p style="margin-top:10px; font-size:12px; opacity:.9;">
      ✅ iOS: Settings → Safari → Camera → Allow<br/>
      ✅ Android: Site Settings → Camera → Allow<br/>
      แล้วกด “INITIALIZE SYSTEM” ใหม่
    </p>
    <button id="error-close" class="cp-btn secondary" style="margin-top:10px;">Close</button>
  </div>
</div>

<div id="toast"></div>

<script>
/**
 * OMEGA v3.0 — Production-grade Mobile CV + HUD
 * Single-file, no build tools. tfjs + coco-ssd only.
 */

// ============================================================================
// CONFIG
// ============================================================================
const CONFIG = {
  AI: {
    MODEL_TYPE: 'lite_mobilenet_v2',
    CONFIDENCE_THRESHOLD: 0.55,
    MAX_DETECTIONS: 20,
    INFERENCE_RATE: 10,     // hard ceiling for adaptive
    MIN_RATE: 2,            // adaptive floor (foreground)
    WARMUP_RUNS: 2,
    ADAPTIVE: {
      TARGET_MS: 90,        // if slower -> reduce rate
      HYSTERESIS: 0.15,     // avoid oscillation
      ADJUST_STEP: 1
    },
    PRESETS: {
      Low:      { maxFps: 4,  shadowBlur: 0,  smoothing: 0.82, renderFps: 20 },
      Balanced: { maxFps: 10, shadowBlur: 8,  smoothing: 0.70, renderFps: 30 },
      High:     { maxFps: 15, shadowBlur: 12, smoothing: 0.58, renderFps: 40 }
    },
    DEFAULT_PRESET: 'Balanced'
  },

  TRACKING: {
    MAX_AGE_FRAMES: 30,
    MIN_IOU: 0.30,
    MAX_CENTER_DIST_NORM: 0.35,
    LABEL_BONUS: 0.10,
    LABEL_PENALTY: 0.20,
    ALPHA: 0.85,     // alpha-beta filter constants
    BETA:  0.005
  },

  PHYSICS: {
    HORIZONTAL_FOV: 70,
    MAX_RANGE: 50,
    PERSON_HEIGHT: 1.70,
    VEHICLE_HEIGHT: 1.50,
    MOTION_THRESHOLD: 0.01,
    APPROACH_THRESHOLD: 0.02,
    RECEDE_THRESHOLD: -0.01,
    GYRO_DAMPING: 0.015
  },

  RADAR: {
    RANGE: 50,
    BLOB_SIZE_MIN: 4,
    BLOB_SIZE_MAX: 10,
    SCAN_SPEED: 2,
    MAX_BLIPS: 24
  },

  MEMORY: {
    MAX_EVENTS: 1000,
    PERSIST_INTERVAL: 30000,
    STORAGE_KEY: 'OMEGA_KB_V3'
  },

  UI: {
    UPDATE_RATE: 30
  },

  COLORS: {
    PRIMARY: '#00ff41',
    SECONDARY: '#008f11',
    ALERT: '#ff0000',
    WARN: '#ffcc00',
    INFO: '#0080ff',
    PERSON: '#ff0000',
    VEHICLE: '#ffcc00',
    OTHER: '#00ff41'
  }
};

// ============================================================================
// Utils
// ============================================================================
const Utils = {
  clamp: (n, a, b) => Math.min(Math.max(n, a), b),
  map: (v, x1, y1, x2, y2) => (v - x1) * (y2 - x2) / (y1 - x1) + x2,
  distance: (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2),
  iou: (r1, r2) => {
    const x1 = Math.max(r1.x, r2.x);
    const y1 = Math.max(r1.y, r2.y);
    const x2 = Math.min(r1.x + r1.width, r2.x + r2.width);
    const y2 = Math.min(r1.y + r1.height, r2.y + r2.height);
    const inter = Math.max(0, x2-x1) * Math.max(0, y2-y1);
    const a1 = r1.width * r1.height;
    const a2 = r2.width * r2.height;
    const uni = a1 + a2 - inter;
    return uni > 0 ? inter/uni : 0;
  },
  ema: (cur, prev, factor) => prev*factor + cur*(1-factor),
  toRad: d => d * Math.PI / 180,
  toDeg: r => r * 180 / Math.PI,
  id: () => 'id_' + Math.random().toString(36).slice(2, 10),
  fmt: (v, d=1) => Number.isFinite(v) ? v.toFixed(d) : '--'
};

// ============================================================================
// Video Mapper (handles object-fit: cover mapping)
// ============================================================================
class VideoMapper {
  constructor(videoEl, canvasEl){
    this.video = videoEl;
    this.canvas = canvasEl;
    this.viewW = window.innerWidth;
    this.viewH = window.innerHeight;
    this.vidW = 0;
    this.vidH = 0;
    this.scale = 1;
    this.offX = 0;
    this.offY = 0;
    window.addEventListener('resize', () => this.recompute());
  }

  recompute(){
    this.viewW = this.canvas.width;
    this.viewH = this.canvas.height;
    this.vidW = this.video.videoWidth || this.vidW;
    this.vidH = this.video.videoHeight || this.vidH;
    if(!this.vidW || !this.vidH) return;

    // object-fit: cover => scale by max ratio
    const s = Math.max(this.viewW / this.vidW, this.viewH / this.vidH);
    const dispW = this.vidW * s;
    const dispH = this.vidH * s;
    this.scale = s;
    this.offX = (this.viewW - dispW) / 2;
    this.offY = (this.viewH - dispH) / 2;
  }

  // map video-space bbox to screen/canvas-space bbox
  toScreenBbox(vb){
    return {
      x: vb.x * this.scale + this.offX,
      y: vb.y * this.scale + this.offY,
      width: vb.width * this.scale,
      height: vb.height * this.scale
    };
  }

  // normalized center in video space (-1..1)
  videoCenterNorm(vb){
    const cx = vb.x + vb.width/2;
    const cy = vb.y + vb.height/2;
    return {
      xNorm: Utils.map(cx, 0, this.vidW, -1, 1),
      yNorm: Utils.map(cy, 0, this.vidH, -1, 1)
    };
  }
}

// ============================================================================
// Avionics (GYRO / ACCEL)
// ============================================================================
class Avionics {
  constructor(){
    this.pitch = 0;
    this.roll = 0;
    this.heading = 0;
    this.gForce = 1.0;
    this.acc = {x:0,y:0,z:0};
    this.rotationRate = {alpha:0,beta:0,gamma:0};
    this.isAvailable = false;
    this.isInitialized = false;

    this.smoothing = {
      orientation: 0.8,
      acceleration: 0.7,
      rotation: 0.7
    };
  }

  async init(){
    try{
      if(!window.DeviceOrientationEvent && !window.DeviceMotionEvent){
        throw new Error("Sensors not available");
      }

      // iOS permission
      if(typeof DeviceOrientationEvent?.requestPermission === 'function'){
        const state = await DeviceOrientationEvent.requestPermission();
        if(state !== 'granted') throw new Error("GYRO PERMISSION DENIED");
      }

      window.addEventListener('deviceorientation', e => this._handleOrientation(e), {passive:true});
      window.addEventListener('devicemotion', e => this._handleMotion(e), {passive:true});

      this.isAvailable = true;
      this.isInitialized = true;
      return true;
    }catch(err){
      console.warn("Avionics init failed:", err);
      this.isAvailable = false;
      return false;
    }
  }

  _handleOrientation(e){
    // NOTE: rotationRate must NOT be read from deviceorientation (fix)
    this.roll = Utils.ema(e.gamma || 0, this.roll, this.smoothing.orientation);
    this.pitch = Utils.ema(e.beta || 0, this.pitch, this.smoothing.orientation);
    this.heading = Utils.ema(e.alpha || 0, this.heading, this.smoothing.orientation);
  }

  _handleMotion(e){
    const acc = e.accelerationIncludingGravity;
    if(acc){
      this.acc.x = Utils.ema(acc.x || 0, this.acc.x, this.smoothing.acceleration);
      this.acc.y = Utils.ema(acc.y || 0, this.acc.y, this.smoothing.acceleration);
      this.acc.z = Utils.ema(acc.z || 0, this.acc.z, this.smoothing.acceleration);

      const {x,y,z} = this.acc;
      this.gForce = Math.sqrt(x*x+y*y+z*z)/9.81;
    }

    // rotationRate ONLY here (fix)
    const rr = e.rotationRate;
    if(rr){
      this.rotationRate.alpha = Utils.ema(rr.alpha || 0, this.rotationRate.alpha, this.smoothing.rotation);
      this.rotationRate.beta  = Utils.ema(rr.beta  || 0, this.rotationRate.beta,  this.smoothing.rotation);
      this.rotationRate.gamma = Utils.ema(rr.gamma || 0, this.rotationRate.gamma, this.smoothing.rotation);
    }
  }

  gyroMagnitude(){
    const r = this.rotationRate;
    return Math.sqrt((r.alpha||0)**2 + (r.beta||0)**2 + (r.gamma||0)**2);
  }
}

// ============================================================================
// Vision Engine (tfjs + coco-ssd)
// ============================================================================
class VisionEngine {
  constructor(){
    this.model = null;
    this.isModelLoaded = false;
    this.isProcessing = false;
    this.lastInferenceMs = 0;
    this.avgInferenceMs = 0;
    this.p95Buffer = [];
  }

  async init(videoEl){
    try{
      await tf.ready();

      // Backend selection (webgl -> cpu). WASM not loaded per CDN constraint.
      let backend = 'cpu';
      try{
        await tf.setBackend('webgl');
        await tf.ready();
        backend = tf.getBackend();
      }catch(e){
        await tf.setBackend('cpu');
        backend = 'cpu';
      }
      console.log("TF backend:", backend);

      this.model = await cocoSsd.load({ base: CONFIG.AI.MODEL_TYPE });
      this.isModelLoaded = true;

      // Warm-up runs (reduce first-frame stutter)
      for(let i=0;i<CONFIG.AI.WARMUP_RUNS;i++){
        try{ await this.model.detect(videoEl, 1, 0.1); }catch(_){}
      }

      return true;
    }catch(err){
      console.error("Vision init failed:", err);
      this.isModelLoaded = false;
      return false;
    }
  }

  async detect(videoEl){
    if(!this.model || !this.isModelLoaded || this.isProcessing || videoEl.readyState !== 4){
      return [];
    }
    this.isProcessing = true;
    const t0 = performance.now();
    try{
      const res = await this.model.detect(
        videoEl,
        CONFIG.AI.MAX_DETECTIONS,
        CONFIG.AI.CONFIDENCE_THRESHOLD
      );
      const dt = performance.now() - t0;
      this.lastInferenceMs = dt;
      this.avgInferenceMs = Utils.ema(dt, this.avgInferenceMs, 0.95);
      this._pushP95(dt);
      return res;
    }catch(err){
      console.warn("Detect error:", err);
      return [];
    }finally{
      this.isProcessing = false;
    }
  }

  _pushP95(ms){
    this.p95Buffer.push(ms);
    if(this.p95Buffer.length > 60) this.p95Buffer.shift();
  }

  p95(){
    if(!this.p95Buffer.length) return 0;
    const a = [...this.p95Buffer].sort((x,y)=>x-y);
    return a[Math.floor(a.length*0.95)];
  }

  status(){
    return {
      isModelLoaded: this.isModelLoaded,
      lastInferenceMs: this.lastInferenceMs,
      avgInferenceMs: this.avgInferenceMs,
      p95InferenceMs: this.p95()
    };
  }
}

// ============================================================================
// Tracker (alpha-beta Kalman-lite + gating)
// ============================================================================
class ObjectTracker {
  constructor(){
    this.tracks = new Map();
    this.nextId = 1;
  }

  update(detections, timestamp, vidW, vidH){
    const dets = detections.map(d => ({
      bbox: { x:d.bbox[0], y:d.bbox[1], width:d.bbox[2], height:d.bbox[3] },
      label: d.class,
      confidence: d.score
    }));

    const used = new Set();

    // 1) match existing tracks
    for(const [id, tr] of this.tracks.entries()){
      if(tr.state === 'removed') continue;

      const dt = Math.max(0.001, (timestamp - tr.lastSeen)/1000);
      tr._predict(dt);

      let best = null;
      let bestScore = -1;

      for(let i=0;i<dets.length;i++){
        if(used.has(i)) continue;
        const det = dets[i];

        const iou = Utils.iou(tr.bbox, det.bbox);
        const tcx = tr.bbox.x + tr.bbox.width/2;
        const tcy = tr.bbox.y + tr.bbox.height/2;
        const dcx = det.bbox.x + det.bbox.width/2;
        const dcy = det.bbox.y + det.bbox.height/2;

        const diag = Math.sqrt(vidW*vidW + vidH*vidH) || 1;
        const centerDistNorm = Utils.distance(tcx,tcy,dcx,dcy)/diag;

        // gating
        if(iou < CONFIG.TRACKING.MIN_IOU && centerDistNorm > CONFIG.TRACKING.MAX_CENTER_DIST_NORM) continue;

        let score = iou * 0.7 + (1-centerDistNorm) * 0.3;
        if(det.label === tr.label) score += CONFIG.TRACKING.LABEL_BONUS;
        else score -= CONFIG.TRACKING.LABEL_PENALTY;

        if(score > bestScore){
          bestScore = score;
          best = {i, det};
        }
      }

      if(best){
        used.add(best.i);
        tr._update(best.det, dt, timestamp);
      }else{
        tr._markLost(timestamp);
      }
    }

    // 2) create new tracks for unmatched detections
    for(let i=0;i<dets.length;i++){
      if(used.has(i)) continue;
      this._create(dets[i], timestamp);
    }

    // 3) remove too-old lost tracks
    for(const [id, tr] of this.tracks.entries()){
      if(tr.state === 'lost' && tr.lostFrames > CONFIG.TRACKING.MAX_AGE_FRAMES){
        tr.state = 'removed';
        this.tracks.delete(id);
      }
    }

    return Array.from(this.tracks.values());
  }

  _create(det, timestamp){
    const id = this.nextId++;
    const tr = new Track(id, det, timestamp);
    this.tracks.set(id, tr);
  }

  activeTracks(){
    return Array.from(this.tracks.values()).filter(t => t.state !== 'lost');
  }

  status(){
    const active = this.activeTracks();
    return {
      totalTracks: this.tracks.size,
      activeTracks: active.length,
      newTracks: active.filter(t=>t.state==='new').length
    };
  }
}

class Track {
  constructor(id, det, ts){
    this.id = id;
    this.label = det.label;
    this.confidence = det.confidence;
    this.bbox = {...det.bbox};   // video-space bbox
    this.rawBbox = {...det.bbox};
    this.state = 'new';
    this.firstSeen = ts;
    this.lastSeen = ts;

    // alpha-beta filter state (center + velocity)
    const cx = det.bbox.x + det.bbox.width/2;
    const cy = det.bbox.y + det.bbox.height/2;
    this.cx = cx; this.cy = cy;
    this.vx = 0; this.vy = 0;

    this.lostFrames = 0;
    this.prevArea = det.bbox.width * det.bbox.height;
    this.prevHeight = det.bbox.height;
    this.prevDepthRel = null;
  }

  _predict(dt){
    this.cx += this.vx * dt;
    this.cy += this.vy * dt;
    // bbox prediction: keep size same, move center
    const w = this.bbox.width, h = this.bbox.height;
    this.bbox.x = this.cx - w/2;
    this.bbox.y = this.cy - h/2;
  }

  _update(det, dt, ts){
    const alpha = CONFIG.TRACKING.ALPHA;
    const beta  = CONFIG.TRACKING.BETA;

    this.rawBbox = {...det.bbox};

    const mx = det.bbox.x + det.bbox.width/2;
    const my = det.bbox.y + det.bbox.height/2;

    const rx = mx - this.cx;
    const ry = my - this.cy;

    this.cx = this.cx + alpha*rx;
    this.cy = this.cy + alpha*ry;
    this.vx = this.vx + (beta*rx)/dt;
    this.vy = this.vy + (beta*ry)/dt;

    // smooth size separately (match original vibe)
    const smooth = OmegaKernel.currentPreset().smoothing;
    this.bbox.x = Utils.ema(det.bbox.x, this.bbox.x, smooth);
    this.bbox.y = Utils.ema(det.bbox.y, this.bbox.y, smooth);
    this.bbox.width  = Utils.ema(det.bbox.width,  this.bbox.width,  smooth);
    this.bbox.height = Utils.ema(det.bbox.height, this.bbox.height, smooth);

    this.label = det.label;
    this.confidence = det.confidence;
    this.lastSeen = ts;
    this.lostFrames = 0;

    if(this.state === 'new') this.state = 'active';
  }

  _markLost(ts){
    this.state = 'lost';
    this.lastSeen = ts;
    this.lostFrames++;
  }
}

// ============================================================================
// Depth Calibration (Pinhole)
// ============================================================================
class DepthCalibrator {
  constructor(){
    this.isCalibrated = false;
    this.focalPx = null;
    this.realHeightM = null;
    this.labelType = null;
  }

  calibrate(track, ZrealM, HrealM){
    if(!track || !track.bbox) return false;

    const h_px = track.bbox.height;
    if(h_px <= 2 || ZrealM <= 0 || HrealM <= 0) return false;

    // f ≈ (h_px * Z_real) / H_real
    this.focalPx = (h_px * ZrealM) / HrealM;
    this.realHeightM = HrealM;
    this.labelType = track.label;
    this.isCalibrated = true;
    return true;
  }

  estimateMeters(track){
    if(!this.isCalibrated || !this.focalPx || !this.realHeightM) return null;
    const h_px = track.bbox.height;
    if(h_px <= 2) return null;
    // Z_est ≈ (f * H_real) / h_px
    return (this.focalPx * this.realHeightM) / h_px;
  }
}

// ============================================================================
// Physics Engine (bearing, depth, radial speed)
// ============================================================================
class PhysicsEngine {
  constructor(mapper, avionics, calibrator){
    this.mapper = mapper;
    this.avionics = avionics;
    this.calibrator = calibrator;
  }

  analyze(tracks){
    return tracks.map(tr => {
      const enhanced = {...tr};

      const vb = tr.bbox;
      const sb = this.mapper.toScreenBbox(vb);
      enhanced.screenBbox = sb;
      enhanced.videoBbox = vb;

      enhanced.screenPosition = this.mapper.videoCenterNorm(vb);

      // Bearing (deg) from video-space xNorm
      enhanced.bearingDeg = enhanced.screenPosition.xNorm * (CONFIG.PHYSICS.HORIZONTAL_FOV/2);

      // Depth
      const absMeters = this.calibrator.estimateMeters(tr);
      if(absMeters != null){
        enhanced.depthMeters = absMeters;
        enhanced.depthRel = Utils.clamp(absMeters / CONFIG.PHYSICS.MAX_RANGE, 0, 1);
        enhanced.depthMode = 'abs';
      }else{
        const bboxHeightNorm = vb.height / (this.mapper.vidH || 1);
        const rel = 1 - Math.min(bboxHeightNorm*2, 1);
        enhanced.depthRel = Utils.clamp(rel, 0, 1);
        enhanced.depthMeters = null;
        enhanced.depthMode = 'rel';
      }

      // Radial motion from bbox area/height changes
      const area = vb.width * vb.height;
      const dh = vb.height - tr.prevHeight;
      const dA = area - tr.prevArea;

      const depthRel = enhanced.depthRel;
      let radial = 0;
      if(tr.prevDepthRel != null){
        // negative depthRel change => approaching
        radial = (tr.prevDepthRel - depthRel);
      }else{
        radial = (dA/Math.max(1, tr.prevArea))*0.5 + (dh/Math.max(1,tr.prevHeight))*0.5;
      }

      // damp ego-motion from gyro
      const gyroMag = this.avionics?.gyroMagnitude?.() || 0;
      radial *= (1 / (1 + gyroMag*CONFIG.PHYSICS.GYRO_DAMPING));

      enhanced.radialSpeed = radial;
      enhanced.motionState = this._classify(radial);

      // cache for next frame
      tr.prevArea = area;
      tr.prevHeight = vb.height;
      tr.prevDepthRel = depthRel;

      return enhanced;
    });
  }

  _classify(rad){
    if(rad > CONFIG.PHYSICS.APPROACH_THRESHOLD) return 'approaching';
    if(rad < CONFIG.PHYSICS.RECEDE_THRESHOLD) return 'receding';
    if(Math.abs(rad) < CONFIG.PHYSICS.MOTION_THRESHOLD) return 'static';
    return 'moving';
  }
}

// ============================================================================
// Radar System (reuse pool + bearing=0 fix)
// ============================================================================
class RadarSystem {
  constructor(containerId){
    this.container = document.getElementById(containerId);
    this.width = 140; this.height = 140;
    this.centerX = this.width/2; this.centerY = this.height/2;
    this.maxRadius = this.width/2 - 6;

    this.pool = [];
    this._ensurePool(CONFIG.RADAR.MAX_BLIPS);
  }

  _ensurePool(n){
    while(this.pool.length < n){
      const b = document.createElement('div');
      b.className = 'radar-blip';
      b.style.opacity = '0';
      this.container.appendChild(b);
      this.pool.push(b);
    }
  }

  update(tracks, showRadar=true){
    if(!showRadar){
      for(const el of this.pool) el.style.opacity='0';
      return;
    }
    const capped = tracks.slice(0, CONFIG.RADAR.MAX_BLIPS);

    for(let i=0;i<this.pool.length;i++){
      const el = this.pool[i];
      const tr = capped[i];
      if(!tr){ el.style.opacity='0'; continue; }

      const bearingOk = (tr.bearingDeg != null);  // FIX: allow 0
      const depthOk = (tr.depthRel != null);
      if(!bearingOk || !depthOk){ el.style.opacity='0'; continue; }

      const angle = Utils.toRad(tr.bearingDeg);
      const radius = tr.depthRel * this.maxRadius;

      const x = this.centerX + radius*Math.sin(angle);
      const y = this.centerY - radius*Math.cos(angle);

      const baseSize = this._baseSize(tr.label);
      const motionSize = (tr.motionState==='approaching') ? 2 : (tr.motionState==='receding' ? -1 : 0);
      const size = baseSize + motionSize;

      el.style.left = x+'px';
      el.style.top  = y+'px';
      el.style.width = size+'px';
      el.style.height= size+'px';
      el.style.backgroundColor = this._color(tr.label);
      el.style.color = this._color(tr.label);
      el.style.opacity='1';
      el.style.animation = (tr.motionState==='approaching') ? 'pulse 1s infinite' : 'none';
    }
  }

  _baseSize(label){
    if(label==='person') return CONFIG.RADAR.BLOB_SIZE_MIN;
    if(['car','truck','bus','motorcycle','bicycle'].includes(label)) return CONFIG.RADAR.BLOB_SIZE_MAX;
    return (CONFIG.RADAR.BLOB_SIZE_MIN+CONFIG.RADAR.BLOB_SIZE_MAX)/2;
  }
  _color(label){
    if(label==='person') return CONFIG.COLORS.PERSON;
    if(['car','truck','bus','motorcycle','bicycle'].includes(label)) return CONFIG.COLORS.VEHICLE;
    return CONFIG.COLORS.OTHER;
  }
}

// ============================================================================
// Knowledge Base (persistence + export/import)
// ============================================================================
class KnowledgeBase {
  constructor(){
    this.events = [];
    this.objectHistory = new Map();
    this.stats = { totalDetections:0, personDetections:0, vehicleDetections:0, uniqueObjects:0 };

    this._load();
    this._persistTimer = setInterval(()=>this._save(), CONFIG.MEMORY.PERSIST_INTERVAL);
  }

  recordEvent(type, data, ts=Date.now()){
    const ev = { type, data, timestamp: ts, id: Utils.id() };
    this.events.push(ev);
    if(this.events.length > CONFIG.MEMORY.MAX_EVENTS) this.events.shift();
    this._updateStats(ev);
    if(data.objectId) this._updateObjHistory(data.objectId, ev);
  }

  _updateStats(ev){
    this.stats.totalDetections++;
    if(ev.type==='object_detected' || ev.type==='object_updated'){
      const l = ev.data.label;
      if(l==='person') this.stats.personDetections++;
      else if(['car','truck','bus','motorcycle','bicycle'].includes(l)) this.stats.vehicleDetections++;
    }
    if(ev.type==='object_detected') this.stats.uniqueObjects++;
  }

  _updateObjHistory(id, ev){
    if(!this.objectHistory.has(id)) this.objectHistory.set(id, []);
    const h = this.objectHistory.get(id);
    h.push(ev);
    if(h.length > 50) h.shift();
  }

  getActiveObjectCount(){
    const recent = Date.now()-5000;
    const s = new Set();
    for(const ev of [...this.events].reverse()){
      if(ev.timestamp < recent) break;
      if(ev.type==='object_detected' || ev.type==='object_updated') s.add(ev.data.objectId);
    }
    return s.size;
  }

  getPersonDetectionsInLast(min){
    const cut = Date.now()-min*60*1000;
    return this.events.filter(ev =>
      ev.timestamp>=cut &&
      ev.data.label==='person' &&
      (ev.type==='object_detected' || ev.type==='object_updated')
    ).length;
  }

  getClosestPerson(){
    const evs = this.events.filter(ev =>
      ev.data.label==='person' &&
      ev.type==='object_updated' &&
      ev.data.depthRel != null
    );
    if(!evs.length) return null;
    const closest = evs.reduce((p,c)=> (p.data.depthRel < c.data.depthRel) ? p : c);
    const distM = closest.data.depthMode==='abs'
      ? closest.data.depthMeters
      : closest.data.depthRel * CONFIG.PHYSICS.MAX_RANGE;

    return { distance: distM, bearing: closest.data.bearingDeg, timestamp: closest.timestamp, mode: closest.data.depthMode };
  }

  getMostCommonLabelInLast(min){
    const cut = Date.now()-min*60*1000;
    const recent = this.events.filter(ev =>
      ev.timestamp>=cut && (ev.type==='object_detected' || ev.type==='object_updated')
    );
    const m = {};
    for(const ev of recent){
      const l = ev.data.label;
      m[l]=(m[l]||0)+1;
    }
    let best='none', bestC=0;
    for(const [l,c] of Object.entries(m)){
      if(c>bestC){ bestC=c; best=l; }
    }
    return best;
  }

  exportJSON(){
    return JSON.stringify({
      events: this.events,
      objectHistory: Array.from(this.objectHistory.entries()),
      stats: this.stats
    }, null, 2);
  }

  importJSON(raw){
    try{
      const j = JSON.parse(raw);
      this.events = Array.isArray(j.events) ? j.events.slice(-CONFIG.MEMORY.MAX_EVENTS) : [];
      this.objectHistory = new Map(Array.isArray(j.objectHistory) ? j.objectHistory : []);
      this.stats = j.stats || this.stats;
      this._save();
      return true;
    }catch(e){
      console.warn("Import failed:", e);
      return false;
    }
  }

  clear(){
    this.events = [];
    this.objectHistory.clear();
    this.stats = { totalDetections:0, personDetections:0, vehicleDetections:0, uniqueObjects:0 };
    this._save();
  }

  _save(){
    try{
      localStorage.setItem(CONFIG.MEMORY.STORAGE_KEY, this.exportJSON());
    }catch(e){
      console.warn("Persist save failed:", e);
    }
  }

  _load(){
    try{
      const raw = localStorage.getItem(CONFIG.MEMORY.STORAGE_KEY);
      if(raw) this.importJSON(raw);
    }catch(e){
      console.warn("Persist load failed:", e);
    }
  }
}

// ============================================================================
// HUD Renderer (OffscreenCanvas if available)
// ============================================================================
class HUDRenderer {
  constructor(){
    this.canvas = document.getElementById('hud-canvas');
    this.ctx = this.canvas.getContext('2d');
    this.resize();
    window.addEventListener('resize',()=>this.resize());
  }

  resize(){
    const dpr = window.devicePixelRatio || 1;
    this.canvas.width = Math.floor(window.innerWidth*dpr);
    this.canvas.height= Math.floor(window.innerHeight*dpr);
    this.canvas.style.width = window.innerWidth+'px';
    this.canvas.style.height= window.innerHeight+'px';
    this.ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  clear(){
    this.ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
  }

  drawHorizon(pitch, roll){
    const ctx=this.ctx;
    const w=window.innerWidth, h=window.innerHeight;
    const horizonY = pitch*2;

    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.rotate(Utils.toRad(roll));

    // ground/sky hints
    ctx.fillStyle='rgba(139,69,19,0.18)';
    ctx.fillRect(-w, horizonY, w*2, h);
    ctx.fillStyle='rgba(0,100,200,0.18)';
    ctx.fillRect(-w, -h, w*2, h+horizonY);

    ctx.strokeStyle=CONFIG.COLORS.PRIMARY;
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(-w, horizonY);
    ctx.lineTo(w, horizonY);
    ctx.stroke();

    // pitch ladder
    ctx.strokeStyle=CONFIG.COLORS.PRIMARY;
    ctx.lineWidth=1;
    ctx.fillStyle=CONFIG.COLORS.PRIMARY;
    ctx.font='12px monospace';
    ctx.textAlign='center';

    for(let i=-4;i<=4;i++){
      if(i===0) continue;
      const y = horizonY + i*30;
      const major = i%2===0;
      const len = major?60:40;
      const val = i*10;

      ctx.beginPath();
      ctx.moveTo(-len/2,y); ctx.lineTo(len/2,y); ctx.stroke();
      if(major) ctx.fillText(`${Math.abs(val)}°`, len/2+20, y+4);
    }

    ctx.restore();

    // center reference
    ctx.strokeStyle=CONFIG.COLORS.PRIMARY;
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(w/2-20,h/2); ctx.lineTo(w/2+20,h/2);
    ctx.moveTo(w/2,h/2-10); ctx.lineTo(w/2,h/2+10);
    ctx.stroke();
  }

  drawCrosshair(){
    const ctx=this.ctx;
    const cx=window.innerWidth/2, cy=window.innerHeight/2;

    ctx.strokeStyle=CONFIG.COLORS.PRIMARY;
    ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.arc(cx,cy,25,0,Math.PI*2); ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(cx-15,cy); ctx.lineTo(cx-40,cy);
    ctx.moveTo(cx+15,cy); ctx.lineTo(cx+40,cy);
    ctx.moveTo(cx,cy-15); ctx.lineTo(cx,cy-40);
    ctx.moveTo(cx,cy+15); ctx.lineTo(cx,cy+40);
    ctx.stroke();

    ctx.fillStyle=CONFIG.COLORS.ALERT;
    ctx.fillRect(cx-2,cy-2,4,4);
  }

  drawTargetBoxes(tracks, showBoxes=true){
    if(!showBoxes) return;
    for(const tr of tracks) this._drawBox(tr);
  }

  _drawBox(tr){
    const ctx=this.ctx;
    const sb = tr.screenBbox;
    if(!sb) return;

    const {x,y,width,height}=sb;

    let color=CONFIG.COLORS.OTHER;
    if(tr.label==='person') color=CONFIG.COLORS.PERSON;
    else if(['car','truck','bus','motorcycle','bicycle'].includes(tr.label)) color=CONFIG.COLORS.VEHICLE;

    const bracket = Math.min(width,height)*0.15;
    ctx.strokeStyle=color;
    ctx.lineWidth=2;
    ctx.shadowBlur = OmegaKernel.currentPreset().shadowBlur;
    ctx.shadowColor=color;

    ctx.beginPath();
    // TL
    ctx.moveTo(x, y+bracket); ctx.lineTo(x, y); ctx.lineTo(x+bracket, y);
    // TR
    ctx.moveTo(x+width-bracket, y); ctx.lineTo(x+width, y); ctx.lineTo(x+width, y+bracket);
    // BR
    ctx.moveTo(x+width, y+height-bracket); ctx.lineTo(x+width, y+height); ctx.lineTo(x+width-bracket, y+height);
    // BL
    ctx.moveTo(x+bracket, y+height); ctx.lineTo(x, y+height); ctx.lineTo(x, y+height-bracket);
    ctx.stroke();
    ctx.shadowBlur=0;

    const label = `${tr.label.toUpperCase()} ${Math.floor(tr.confidence*100)}%  #${tr.id}`;
    const distText = tr.depthMode==='abs'
      ? `~${Utils.fmt(tr.depthMeters,1)}m`
      : `REL ${Utils.fmt(tr.depthRel,2)}`;
    const info = `${distText} @ ${Utils.fmt(tr.bearingDeg,0)}°`;

    ctx.font='bold 11px monospace';
    const w1=ctx.measureText(label).width;
    const w2=ctx.measureText(info).width;
    const mw=Math.max(w1,w2);

    ctx.fillStyle='rgba(0,0,0,0.7)';
    ctx.fillRect(x, y-32, mw+10, 26);

    ctx.fillStyle=color;
    ctx.fillText(label, x+5, y-17);
    ctx.fillText(info,  x+5, y-6);
  }
}

// ============================================================================
// Omega Kernel (orchestrator)
// ============================================================================
class OmegaKernel {
  static presetName = CONFIG.AI.DEFAULT_PRESET;
  static currentPreset(){ return CONFIG.AI.PRESETS[OmegaKernel.presetName]; }

  constructor(){
    this.video = document.getElementById('camera-feed');

    this.avionics = new Avionics();
    this.vision = new VisionEngine();
    this.tracker = new ObjectTracker();
    this.calibrator = new DepthCalibrator();
    this.renderer = new HUDRenderer();
    this.mapper = new VideoMapper(this.video, this.renderer.canvas);
    this.physics = new PhysicsEngine(this.mapper, this.avionics, this.calibrator);
    this.radar = new RadarSystem('radar-blips');
    this.memory = new KnowledgeBase();

    this.isRunning = false;
    this.aiPaused = false;
    this.cameraOn = true;

    // adaptive AI loop
    this.aiRate = OmegaKernel.currentPreset().maxFps;
    this.aiIntervalMs = 1000/this.aiRate;
    this.lastAIStamp = 0;

    // render loop
    this.renderIntervalMs = 1000/OmegaKernel.currentPreset().renderFps;
    this.lastRenderStamp = 0;

    // FPS counters
    this.aiFrames = 0;
    this.renderFrames = 0;
    this.aiFpsReal = 0;
    this.renderFpsReal = 0;
    this.fpsTimer = performance.now();

    this.tracked = [];
    this.primaryTarget = null;

    this.hudFlags = { horizon:true, radar:true, boxes:true };

    this._bindVisibility();
  }

  async boot(){
    try{
      this._status("SYSTEM INITIALIZING...");

      this._bootLED('led-gyro','loading');
      const gyroOk = await this.avionics.init();
      this._bootLED('led-gyro', gyroOk ? 'active' : 'error');

      this._bootLED('led-cam','loading');
      const camOk = await this._initCamera();
      this._bootLED('led-cam', camOk ? 'active' : 'error');
      if(!camOk) throw new Error("Camera permission denied or unavailable.");

      this.mapper.recompute();

      this._bootLED('led-ai','loading');
      const aiOk = await this.vision.init(this.video);
      this._bootLED('led-ai', aiOk ? 'active' : 'error');

      this._bootLED('led-tracker','active');
      this._bootLED('led-memory','active');

      this.isRunning = true;

      document.getElementById('boot-overlay').style.display='none';

      this._aiLoop();
      this._renderLoop();

      this._status(aiOk ? "SYSTEM OPERATIONAL" : "SYSTEM OPERATIONAL (AI OFFLINE)");
    }catch(err){
      console.error(err);
      this._status("SYSTEM ERROR: "+err.message);
      this._showError("CAMERA ERROR", err.message);
    }
  }

  async _initCamera(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({
        video:{
          facingMode:'environment',
          width:{ideal:1280}, height:{ideal:720}
        },
        audio:false
      });
      this.video.srcObject = stream;
      await new Promise(res=>{
        this.video.onloadedmetadata=()=>{
          this.video.play();
          res();
        };
      });
      return true;
    }catch(err){
      console.warn("Camera init failed:", err);
      return false;
    }
  }

  _adaptiveStep(){
    if(!this.vision.isModelLoaded) return;

    const st = this.vision.status();
    const presetMax = OmegaKernel.currentPreset().maxFps;
    const target = CONFIG.AI.ADAPTIVE.TARGET_MS;

    // if too slow decrease, if fast increase (hysteresis)
    if(st.avgInferenceMs > target*(1+CONFIG.AI.ADAPTIVE.HYSTERESIS)){
      this.aiRate = Math.max(CONFIG.AI.MIN_RATE, this.aiRate - CONFIG.AI.ADAPTIVE.ADJUST_STEP);
    }else if(st.avgInferenceMs < target*(1-CONFIG.AI.ADAPTIVE.HYSTERESIS)){
      this.aiRate = Math.min(presetMax, this.aiRate + CONFIG.AI.ADAPTIVE.ADJUST_STEP);
    }
    this.aiRate = Math.min(this.aiRate, CONFIG.AI.INFERENCE_RATE);
    this.aiIntervalMs = 1000/this.aiRate;
  }

  async _aiLoop(){
    if(!this.isRunning) return;

    const now = performance.now();
    if(!this.aiPaused && now - this.lastAIStamp >= this.aiIntervalMs){
      this.lastAIStamp = now;

      try{
        const dets = await this.vision.detect(this.video);
        this.aiFrames++;

        const rawTracks = this.tracker.update(dets, Date.now(), this.video.videoWidth||1, this.video.videoHeight||1);
        this.mapper.recompute();
        this.tracked = this.physics.analyze(rawTracks);

        this._updateMemory(this.tracked);
        this._updatePrimaryTarget();
        this._adaptiveStep();
      }catch(e){
        console.warn("AI loop error:", e);
      }
    }

    setTimeout(()=>this._aiLoop(), this.aiIntervalMs);
  }

  _renderLoop(){
    if(!this.isRunning) return;

    const now = performance.now();
    if(now - this.lastRenderStamp >= this.renderIntervalMs){
      this.lastRenderStamp = now;
      this.renderFrames++;

      try{
        this.renderer.clear();
        if(this.hudFlags.horizon && this.avionics.isAvailable){
          this.renderer.drawHorizon(this.avionics.pitch, this.avionics.roll);
        }
        this.renderer.drawCrosshair();
        this.renderer.drawTargetBoxes(this.tracked, this.hudFlags.boxes);
        this.radar.update(this.tracked, this.hudFlags.radar);
        this._updateUI();
      }catch(e){
        console.warn("Render loop error:", e);
      }
    }

    requestAnimationFrame(()=>this._renderLoop());
  }

  _updateMemory(tracks){
    for(const tr of tracks){
      const type = (tr.state==='new') ? 'object_detected' : 'object_updated';
      this.memory.recordEvent(type, {
        objectId: tr.id,
        label: tr.label,
        confidence: tr.confidence,
        depthRel: tr.depthRel,
        depthMeters: tr.depthMeters,
        depthMode: tr.depthMode,
        bearingDeg: tr.bearingDeg,
        motionState: tr.motionState
      });
    }

    // FIX: iterator -> array before filter
    const lost = Array.from(this.tracker.tracks.values()).filter(t=>t.state==='lost');
    for(const tr of lost){
      this.memory.recordEvent('object_lost', { objectId: tr.id, label: tr.label });
    }
  }

  _updatePrimaryTarget(){
    if(!this.tracked.length){ this.primaryTarget=null; return; }
    this.primaryTarget = this.tracked.reduce((a,b)=>{
      const da = Math.abs(a.screenPosition.xNorm)+Math.abs(a.screenPosition.yNorm);
      const db = Math.abs(b.screenPosition.xNorm)+Math.abs(b.screenPosition.yNorm);
      // hysteresis: keep old if close
      if(this.primaryTarget && a.id===this.primaryTarget.id && da <= db+0.02) return a;
      return db<da ? b : a;
    });
  }

  _updateUI(){
    // FPS real-time calc
    const t = performance.now();
    if(t - this.fpsTimer >= 1000){
      this.aiFpsReal = this.aiFrames;
      this.renderFpsReal = this.renderFrames;
      this.aiFrames = 0;
      this.renderFrames = 0;
      this.fpsTimer = t;
    }

    const vs = this.vision.status();
    document.getElementById('val-cpu').innerText = Utils.fmt(vs.avgInferenceMs,1);
    document.getElementById('val-ai-fps').innerText = Utils.fmt(this.aiFpsReal,0);
    document.getElementById('val-render-fps').innerText = Utils.fmt(this.renderFpsReal,0);

    document.getElementById('val-pitch').innerText = Utils.fmt(this.avionics.pitch,1);
    document.getElementById('val-roll').innerText = Utils.fmt(this.avionics.roll,1);
    document.getElementById('val-heading').innerText = Utils.fmt(this.avionics.heading,1);
    document.getElementById('val-g').innerText = Utils.fmt(this.avionics.gForce,2);

    const ts = this.tracker.status();
    document.getElementById('val-tracked').innerText = ts.activeTracks;

    document.getElementById('val-active').innerText = this.memory.getActiveObjectCount();
    document.getElementById('val-persons').innerText = this.memory.getPersonDetectionsInLast(5);

    const cp = this.memory.getClosestPerson();
    document.getElementById('val-closest-person').innerText = cp
      ? `${cp.mode==='abs'?'~'+Utils.fmt(cp.distance,1)+'m':'REL '+Utils.fmt(cp.distance/CONFIG.PHYSICS.MAX_RANGE,2)} @ ${Utils.fmt(cp.bearing,0)}°`
      : '--';

    document.getElementById('val-top-label').innerText = this.memory.getMostCommonLabelInLast(5);

    if(this.primaryTarget){
      document.getElementById('val-target-label').innerText = this.primaryTarget.label.toUpperCase();
      document.getElementById('val-target-dist').innerText = (this.primaryTarget.depthMode==='abs')
        ? `~${Utils.fmt(this.primaryTarget.depthMeters,1)}m`
        : `REL ${Utils.fmt(this.primaryTarget.depthRel,2)}`;
      document.getElementById('val-target-bearing').innerText = `${Utils.fmt(this.primaryTarget.bearingDeg,1)}°`;
      document.getElementById('val-target-state').innerText = this.primaryTarget.motionState.toUpperCase();
    }else{
      document.getElementById('val-target-label').innerText = '--';
      document.getElementById('val-target-dist').innerText = '--';
      document.getElementById('val-target-bearing').innerText = '--';
      document.getElementById('val-target-state').innerText = '--';
    }

    this._updateStatusIndicators();
  }

  _updateStatusIndicators(){
    const camOk = this.video.srcObject && this.video.readyState===4 && this.cameraOn;
    document.getElementById('status-cam').className = `status-indicator ${camOk?'status-ok':'status-error'}`;

    document.getElementById('status-ai').className = `status-indicator ${this.vision.isModelLoaded?'status-ok':'status-offline'}`;
    document.getElementById('status-gyro').className = `status-indicator ${this.avionics.isAvailable?'status-ok':'status-offline'}`;

    const hasActive = this.tracker.status().activeTracks>0;
    document.getElementById('status-tracker').className = `status-indicator ${hasActive?'status-ok':'status-warn'}`;

    document.getElementById('status-memory').className = `status-indicator ${this.memory.events.length?'status-ok':'status-warn'}`;
  }

  setPreset(name){
    if(!CONFIG.AI.PRESETS[name]) return;
    OmegaKernel.presetName = name;

    const p = OmegaKernel.currentPreset();
    this.aiRate = Math.min(this.aiRate, p.maxFps);
    this.aiIntervalMs = 1000/this.aiRate;
    this.renderIntervalMs = 1000/p.renderFps;

    this._toast(`Preset set: ${name}`);
  }

  toggleAI(){
    this.aiPaused = !this.aiPaused;
    this._toast(this.aiPaused ? "AI Paused" : "AI Resumed");
  }

  async toggleCamera(){
    this.cameraOn = !this.cameraOn;
    if(!this.cameraOn){
      if(this.video.srcObject){
        this.video.srcObject.getTracks().forEach(t=>t.stop());
      }
      this.video.srcObject = null;
      this._toast("Camera stopped");
    }else{
      const ok = await this._initCamera();
      this.mapper.recompute();
      this._toast(ok ? "Camera resumed" : "Camera resume failed");
    }
  }

  calibratePrimary(Zreal, Hreal){
    if(!this.primaryTarget) return false;
    const ok = this.calibrator.calibrate(this.primaryTarget, Zreal, Hreal);
    if(ok){
      this._toast("Calibration stored");
    }
    return ok;
  }

  shutdown(){
    this.isRunning = false;
    if(this.video.srcObject){
      this.video.srcObject.getTracks().forEach(t=>t.stop());
    }
  }

  _bootLED(id, state){
    const led=document.getElementById(id);
    led.className='status-led';
    if(state==='active') led.classList.add('active');
    if(state==='error') led.classList.add('error');
    if(state==='warning') led.classList.add('warning');
  }

  _status(msg){
    document.getElementById('status-message').textContent = msg;
  }

  _toast(msg){
    const t=document.getElementById('toast');
    t.textContent=msg;
    t.classList.add('show');
    clearTimeout(this._toastTimer);
    this._toastTimer = setTimeout(()=>t.classList.remove('show'), 1200);
  }

  _showError(title, msg){
    document.getElementById('error-title').textContent=title;
    document.getElementById('error-msg').textContent=msg;
    document.getElementById('error-overlay').classList.add('open');
  }

  _bindVisibility(){
    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden){
        // battery-save mode
        this.aiRate = 1;
        this.aiIntervalMs = 1000;
        this._toast("Background mode: AI throttled");
      }else{
        this.aiRate = Math.min(this.aiRate, OmegaKernel.currentPreset().maxFps);
        this.aiIntervalMs = 1000/this.aiRate;
        this._toast("Foreground mode");
      }
    });
  }
}

// ============================================================================
// UI Controller
// ============================================================================
const OMEGA = new OmegaKernel();

document.getElementById('btn-init').addEventListener('click', ()=>OMEGA.boot());

const toggleBtn = document.getElementById('control-toggle');
const panel = document.getElementById('control-panel');
toggleBtn.addEventListener('click', ()=>{
  panel.classList.toggle('open');
});

// Preset
const presetSel = document.getElementById('cp-preset');
presetSel.value = CONFIG.AI.DEFAULT_PRESET;
presetSel.addEventListener('change', e=>{
  OMEGA.setPreset(e.target.value);
});

// AI toggle
const aiBtn = document.getElementById('cp-ai-toggle');
aiBtn.addEventListener('click', ()=>{
  OMEGA.toggleAI();
  aiBtn.textContent = OMEGA.aiPaused ? "Resume AI" : "Pause AI";
});

// Camera toggle
const camBtn = document.getElementById('cp-cam-toggle');
camBtn.addEventListener('click', async ()=>{
  await OMEGA.toggleCamera();
  camBtn.textContent = OMEGA.cameraOn ? "Stop Camera" : "Start Camera";
});

// HUD toggles
const hHorizon = document.getElementById('cp-toggle-horizon');
const hRadar   = document.getElementById('cp-toggle-radar');
const hBoxes   = document.getElementById('cp-toggle-boxes');

function chipToggle(el, key){
  el.addEventListener('click', ()=>{
    OMEGA.hudFlags[key] = !OMEGA.hudFlags[key];
    el.classList.toggle('active', OMEGA.hudFlags[key]);
    if(key==='horizon' && !OMEGA.avionics.isAvailable){
      OMEGA._toast("Gyro offline");
    }
  });
}
chipToggle(hHorizon,'horizon');
chipToggle(hRadar,'radar');
chipToggle(hBoxes,'boxes');

// Calibration modal
const calibModal = document.getElementById('calibrate-modal');
document.getElementById('cp-open-calib').addEventListener('click', ()=>{
  calibModal.classList.add('open');
});
document.getElementById('calib-cancel').addEventListener('click', ()=>{
  calibModal.classList.remove('open');
});
document.getElementById('calib-apply').addEventListener('click', ()=>{
  const Z = parseFloat(document.getElementById('calib-distance').value);
  const H = parseFloat(document.getElementById('calib-height').value);
  const ok = OMEGA.calibratePrimary(Z, H);
  document.getElementById('cp-calib-status').textContent = ok ? "CALIBRATED" : "FAILED (Need primary target full body)";
  calibModal.classList.remove('open');
});

// Memory export/import/clear
document.getElementById('cp-export').addEventListener('click', ()=>{
  const data = OMEGA.memory.exportJSON();
  const blob = new Blob([data],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url; a.download='omega_memory.json'; a.click();
  URL.revokeObjectURL(url);
});

document.getElementById('cp-import').addEventListener('change', async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  const raw = await f.text();
  const ok = OMEGA.memory.importJSON(raw);
  OMEGA._toast(ok ? "Memory imported" : "Import failed");
  e.target.value='';
});

document.getElementById('cp-clear').addEventListener('click', ()=>{
  OMEGA.memory.clear();
  OMEGA._toast("Memory cleared");
});

// Error overlay close
document.getElementById('error-close').addEventListener('click', ()=>{
  document.getElementById('error-overlay').classList.remove('open');
});

// Shutdown on unload
window.addEventListener('beforeunload', ()=>OMEGA.shutdown());

console.log("OMEGA v3.0 loaded");
</script>
</body>
</html>
