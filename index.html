<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OMEGA: ADVANCED HUMANOID VISION SYSTEM</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        :root {
            --hud-primary: #00ff41;
            --hud-secondary: #008f11;
            --hud-alert: #ff0000;
            --hud-warn: #ffcc00;
            --hud-info: #0080ff;
            --hud-critical: #ff0066;
            --bg-dark: #050505;
            --glass: rgba(0, 20, 0, 0.85);
            --glass-dark: rgba(0, 10, 0, 0.95);
            --neon-glow: 0 0 10px currentColor;
        }

        * { 
            box-sizing: border-box; 
            user-select: none; 
            -webkit-touch-callout: none; 
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0; 
            overflow: hidden; 
            background: var(--bg-dark);
            font-family: 'Courier New', 'Consolas', monospace;
            color: var(--hud-primary);
            width: 100vw; 
            height: 100vh;
            line-height: 1.2;
        }

        #viewport { 
            position: relative; 
            width: 100%; 
            height: 100%; 
        }
        
        #camera-feed {
            position: absolute; 
            width: 100%; 
            height: 100%; 
            object-fit: cover;
            z-index: 0; 
            filter: contrast(1.4) brightness(0.7) hue-rotate(90deg) saturate(1.3);
            opacity: 0.5;
        }
        
        #hud-canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 10; 
        }

        #ui-layer {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            z-index: 20; 
            pointer-events: none;
            display: flex; 
            flex-direction: column; 
            justify-content: space-between;
            padding: max(12px, env(safe-area-inset-top));
        }

        .hud-panel {
            background: var(--glass); 
            border: 1px solid var(--hud-primary);
            border-left: 3px solid var(--hud-primary);
            padding: 8px 12px; 
            margin: 6px; 
            width: fit-content;
            backdrop-filter: blur(4px);
            box-shadow: var(--neon-glow);
            clip-path: polygon(0 0, calc(100% - 6px) 0, 100% 6px, 100% 100%, 6px 100%, 0 calc(100% - 6px));
            font-size: 11px;
        }
        
        .hud-panel-wide {
            width: auto;
            min-width: 240px;
            max-width: 280px;
        }
        
        .panel-title {
            font-size: 10px;
            font-weight: bold;
            color: var(--hud-secondary);
            margin-bottom: 6px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        .hud-text { 
            font-size: 10px; 
            letter-spacing: 0.5px; 
            margin-bottom: 3px; 
            text-shadow: var(--neon-glow);
            display: flex;
            justify-content: space-between;
        }
        
        .hud-value { 
            font-weight: bold; 
            color: #fff;
            margin-left: 8px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 6px;
        }

        #radar-container {
            position: absolute; 
            bottom: 15px; 
            right: 15px;
            width: 140px; 
            height: 140px;
            border-radius: 50%;
            background: var(--glass-dark);
            border: 2px solid var(--hud-primary);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
            overflow: hidden;
            z-index: 30;
        }
        
        #radar-container::after {
            content: ''; 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: conic-gradient(from 0deg, transparent 0deg, transparent 270deg, rgba(0,255,65,0.4) 360deg);
            border-radius: 50%;
            animation: radar-scan 3s linear infinite;
        }
        
        .radar-grid {
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            border: 1px solid rgba(0,255,65,0.3); 
            border-radius: 50%; 
            pointer-events: none;
        }
        
        .radar-cross {
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            width: 100%; 
            height: 1px; 
            background: rgba(0,255,65,0.3);
        }
        
        .radar-blip {
            position: absolute; 
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: var(--neon-glow);
            transition: all 0.2s ease-out;
            z-index: 2;
        }
        
        .radar-range {
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: var(--hud-secondary);
        }
        
        @keyframes radar-scan { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }

        #boot-overlay {
            position: fixed; 
            inset: 0; 
            background: #000; 
            z-index: 9999;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            color: var(--hud-primary);
            background: radial-gradient(circle at center, #001100 0%, #000000 70%);
        }
        
        .boot-title {
            font-size: 42px;
            font-weight: 900;
            margin-bottom: 8px;
            letter-spacing: 6px;
            text-shadow: 0 0 20px var(--hud-primary);
            background: linear-gradient(90deg, var(--hud-primary), var(--hud-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .boot-subtitle {
            opacity: 0.7; 
            margin-bottom: 30px;
            font-size: 13px;
            letter-spacing: 2px;
        }
        
        #btn-init {
            background: transparent; 
            color: var(--hud-primary); 
            border: 2px solid var(--hud-primary);
            padding: 14px 50px; 
            font-family: inherit; 
            font-size: 15px; 
            font-weight: bold;
            letter-spacing: 3px; 
            cursor: pointer; 
            margin-top: 30px;
            transition: all 0.3s ease;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
            pointer-events: auto;
        }
        
        #btn-init::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,65,0.4), transparent);
            transition: left 0.5s;
        }
        
        #btn-init:hover::before {
            left: 100%;
        }
        
        #btn-init:hover { 
            background: var(--hud-primary); 
            color: #000; 
            box-shadow: 0 0 25px var(--hud-primary);
        }
        
        .status-list {
            text-align: left; 
            font-size: 11px; 
            line-height: 1.6; 
            opacity: 0.9;
            margin-top: 25px;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .status-led { 
            display: inline-block; 
            width: 8px; 
            height: 8px; 
            background: #333; 
            border-radius: 50%; 
            margin-right: 10px; 
            position: relative;
        }
        
        .status-led::after {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 50%;
            box-shadow: 0 0 6px currentColor;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .status-led.active { 
            background: var(--hud-primary);
        }
        
        .status-led.active::after {
            opacity: 1;
        }
        
        .status-led.error { 
            background: var(--hud-alert);
        }
        
        .status-led.error::after {
            opacity: 1;
        }
        
        .status-led.warning { 
            background: var(--hud-warn);
        }
        
        .status-led.warning::after {
            opacity: 1;
        }
        
        .status-led.loading {
            background: var(--hud-info);
            animation: pulse 1.5s infinite;
        }

        #system-status {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: var(--glass-dark);
            border-top: 1px solid var(--hud-secondary);
            padding: 6px 12px;
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            z-index: 25;
            backdrop-filter: blur(4px);
        }
        
        .status-section {
            display: flex;
            align-items: center;
        }
        
        .status-item-compact {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        
        .status-indicator {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            margin-right: 5px;
            position: relative;
        }
        
        .status-indicator::after {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 50%;
            box-shadow: 0 0 4px currentColor;
        }
        
        .status-ok { 
            background: var(--hud-primary); 
        }
        
        .status-warn { 
            background: var(--hud-warn); 
        }
        
        .status-error { 
            background: var(--hud-alert); 
        }
        
        .status-offline { 
            background: #444; 
        }

        /* Control Panel */
        #control-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: var(--glass-dark);
            border: 1px solid var(--hud-primary);
            padding: 8px;
            border-radius: 4px;
            z-index: 40;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            display: none;
        }

        .control-btn {
            background: transparent;
            border: 1px solid var(--hud-secondary);
            color: var(--hud-primary);
            padding: 4px 8px;
            margin: 2px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 2px;
        }

        .control-btn:hover {
            background: var(--hud-secondary);
        }

        .control-btn.active {
            background: var(--hud-primary);
            color: black;
        }

        #toggle-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 35;
            pointer-events: auto;
            background: var(--glass);
            border: 1px solid var(--hud-primary);
            color: var(--hud-primary);
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 2px;
        }

        /* Permission Overlay */
        #permission-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9998;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--hud-primary);
            text-align: center;
            padding: 20px;
        }

        .permission-content {
            background: var(--glass-dark);
            border: 2px solid var(--hud-primary);
            padding: 20px;
            border-radius: 8px;
            max-width: 400px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes targetLock {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.7; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .critical-alert {
            animation: alertPulse 0.5s infinite;
        }

        @keyframes alertPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .hud-panel-wide {
                min-width: 220px;
                max-width: 250px;
            }
            
            #radar-container {
                width: 120px;
                height: 120px;
                bottom: 10px;
                right: 10px;
            }
            
            .boot-title {
                font-size: 32px;
                letter-spacing: 4px;
            }

            .hud-panel {
                padding: 6px 10px;
                margin: 4px;
            }
        }

        @media (max-width: 480px) {
            .hud-panel {
                padding: 4px 8px;
            }
            
            .status-grid {
                grid-template-columns: 1fr;
            }
            
            #system-status {
                flex-direction: column;
                gap: 2px;
                font-size: 8px;
            }

            #radar-container {
                width: 100px;
                height: 100px;
            }
        }
    </style>
</head>
<body>

    <div id="viewport">
        <video id="camera-feed" autoplay playsinline muted></video>
        <canvas id="hud-canvas"></canvas>
        
        <div id="ui-layer">
            <!-- Top Row: System Status -->
            <div style="display:flex; justify-content:space-between; width:100%;">
                <div class="hud-panel">
                    <div class="panel-title">SYSTEM METRICS</div>
                    <div class="hud-text">AI CPU: <span id="val-cpu" class="hud-value">0</span> ms</div>
                    <div class="hud-text">AI FPS: <span id="val-ai-fps" class="hud-value">0</span></div>
                    <div class="hud-text">RENDER FPS: <span id="val-render-fps" class="hud-value">0</span></div>
                    <div class="hud-text">TRACKED: <span id="val-tracked" class="hud-value">0</span></div>
                </div>
                
                <div class="hud-panel">
                    <div class="panel-title">AVIONICS</div>
                    <div class="hud-text">PITCH: <span id="val-pitch" class="hud-value">0.0°</span></div>
                    <div class="hud-text">ROLL: <span id="val-roll" class="hud-value">0.0°</span></div>
                    <div class="hud-text">HEADING: <span id="val-heading" class="hud-value">0.0°</span></div>
                    <div class="hud-text">G-FORCE: <span id="val-g" class="hud-value">1.00</span></div>
                </div>
            </div>
            
            <!-- Middle: Analytics -->
            <div class="hud-panel hud-panel-wide" style="margin-top: auto; margin-bottom: 160px;">
                <div class="panel-title">TACTICAL ANALYTICS</div>
                <div class="hud-text">ACTIVE OBJECTS: <span id="val-active" class="hud-value">0</span></div>
                <div class="hud-text">PERSONS (5M): <span id="val-persons" class="hud-value">0</span></div>
                <div class="hud-text">CLOSEST PERSON: <span id="val-closest-person" class="hud-value">--</span></div>
                <div class="hud-text">DOMINANT CLASS: <span id="val-top-label" class="hud-value">--</span></div>
            </div>
            
            <!-- Target Acquisition -->
            <div class="hud-panel hud-panel-wide" style="margin-left: auto; margin-right: 160px;">
                <div class="panel-title">PRIMARY TARGET</div>
                <div class="hud-text">CLASS: <span id="val-target-label" class="hud-value">--</span></div>
                <div class="hud-text">DISTANCE: <span id="val-target-dist" class="hud-value">--</span></div>
                <div class="hud-text">BEARING: <span id="val-target-bearing" class="hud-value">--</span></div>
                <div class="hud-text">MOTION: <span id="val-target-state" class="hud-value">--</span></div>
                <div class="hud-text">CONFIDENCE: <span id="val-target-conf" class="hud-value">--</span></div>
            </div>

            <!-- Radar -->
            <div id="radar-container">
                <div class="radar-grid" style="width: 33%; height: 33%;"></div>
                <div class="radar-grid" style="width: 66%; height: 66%;"></div>
                <div class="radar-cross"></div>
                <div class="radar-cross" style="transform: translate(-50%, -50%) rotate(90deg);"></div>
                <div id="radar-blips"></div>
                <div class="radar-range">RANGE: 50M</div>
            </div>
        </div>
        
        <!-- System Status Bar -->
        <div id="system-status">
            <div class="status-section">
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-cam"></span>
                    <span>OPTICAL</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-ai"></span>
                    <span>AI</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-gyro"></span>
                    <span>GYRO</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-tracker"></span>
                    <span>TRACKER</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-memory"></span>
                    <span>MEMORY</span>
                </div>
            </div>
            <div class="status-section">
                <span id="status-message">SYSTEM_STANDBY</span>
            </div>
        </div>

        <!-- Control Panel Toggle -->
        <button id="toggle-controls">CONTROLS</button>

        <!-- Control Panel -->
        <div id="control-panel">
            <div class="panel-title">CONTROL PANEL</div>
            <div>
                <button class="control-btn active" id="btn-quality-low">LOW</button>
                <button class="control-btn" id="btn-quality-balanced">BALANCED</button>
                <button class="control-btn" id="btn-quality-high">HIGH</button>
            </div>
            <div style="margin-top: 8px;">
                <button class="control-btn" id="btn-calibrate">CALIBRATE DEPTH</button>
                <button class="control-btn" id="btn-export">EXPORT DATA</button>
                <button class="control-btn" id="btn-clear">CLEAR MEMORY</button>
            </div>
            <div style="margin-top: 8px;">
                <button class="control-btn active" id="btn-hud-on">HUD ON</button>
                <button class="control-btn" id="btn-hud-off">HUD OFF</button>
            </div>
        </div>
    </div>

    <!-- Boot Screen -->
    <div id="boot-overlay">
        <div class="boot-title">OMEGA</div>
        <div class="boot-subtitle">ADVANCED HUMANOID VISION SYSTEM</div>
        
        <div class="status-list">
            <div class="status-item">
                <span class="status-led" id="led-cam"></span>
                <span>OPTICAL SENSOR ARRAY</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-ai"></span>
                <span>NEURAL NETWORK (COCO-SSD)</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-gyro"></span>
                <span>INERTIAL NAVIGATION</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-tracker"></span>
                <span>MULTI-OBJECT TRACKER</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-memory"></span>
                <span>KNOWLEDGE BASE</span>
            </div>
        </div>
        
        <button id="btn-init">INITIALIZE SYSTEM</button>
    </div>

    <!-- Permission Overlay -->
    <div id="permission-overlay">
        <div class="permission-content">
            <div style="font-size: 18px; margin-bottom: 15px;">PERMISSION REQUIRED</div>
            <div style="margin-bottom: 20px; font-size: 14px;">
                Camera access is required for the vision system to function. Please allow camera permissions when prompted.
            </div>
            <button id="btn-retry-permission" style="
                background: transparent;
                border: 2px solid var(--hud-primary);
                color: var(--hud-primary);
                padding: 10px 20px;
                font-family: inherit;
                cursor: pointer;
            ">RETRY PERMISSION</button>
        </div>
    </div>

<script>
/**
 * OMEGA: ADVANCED HUMANOID VISION SYSTEM
 * Fixed + Production-stable Single-file build
 */

// ============================================================================
// CONFIGURATION - FIXED
// ============================================================================

const CONFIG = {
    AI: {
        MODEL_TYPE: 'lite_mobilenet_v2',
        CONFIDENCE_THRESHOLD: 0.65,
        MAX_DETECTIONS: 20,
        INFERENCE_RATE: 12,
        QUALITY_PRESETS: {
            LOW: { rate: 8, blur: 0 },
            BALANCED: { rate: 12, blur: 4 },
            HIGH: { rate: 15, blur: 8 }
        }
    },
    
    TRACKING: {
        MAX_AGE: 30,              // frames to keep a lost track
        MIN_IOU: 0.4,
        MAX_ASSOCIATION_DISTANCE: 0.3,
        VELOCITY_SMOOTHING: 0.85,
        MAX_TRACKS: 15
    },
    
    PHYSICS: {
        HORIZONTAL_FOV: 67.5,
        VERTICAL_FOV: 52.5,
        MAX_RANGE: 50,
        MIN_RANGE: 0.5,
        PERSON_HEIGHT: 1.75,
        VEHICLE_HEIGHT: 1.6,
        IS_CALIBRATED: false
    },
    
    RADAR: {
        RANGE: 50,
        MAX_BLIPS: 10
    },
    
    MEMORY: {
        MAX_EVENTS: 1000,
        STORAGE_KEY: 'omega_vision_data'
    },
    
    UI: {
        UPDATE_RATE: 30,

        // ✅ FIX: missing color coding caused hard crash
        COLOR_CODING: {
            LOW:    'rgba(0, 255, 65, 0.75)',
            MEDIUM: 'rgba(255, 204, 0, 0.9)',
            HIGH:   'rgba(255, 0, 102, 0.95)'
        }
    }
};

// ============================================================================
// CORE UTILITIES
// ============================================================================

const Utils = {
    clamp: (num, min, max) => Math.min(Math.max(num, min), max),
    map: (value, x1, y1, x2, y2) => (value - x1) * (y2 - x2) / (y1 - x1) + x2,
    distance: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
    
    iou: (rect1, rect2) => {
        const x1 = Math.max(rect1.x, rect2.x);
        const y1 = Math.max(rect1.y, rect2.y);
        const x2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width);
        const y2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);
        const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
        const area1 = rect1.width * rect1.height;
        const area2 = rect2.width * rect2.height;
        const union = area1 + area2 - intersection;
        return union > 0 ? intersection / union : 0;
    },
    
    ema: (current, previous, factor) => previous * factor + current * (1 - factor),
    generateId: () => 'id_' + Math.random().toString(36).substr(2, 9),
    formatNumber: (value, decimals = 1) => Number(value).toFixed(decimals)
};

// ============================================================================
// AVIONICS - FIXED iOS MOTION PERMISSION
// ============================================================================

class Avionics {
    constructor() {
        this.pitch = 0;
        this.roll = 0;
        this.heading = 0;
        this.gForce = 1.0;
        this.rotationRate = { alpha: 0, beta: 0, gamma: 0 };
        this.isAvailable = false;
    }

    async init() {
        try {
            // iOS permission for orientation
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                const state = await DeviceOrientationEvent.requestPermission();
                if (state !== 'granted') throw new Error("GYRO PERMISSION DENIED");
            }

            // ✅ FIX: iOS also requires DeviceMotion permission
            if (typeof DeviceMotionEvent !== 'undefined' &&
                typeof DeviceMotionEvent.requestPermission === 'function') {
                const state2 = await DeviceMotionEvent.requestPermission();
                if (state2 !== 'granted') throw new Error("MOTION PERMISSION DENIED");
            }
            
            window.addEventListener('deviceorientation', e => {
                this.pitch = e.beta || 0;
                this.roll = e.gamma || 0;
                this.heading = e.alpha || 0;
            });
            
            window.addEventListener('devicemotion', e => {
                const acc = e.accelerationIncludingGravity;
                if (acc) {
                    const {x, y, z} = acc;
                    this.gForce = Math.sqrt(x*x + y*y + z*z) / 9.81;
                }
                if (e.rotationRate) {
                    this.rotationRate = {
                        alpha: e.rotationRate.alpha || 0,
                        beta: e.rotationRate.beta || 0,
                        gamma: e.rotationRate.gamma || 0
                    };
                }
            });
            
            this.isAvailable = true;
            return true;
        } catch (error) {
            console.warn("Avionics skipped:", error);
            this.isAvailable = false;
            return false;
        }
    }

    getOrientation() {
        return { pitch: this.pitch, roll: this.roll, heading: this.heading };
    }

    getMotion() {
        return { gForce: this.gForce, rotationRate: { ...this.rotationRate } };
    }
}

// ============================================================================
// VISION ENGINE
// ============================================================================

class VisionEngine {
    constructor() {
        this.model = null;
        this.isModelLoaded = false;
        this.inferenceStats = { lastTime: 0, averageTime: 0, aiFps: 0, renderFps: 0 };
        this.qualityPreset = 'BALANCED';
        this.lastRenderTime = 0;
    }

    async init() {
        try {
            await tf.ready();
            this.model = await cocoSsd.load({ base: CONFIG.AI.MODEL_TYPE });
            this.isModelLoaded = true;
            return true;
        } catch (error) {
            console.error("Vision engine failed:", error);
            return false;
        }
    }

    async detect(videoEl) {
        if (!this.model || !this.isModelLoaded) return [];
        const startTime = performance.now();
        try {
            const results = await this.model.detect(
                videoEl, 
                CONFIG.AI.MAX_DETECTIONS, 
                CONFIG.AI.CONFIDENCE_THRESHOLD
            );
            const processingTime = performance.now() - startTime;
            this._updateInferenceStats(processingTime);
            return results;
        } catch (error) {
            console.error("Detection error:", error);
            return [];
        }
    }

    _updateInferenceStats(processingTime) {
        this.inferenceStats.lastTime = processingTime;
        this.inferenceStats.averageTime = Utils.ema(processingTime, this.inferenceStats.averageTime, 0.95);
        this.inferenceStats.aiFps = 1000 / Math.max(1, this.inferenceStats.averageTime);
    }

    updateRenderFPS() {
        const now = performance.now();
        if (this.lastRenderTime > 0) {
            const frameTime = now - this.lastRenderTime;
            this.inferenceStats.renderFps = 1000 / Math.max(1, frameTime);
        }
        this.lastRenderTime = now;
    }

    setQualityPreset(preset) { this.qualityPreset = preset; }
    getInferenceRate() { return CONFIG.AI.QUALITY_PRESETS[this.qualityPreset].rate; }
    getStatus() { return { isModelLoaded: this.isModelLoaded, ...this.inferenceStats }; }
}

// ============================================================================
// OBJECT TRACKER - FIXED TTL BY ACTUAL RATE
// ============================================================================

class ObjectTracker {
    constructor() {
        this.tracks = new Map();
        this.nextId = 1;
        this.frameCount = 0;
        this.inferenceRate = CONFIG.AI.INFERENCE_RATE;
    }

    update(detections, timestamp, inferenceRate = CONFIG.AI.INFERENCE_RATE) {
        this.frameCount++;
        this.inferenceRate = inferenceRate;

        const currentDetections = detections.map(det => ({
            bbox: {
                x: det.bbox[0],
                y: det.bbox[1],
                width: det.bbox[2],
                height: det.bbox[3]
            },
            label: det.class,
            confidence: det.score,
            timestamp
        }));
        
        this._updateTracks(currentDetections, timestamp);
        this._removeExpiredTracks(timestamp);
        
        if (this.tracks.size > CONFIG.TRACKING.MAX_TRACKS) this._pruneTracks();
        return Array.from(this.tracks.values());
    }

    _updateTracks(detections, timestamp) {
        const usedDetections = new Set();

        for (const [id, track] of this.tracks.entries()) {
            if (track.status === 'lost') continue;

            let bestMatch = null;
            let bestScore = 0;
            
            for (let i = 0; i < detections.length; i++) {
                if (usedDetections.has(i)) continue;
                
                const detection = detections[i];
                
                const iouScore = Utils.iou(track.bbox, detection.bbox);
                const centerDist = Utils.distance(
                    track.bbox.x + track.bbox.width / 2,
                    track.bbox.y + track.bbox.height / 2,
                    detection.bbox.x + detection.bbox.width / 2,
                    detection.bbox.y + detection.bbox.height / 2
                ) / Math.sqrt(window.innerWidth * window.innerHeight);
                
                const labelScore = track.label === detection.label ? 1 : 0.5;
                const velocityScore = this._calculateVelocityScore(track, detection, timestamp);
                
                const totalScore =
                    iouScore * 0.4 +
                    (1 - centerDist) * 0.3 +
                    labelScore * 0.2 +
                    velocityScore * 0.1;
                
                if (totalScore > bestScore && totalScore > CONFIG.TRACKING.MIN_IOU) {
                    bestScore = totalScore;
                    bestMatch = { index: i, detection };
                }
            }
            
            if (bestMatch) {
                this._updateTrack(track, bestMatch.detection, timestamp);
                usedDetections.add(bestMatch.index);
            } else {
                track.status = 'lost';
                track.lastSeen = timestamp;
            }
        }

        for (let i = 0; i < detections.length; i++) {
            if (!usedDetections.has(i)) this._createTrack(detections[i], timestamp);
        }
    }

    _calculateVelocityScore(track, detection, timestamp) {
        if (!track.lastPosition || track.status === 'new') return 0.5;
        const dt = (timestamp - track.lastUpdateTime) / 1000;
        if (dt <= 0) return 0.5;

        const predX = track.bbox.x + (track.velocity?.vx || 0) * dt;
        const predY = track.bbox.y + (track.velocity?.vy || 0) * dt;
        const dist = Utils.distance(predX, predY, detection.bbox.x, detection.bbox.y);
        const maxDist = Math.sqrt(window.innerWidth * window.innerHeight) * 0.1;
        return Math.max(0, 1 - (dist / maxDist));
    }

    _updateTrack(track, detection, timestamp) {
        const dt = (timestamp - track.lastUpdateTime) / 1000;

        track.rawBbox = { ...detection.bbox };
        track.bbox.x = Utils.ema(detection.bbox.x, track.bbox.x, 0.7);
        track.bbox.y = Utils.ema(detection.bbox.y, track.bbox.y, 0.7);
        track.bbox.width = Utils.ema(detection.bbox.width, track.bbox.width, 0.7);
        track.bbox.height = Utils.ema(detection.bbox.height, track.bbox.height, 0.7);

        if (track.lastPosition && dt > 0) {
            const dx = (track.bbox.x - track.lastPosition.x) / dt;
            const dy = (track.bbox.y - track.lastPosition.y) / dt;
            track.velocity = {
                vx: Utils.ema(dx, track.velocity?.vx || 0, CONFIG.TRACKING.VELOCITY_SMOOTHING),
                vy: Utils.ema(dy, track.velocity?.vy || 0, CONFIG.TRACKING.VELOCITY_SMOOTHING)
            };
        }

        track.lastPosition = { x: track.bbox.x, y: track.bbox.y };
        track.lastUpdateTime = timestamp;
        track.status = track.status === 'new' ? 'active' : track.status;
        track.label = detection.label;
        track.confidence = detection.confidence;
    }

    _createTrack(detection, timestamp) {
        const id = this.nextId++;
        this.tracks.set(id, {
            id,
            label: detection.label,
            confidence: detection.confidence,
            bbox: { ...detection.bbox },
            rawBbox: { ...detection.bbox },
            firstSeen: timestamp,
            lastSeen: timestamp,
            lastUpdateTime: timestamp,
            status: 'new',
            velocity: { vx: 0, vy: 0 },
            lastPosition: { x: detection.bbox.x, y: detection.bbox.y }
        });
    }

    _removeExpiredTracks(timestamp) {
        const tracksArray = Array.from(this.tracks.entries());
        const frameTTLms = CONFIG.TRACKING.MAX_AGE * (1000 / Math.max(1, this.inferenceRate));

        for (const [id, track] of tracksArray) {
            if (track.status === 'lost' && timestamp - track.lastSeen > frameTTLms) {
                this.tracks.delete(id);
            }
        }
    }

    _pruneTracks() {
        const arr = Array.from(this.tracks.entries());
        arr.sort((a, b) => b[1].confidence - a[1].confidence);
        while (this.tracks.size > CONFIG.TRACKING.MAX_TRACKS) {
            const [id] = arr.pop();
            this.tracks.delete(id);
        }
    }

    getActiveTracks() {
        return Array.from(this.tracks.values()).filter(t => t.status !== 'lost');
    }

    getStats() {
        const active = this.getActiveTracks();
        return {
            totalTracks: this.tracks.size,
            activeTracks: active.length,
            newTracks: active.filter(t => t.status === 'new').length
        };
    }
}

// ============================================================================
// PHYSICS ENGINE - FIXED DEPTH SEMANTICS
// ============================================================================

class PhysicsEngine {
    constructor() {
        this.videoWidth = 1280;
        this.videoHeight = 720;
        this.scaleX = 1;
        this.scaleY = 1;
        this.offsetX = 0;
        this.offsetY = 0;
    }

    updateVideoDimensions(video) {
        if (video.videoWidth && video.videoHeight) {
            this.videoWidth = video.videoWidth;
            this.videoHeight = video.videoHeight;

            // reset offsets each update
            this.offsetX = 0; 
            this.offsetY = 0;
            
            const videoAspect = this.videoWidth / this.videoHeight;
            const screenAspect = window.innerWidth / window.innerHeight;
            
            if (videoAspect > screenAspect) {
                this.scaleX = window.innerWidth / this.videoWidth;
                this.scaleY = this.scaleX;
                this.offsetY = (window.innerHeight - this.videoHeight * this.scaleY) / 2;
            } else {
                this.scaleY = window.innerHeight / this.videoHeight;
                this.scaleX = this.scaleY;
                this.offsetX = (window.innerWidth - this.videoWidth * this.scaleX) / 2;
            }
        }
    }

    analyze(tracks) {
        return tracks.map(track => {
            const enhanced = { ...track };
            
            const screenBbox = this._videoToScreenBbox(track.bbox);
            enhanced.screenBbox = screenBbox;
            
            const centerX = screenBbox.x + screenBbox.width / 2;
            const centerY = screenBbox.y + screenBbox.height / 2;
            
            enhanced.screenPosition = {
                xNorm: (centerX / window.innerWidth) * 2 - 1,
                yNorm: (centerY / window.innerHeight) * 2 - 1
            };
            
            enhanced.bearingDeg = this._computeBearing(enhanced.screenPosition.xNorm);
            
            // ✅ FIX: always meters estimate; keep norm separately
            const depthMeters = this._computeDepthMeters(track);
            const depthNorm   = Utils.clamp(1 - (depthMeters / CONFIG.PHYSICS.MAX_RANGE), 0, 1);

            enhanced.depthMeters   = depthMeters;
            enhanced.depthNorm     = depthNorm;
            enhanced.depthEstimate = depthMeters;

            enhanced.motionAnalysis = this._analyzeMotion(track);
            
            return enhanced;
        });
    }

    _videoToScreenBbox(videoBbox) {
        return {
            x: videoBbox.x * this.scaleX + this.offsetX,
            y: videoBbox.y * this.scaleY + this.offsetY,
            width: videoBbox.width * this.scaleX,
            height: videoBbox.height * this.scaleY
        };
    }

    _computeBearing(xNorm) {
        return (xNorm || 0) * (CONFIG.PHYSICS.HORIZONTAL_FOV / 2);
    }

    _computeDepthMeters(track) {
        const bboxHeightPx = track.bbox.height;
        const bboxHeightNorm = bboxHeightPx / this.videoHeight;

        let physicalHeight;
        switch (track.label) {
            case 'person': physicalHeight = CONFIG.PHYSICS.PERSON_HEIGHT; break;
            case 'car':
            case 'truck':
            case 'bus': physicalHeight = CONFIG.PHYSICS.VEHICLE_HEIGHT; break;
            default: physicalHeight = 1.0;
        }

        const focalLengthPx = (this.videoHeight / 2) /
            Math.tan(CONFIG.PHYSICS.VERTICAL_FOV * Math.PI / 360);

        const denom = Math.max(1e-6, bboxHeightNorm * this.videoHeight);
        const depth = (focalLengthPx * physicalHeight) / denom;

        return Utils.clamp(depth, CONFIG.PHYSICS.MIN_RANGE, CONFIG.PHYSICS.MAX_RANGE);
    }

    _analyzeMotion(track) {
        if (!track.velocity || track.status === 'new') {
            return { motionState: 'unknown', radialSpeed: 0 };
        }
        
        const scaleChange = track.velocity.vy / window.innerHeight;
        let motionState = 'static';
        
        if (scaleChange > 0.02) motionState = 'approaching';
        else if (scaleChange < -0.01) motionState = 'receding';
        else if (Math.abs(scaleChange) < 0.005) motionState = 'static';
        else motionState = 'moving';
        
        return { motionState, radialSpeed: scaleChange };
    }

    calibrateDepth(knownDistance, track) {
        CONFIG.PHYSICS.IS_CALIBRATED = true;
        return knownDistance / Math.max(1e-6, track.depthMeters);
    }
}

// ============================================================================
// RADAR SYSTEM - FIXED SIZING + CLEARING
// ============================================================================

class RadarSystem {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.outer = this.container.closest('#radar-container') || this.container;
        this._recomputeGeometry();
    }

    _recomputeGeometry() {
        const rect = this.outer.getBoundingClientRect();
        this.width = rect.width;
        this.height = rect.height;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        this.maxRadius = Math.min(this.width, this.height) / 2 - 6;
    }

    update(tracks) {
        this._recomputeGeometry();

        // ✅ FIX: clear correctly every update
        this.container.innerHTML = '';

        const displayTracks = tracks.slice(0, CONFIG.RADAR.MAX_BLIPS);

        displayTracks.forEach(track => {
            if (track.bearingDeg == null) return;
            const blip = this._createBlip(track);
            if (blip) this.container.appendChild(blip);
        });
    }

    _createBlip(track) {
        const bearingDeg = (track.bearingDeg ?? 0);
        const angle = bearingDeg * Math.PI / 180;

        const depth = track.depthMeters ?? track.depthEstimate ?? CONFIG.PHYSICS.MAX_RANGE;
        const clampedDepth = Utils.clamp(depth, CONFIG.PHYSICS.MIN_RANGE, CONFIG.PHYSICS.MAX_RANGE);
        const range = (clampedDepth / CONFIG.PHYSICS.MAX_RANGE) * this.maxRadius;

        const x = this.centerX + range * Math.sin(angle);
        const y = this.centerY - range * Math.cos(angle);

        const blip = document.createElement('div');
        blip.className = 'radar-blip';
        blip.style.left = `${x}px`;
        blip.style.top = `${y}px`;

        let size = 6;
        let color = CONFIG.UI.COLOR_CODING.LOW;

        switch (track.label) {
            case 'person':
                size = 8; color = CONFIG.UI.COLOR_CODING.HIGH; break;
            case 'car':
            case 'truck':
            case 'bus':
                size = 10; color = CONFIG.UI.COLOR_CODING.MEDIUM; break;
        }

        if (track.motionAnalysis?.motionState === 'approaching') {
            size += 2;
            blip.style.animation = 'pulse 1s infinite';
        }

        blip.style.width = `${size}px`;
        blip.style.height = `${size}px`;
        blip.style.backgroundColor = color;
        return blip;
    }
}

// ============================================================================
// KNOWLEDGE BASE - FIXED CLOSEST LOGIC
// ============================================================================

class KnowledgeBase {
    constructor() {
        this.events = [];
        this.loadFromStorage();
    }

    recordEvent(type, data, timestamp = Date.now()) {
        const event = { type, data, timestamp, id: Utils.generateId() };
        this.events.push(event);

        if (this.events.length > CONFIG.MEMORY.MAX_EVENTS) this.events.shift();
        if (this.events.length % 10 === 0) this.saveToStorage();

        return event.id;
    }

    saveToStorage() {
        try {
            const data = { events: this.events.slice(-500), timestamp: Date.now() };
            localStorage.setItem(CONFIG.MEMORY.STORAGE_KEY, JSON.stringify(data));
        } catch (error) {
            console.warn("Failed to save to storage:", error);
        }
    }

    loadFromStorage() {
        try {
            const stored = localStorage.getItem(CONFIG.MEMORY.STORAGE_KEY);
            if (stored) {
                const data = JSON.parse(stored);
                this.events = data.events || [];
            }
        } catch (error) {
            console.warn("Failed to load from storage:", error);
        }
    }

    clear() {
        this.events = [];
        localStorage.removeItem(CONFIG.MEMORY.STORAGE_KEY);
    }

    exportData() {
        const data = {
            events: this.events,
            exportTime: new Date().toISOString(),
            totalEvents: this.events.length
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `omega_vision_export_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    getActiveObjectCount() {
        const recentTime = Date.now() - 5000;
        const active = new Set();
        for (const e of this.events.slice().reverse()) {
            if (e.timestamp < recentTime) break;
            if (e.data.objectId && (e.type === 'object_detected' || e.type === 'object_updated')) {
                active.add(e.data.objectId);
            }
        }
        return active.size;
    }

    getPersonDetectionsInLast(minutes) {
        const cutoff = Date.now() - (minutes * 60 * 1000);
        return this.events.filter(e => e.timestamp >= cutoff && e.data.label === 'person').length;
    }

    getClosestPerson() {
        const persons = this.events.filter(e =>
            e.data.label === 'person' && typeof e.data.depthMeters === 'number'
        );
        if (!persons.length) return null;

        // ✅ FIX: choose smallest meters = closest
        const closest = persons.reduce((prev, cur) =>
            cur.data.depthMeters < prev.data.depthMeters ? cur : prev
        );

        return {
            distance: closest.data.depthMeters,
            bearing: closest.data.bearingDeg || 0
        };
    }

    getMostCommonLabelInLast(minutes) {
        const cutoff = Date.now() - (minutes * 60 * 1000);
        const recent = this.events.filter(e => e.timestamp >= cutoff);

        const counts = {};
        for (const e of recent) {
            if (!e.data.label) continue;
            counts[e.data.label] = (counts[e.data.label] || 0) + 1;
        }

        let best = 'none', max = 0;
        for (const [label, c] of Object.entries(counts)) {
            if (c > max) { max = c; best = label; }
        }
        return best;
    }
}

// ============================================================================
// HUD RENDERER - FIXED LABEL CLAMP
// ============================================================================

class HUDRenderer {
    constructor() {
        this.canvas = document.getElementById('hud-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        this.hudEnabled = true;
        window.addEventListener('resize', () => this.resize());
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    render(avionicsData, tracks, primaryTarget) {
        if (!this.hudEnabled) { this.clear(); return; }
        this.clear();
        this.ctx.imageSmoothingEnabled = false;

        this.drawHorizon(avionicsData);
        this.drawCrosshair();
        this.drawTargetBoxes(tracks);
        if (primaryTarget) this.drawPrimaryTarget(primaryTarget);
    }

    drawHorizon(avionicsData) {
        const { width, height } = this.canvas;
        const ctx = this.ctx;
        const { pitch, roll } = avionicsData.getOrientation();
        
        ctx.save();
        ctx.translate(width/2, height/2);
        ctx.rotate(roll * Math.PI / 180);
        const horizonY = pitch * 2;

        ctx.fillStyle = 'rgba(0, 50, 100, 0.3)';
        ctx.fillRect(-width, -height, width * 2, height + horizonY);

        ctx.fillStyle = 'rgba(101, 67, 33, 0.3)';
        ctx.fillRect(-width, horizonY, width * 2, height);

        ctx.strokeStyle = 'rgba(0, 255, 65, 0.5)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-width, horizonY);
        ctx.lineTo(width, horizonY);
        ctx.stroke();
        ctx.restore();
    }

    drawCrosshair() {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        const ctx = this.ctx;

        ctx.strokeStyle = CONFIG.UI.COLOR_CODING.LOW;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(cx, cy, 20, 0, Math.PI * 2);
        ctx.moveTo(cx - 10, cy); ctx.lineTo(cx - 30, cy);
        ctx.moveTo(cx + 10, cy); ctx.lineTo(cx + 30, cy);
        ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy - 30);
        ctx.moveTo(cx, cy + 10); ctx.lineTo(cx, cy + 30);
        ctx.stroke();

        ctx.fillStyle = CONFIG.UI.COLOR_CODING.HIGH;
        ctx.fillRect(cx - 1, cy - 1, 2, 2);
    }

    drawTargetBoxes(tracks) { tracks.forEach(t => this.drawTargetBox(t)); }

    drawTargetBox(track) {
        const bbox = track.screenBbox || track.bbox;
        const { x, y, width, height } = bbox;
        const ctx = this.ctx;
        
        let color = CONFIG.UI.COLOR_CODING.LOW;
        if (track.label === 'person') color = CONFIG.UI.COLOR_CODING.HIGH;
        else if (['car','truck','bus'].includes(track.label)) color = CONFIG.UI.COLOR_CODING.MEDIUM;
        
        const bracketSize = Math.min(width, height) * 0.15;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 5;
        ctx.shadowColor = color;
        ctx.beginPath();

        ctx.moveTo(x, y + bracketSize);
        ctx.lineTo(x, y);
        ctx.lineTo(x + bracketSize, y);

        ctx.moveTo(x + width - bracketSize, y);
        ctx.lineTo(x + width, y);
        ctx.lineTo(x + width, y + bracketSize);

        ctx.moveTo(x + width, y + height - bracketSize);
        ctx.lineTo(x + width, y + height);
        ctx.lineTo(x + width - bracketSize, y + height);

        ctx.moveTo(x + bracketSize, y + height);
        ctx.lineTo(x, y + height);
        ctx.lineTo(x, y + height - bracketSize);

        ctx.stroke();
        ctx.shadowBlur = 0;

        const label = `${track.label.toUpperCase()} ${Math.floor(track.confidence * 100)}%`;
        const dist = CONFIG.PHYSICS.IS_CALIBRATED
            ? `~${Math.floor(track.depthMeters)}m`
            : `${Math.floor((track.depthNorm ?? 0) * 100)}%`;

        ctx.font = "bold 10px monospace";
        const textWidth = ctx.measureText(label).width;

        // ✅ FIX: clamp label inside screen
        const labelY = Math.max(0, y - 25);

        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(x, labelY, textWidth + 10, 20);

        ctx.fillStyle = color;
        ctx.fillText(label, x + 5, labelY + 14);
    }

    drawPrimaryTarget(target) {
        const bbox = target.screenBbox || target.bbox;
        const centerX = bbox.x + bbox.width / 2;
        const centerY = bbox.y + bbox.height / 2;
        const ctx = this.ctx;

        const pulsePhase = (Date.now() % 1000) / 1000;
        const radius = Math.max(bbox.width, bbox.height) / 2 + 15 +
            Math.sin(pulsePhase * Math.PI * 2) * 5;
        
        ctx.strokeStyle = CONFIG.UI.COLOR_CODING.HIGH;
        ctx.lineWidth = 2;
        ctx.setLineDash([5,5]);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    setHudEnabled(enabled) { this.hudEnabled = enabled; }
}

// ============================================================================
// OMEGA KERNEL
// ============================================================================

class OmegaKernel {
    constructor() {
        this.avionics = new Avionics();
        this.vision   = new VisionEngine();
        this.tracker  = new ObjectTracker();
        this.physics  = new PhysicsEngine();
        this.radar    = new RadarSystem('radar-blips');
        this.memory   = new KnowledgeBase();
        this.renderer = new HUDRenderer();
        
        this.isRunning = false;
        this.video = document.getElementById('camera-feed');
        this.trackedObjects = [];
        this.primaryTarget = null;
        
        this.lastAITime = 0;
        this._setupControls();
    }

    _setupControls() {
        document.getElementById('toggle-controls').addEventListener('click', () => {
            const panel = document.getElementById('control-panel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        });

        document.getElementById('btn-quality-low').addEventListener('click', () => this._setQuality('LOW'));
        document.getElementById('btn-quality-balanced').addEventListener('click', () => this._setQuality('BALANCED'));
        document.getElementById('btn-quality-high').addEventListener('click', () => this._setQuality('HIGH'));

        document.getElementById('btn-hud-on').addEventListener('click', () => this._setHudEnabled(true));
        document.getElementById('btn-hud-off').addEventListener('click', () => this._setHudEnabled(false));

        document.getElementById('btn-export').addEventListener('click', () => this.memory.exportData());
        document.getElementById('btn-clear').addEventListener('click', () => {
            if (confirm('Clear all memory data?')) this.memory.clear();
        });

        document.getElementById('btn-calibrate').addEventListener('click', () => this._startCalibration());
        document.getElementById('btn-retry-permission').addEventListener('click', () => this._retryPermission());
    }

    _setQuality(preset) {
        this.vision.setQualityPreset(preset);

        // ✅ FIX: only update quality buttons
        ['low','balanced','high'].forEach(k => {
            const btn = document.getElementById(`btn-quality-${k}`);
            btn && btn.classList.remove('active');
        });
        document.getElementById(`btn-quality-${preset.toLowerCase()}`).classList.add('active');

        const blur = CONFIG.AI.QUALITY_PRESETS[preset].blur;
        document.getElementById('ui-layer').style.backdropFilter = `blur(${blur}px)`;
    }

    _setHudEnabled(enabled) {
        this.renderer.setHudEnabled(enabled);
        document.getElementById('btn-hud-on').classList.toggle('active', enabled);
        document.getElementById('btn-hud-off').classList.toggle('active', !enabled);
    }

    async boot() {
        try {
            this._updateStatus('INITIALIZING...');
            
            this._updateBootLED('led-gyro', 'loading');
            const avionicsReady = await this.avionics.init();
            this._updateBootLED('led-gyro', avionicsReady ? 'active' : 'warning');
            
            this._updateBootLED('led-cam', 'loading');
            const cameraReady = await this._initCamera();
            this._updateBootLED('led-cam', cameraReady ? 'active' : 'error');
            
            if (!cameraReady) { this._showPermissionOverlay(); return; }
            
            this._updateBootLED('led-ai', 'loading');
            const visionReady = await this.vision.init();
            this._updateBootLED('led-ai', visionReady ? 'active' : 'error');
            
            this._updateBootLED('led-tracker', 'active');
            this._updateBootLED('led-memory', 'active');
            
            document.getElementById('boot-overlay').style.display = 'none';
            this.isRunning = true;
            this._updateStatus('SYSTEM_OPERATIONAL');

            this.aiCycle();
            this.renderCycle();
        } catch (error) {
            console.error("Boot failed:", error);
            this._updateStatus(`ERROR: ${error.message}`);
        }
    }

    async _initCamera() {
        try {
            if (!navigator.mediaDevices?.getUserMedia) throw new Error('getUserMedia not supported');

            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }, 
                audio: false 
            });

            this.video.srcObject = stream;
            await new Promise(resolve => {
                this.video.onloadedmetadata = () => this.video.play().then(resolve);
            });

            this.physics.updateVideoDimensions(this.video);
            return true;
        } catch (error) {
            console.error("Camera init failed:", error);
            return false;
        }
    }

    _showPermissionOverlay() {
        document.getElementById('permission-overlay').style.display = 'flex';
        this._updateStatus('CAMERA_PERMISSION_REQUIRED');
    }

    _retryPermission() {
        document.getElementById('permission-overlay').style.display = 'none';
        setTimeout(() => this.boot(), 100);
    }

    async aiCycle() {
        if (!this.isRunning) return;
        
        const now = performance.now();
        const rate = this.vision.getInferenceRate();
        const aiInterval = 1000 / rate;
        
        if (now - this.lastAITime >= aiInterval) {
            this.lastAITime = now;
            try {
                const detections = await this.vision.detect(this.video);
                const rawTracks = this.tracker.update(detections, Date.now(), rate);
                this.trackedObjects = this.physics.analyze(rawTracks);
                this._updateMemory(this.trackedObjects);
                this._updatePrimaryTarget();
            } catch (error) {
                console.error("AI cycle error:", error);
            }
        }
        
        const nextCycle = Math.max(0, aiInterval - (performance.now() - this.lastAITime));
        setTimeout(() => this.aiCycle(), nextCycle);
    }

    renderCycle() {
        if (!this.isRunning) return;

        this.vision.updateRenderFPS();
        this.renderer.render(this.avionics, this.trackedObjects, this.primaryTarget);
        this.radar.update(this.trackedObjects);
        this._updateUI();

        performanceMonitor.update(); // ✅ FIX: actually used

        requestAnimationFrame(() => this.renderCycle());
    }

    _updateMemory(tracks) {
        const tracksArray = Array.from(this.tracker.tracks.values());
        
        tracks.forEach(track => {
            const eventType = track.status === 'new' ? 'object_detected' : 'object_updated';
            this.memory.recordEvent(eventType, {
                objectId: track.id,
                label: track.label,
                confidence: track.confidence,
                depthMeters: track.depthMeters,
                depthNorm: track.depthNorm,
                bearingDeg: track.bearingDeg,
                motionState: track.motionAnalysis?.motionState
            });
        });

        const lostTracks = tracksArray.filter(t => t.status === 'lost');
        lostTracks.forEach(track => {
            this.memory.recordEvent('object_lost', {
                objectId: track.id,
                label: track.label
            });
        });
    }

    _updatePrimaryTarget() {
        if (!this.trackedObjects.length) { this.primaryTarget = null; return; }
        this.primaryTarget = this.trackedObjects.reduce((closest, cur) => {
            const cd = Math.abs(closest.screenPosition.xNorm) + Math.abs(closest.screenPosition.yNorm);
            const nd = Math.abs(cur.screenPosition.xNorm) + Math.abs(cur.screenPosition.yNorm);
            return nd < cd ? cur : closest;
        });
    }

    _updateUI() {
        const visionStatus = this.vision.getStatus();
        document.getElementById('val-cpu').textContent = Utils.formatNumber(visionStatus.lastTime, 1);
        document.getElementById('val-ai-fps').textContent = Utils.formatNumber(visionStatus.aiFps, 1);
        document.getElementById('val-render-fps').textContent = Utils.formatNumber(visionStatus.renderFps, 1);

        const orientation = this.avionics.getOrientation();
        document.getElementById('val-pitch').textContent = Utils.formatNumber(orientation.pitch, 1) + '°';
        document.getElementById('val-roll').textContent = Utils.formatNumber(orientation.roll, 1) + '°';
        document.getElementById('val-heading').textContent = Utils.formatNumber(orientation.heading, 1) + '°';
        document.getElementById('val-g').textContent = Utils.formatNumber(this.avionics.gForce, 2);

        const trackerStats = this.tracker.getStats();
        document.getElementById('val-tracked').textContent = trackerStats.activeTracks;

        document.getElementById('val-active').textContent = this.memory.getActiveObjectCount();
        document.getElementById('val-persons').textContent = this.memory.getPersonDetectionsInLast(5);

        const closestPerson = this.memory.getClosestPerson();
        document.getElementById('val-closest-person').textContent = closestPerson
            ? `~${Utils.formatNumber(closestPerson.distance, 1)}m @ ${Utils.formatNumber(closestPerson.bearing, 0)}°`
            : '--';

        document.getElementById('val-top-label').textContent = this.memory.getMostCommonLabelInLast(5);

        if (this.primaryTarget) {
            document.getElementById('val-target-label').textContent = this.primaryTarget.label.toUpperCase();

            // show meters if calibrated else show % norm
            const distText = CONFIG.PHYSICS.IS_CALIBRATED
                ? `~${Utils.formatNumber(this.primaryTarget.depthMeters, 1)}m`
                : `${Math.floor((this.primaryTarget.depthNorm ?? 0) * 100)}%`;

            document.getElementById('val-target-dist').textContent = distText;
            document.getElementById('val-target-bearing').textContent =
                `${Utils.formatNumber(this.primaryTarget.bearingDeg, 1)}°`;
            document.getElementById('val-target-state').textContent =
                (this.primaryTarget.motionAnalysis?.motionState || 'unknown').toUpperCase();
            document.getElementById('val-target-conf').textContent =
                `${Math.floor(this.primaryTarget.confidence * 100)}%`;
        }

        this._updateSystemStatus();
    }

    _updateSystemStatus() {
        document.getElementById('status-cam').className =
            `status-indicator ${this.video.srcObject ? 'status-ok' : 'status-error'}`;
        document.getElementById('status-ai').className =
            `status-indicator ${this.vision.isModelLoaded ? 'status-ok' : 'status-error'}`;
        document.getElementById('status-gyro').className =
            `status-indicator ${this.avionics.isAvailable ? 'status-ok' : 'status-offline'}`;
        document.getElementById('status-tracker').className =
            `status-indicator ${this.trackedObjects.length ? 'status-ok' : 'status-warn'}`;
        document.getElementById('status-memory').className =
            `status-indicator ${this.memory.events.length ? 'status-ok' : 'status-warn'}`;
    }

    _updateBootLED(ledId, state) {
        const led = document.getElementById(ledId);
        led.className = 'status-led';
        if (state === 'active') led.classList.add('active');
        else if (state === 'error') led.classList.add('error');
        else if (state === 'warning') led.classList.add('warning');
        else if (state === 'loading') led.classList.add('loading');
    }

    _updateStatus(message) {
        document.getElementById('status-message').textContent = message;
    }

    _startCalibration() {
        if (!this.trackedObjects.length) { alert('No objects detected for calibration'); return; }
        const distance = prompt('Enter known distance to object (meters):');
        if (distance && !isNaN(distance)) {
            const knownDistance = parseFloat(distance);
            const track = this.trackedObjects[0];
            this.physics.calibrateDepth(knownDistance, track);
            alert('Depth calibration completed');
        }
    }

    shutdown() {
        this.isRunning = false;
        if (this.video.srcObject) {
            this.video.srcObject.getTracks().forEach(track => track.stop());
        }
        this.memory.saveToStorage();
    }
}

// ============================================================================
// SYSTEM INITIALIZATION
// ============================================================================

const OMEGA = new OmegaKernel();

document.getElementById('btn-init').addEventListener('click', () => {
    const btn = document.getElementById('btn-init');
    btn.textContent = 'INITIALIZING...';
    btn.disabled = true;
    OMEGA.boot();
});

// Handle visibility changes for performance (restore on return)
let prevPreset = 'BALANCED';
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        prevPreset = OMEGA.vision.qualityPreset || prevPreset;
        OMEGA._setQuality('LOW');
    } else {
        OMEGA._setQuality(prevPreset || 'BALANCED');
    }
});

window.addEventListener('beforeunload', () => OMEGA.shutdown());

// Performance monitor (now actually used)
const performanceMonitor = {
    frames: 0,
    lastTime: performance.now(),
    update() {
        this.frames++;
        const now = performance.now();
        if (now >= this.lastTime + 1000) {
            const fps = (this.frames * 1000) / (now - this.lastTime);
            this.frames = 0;
            this.lastTime = now;

            if (fps < 20 && OMEGA.vision.qualityPreset !== 'LOW') {
                OMEGA._setQuality('LOW');
            }
        }
    }
};

console.log("OMEGA: Advanced Humanoid Vision System - Fixed Build Loaded");
</script>
</body>
</html>
