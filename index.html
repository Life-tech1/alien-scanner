<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Field Console MVP</title>
    <style>
        /* Minimal Sci-Fi Design System */
        :root {
            --primary: #00ff88;
            --secondary: #0088ff;
            --background: rgba(0, 10, 20, 0.8);
            --surface: rgba(255, 255, 255, 0.1);
            --text: #ffffff;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: var(--text);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #camera-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        
        /* Overlay System */
        .overlay-minimal {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 3;
            pointer-events: none;
        }
        
        .corner-hint {
            background: var(--background);
            border: 1px solid var(--primary);
            border-radius: 12px;
            padding: 6px 12px;
            margin: 4px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            display: inline-block;
        }
        
        /* Core Controls */
        .core-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 20px;
            pointer-events: auto;
        }
        
        .core-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid var(--primary);
            background: var(--background);
            color: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
        }
        
        .core-btn.active {
            background: var(--primary);
            color: #000;
        }
        
        /* Companion UI */
        .companion-aura {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            z-index: 4;
            transition: all 0.5s ease;
        }
        
        .companion-aura.calm { background: rgba(0, 255, 136, 0.3); }
        .companion-aura.curious { background: rgba(255, 204, 0, 0.3); }
        .companion-aura.alert { background: rgba(255, 50, 50, 0.3); }
        
        /* Mission Drawer */
        .mission-drawer {
            position: absolute;
            top: 0;
            right: -300px;
            width: 280px;
            height: 100%;
            background: var(--background);
            backdrop-filter: blur(20px);
            border-left: 1px solid var(--surface);
            transition: transform 0.3s ease;
            z-index: 5;
            padding: 20px;
            pointer-events: auto;
        }
        
        .mission-drawer.open {
            transform: translateX(-300px);
        }
        
        .mission-btn {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: var(--surface);
            border: 1px solid var(--secondary);
            border-radius: 8px;
            color: var(--text);
            cursor: pointer;
            text-align: left;
        }
        
        .mission-btn.active {
            border-color: var(--primary);
            background: rgba(0, 255, 136, 0.1);
        }
    </style>
</head>
<body>
    <!-- Camera Layer -->
    <div id="camera-container">
        <video id="video" playsinline></video>
        <canvas id="canvas"></canvas>
    </div>
    
    <!-- Overlay: Minimal Mode -->
    <div class="overlay-minimal">
        <div class="corner-hint" id="scene-summary">Ready</div>
        <div class="corner-hint" id="object-count">Objects: 0</div>
        <div class="corner-hint" id="fps-counter">FPS: 0</div>
    </div>
    
    <!-- Companion Aura -->
    <div class="companion-aura" id="companion-aura"></div>
    
    <!-- Core Controls -->
    <div class="core-controls">
        <div class="core-btn" id="activate-btn">‚ö°</div>
        <div class="core-btn" id="lock-btn">üîí</div>
        <div class="core-btn" id="mission-btn">üéØ</div>
    </div>
    
    <!-- Mission Drawer -->
    <div class="mission-drawer" id="mission-drawer">
        <h3>Mission Packs</h3>
        <button class="mission-btn" data-mode="film">üé¨ Film Mode</button>
        <button class="mission-btn" data-mode="safety">üõ°Ô∏è Safety Mode</button>
        <button class="mission-btn" data-mode="travel">üß≠ Travel Mode</button>
    </div>

    <script>
        // Field Console MVP - Core Engine
        class FieldConsole {
            constructor() {
                this.isActive = false;
                this.currentMode = 'film';
                this.lockedTarget = null;
                this.companionMood = 'calm';
                this.performanceMode = 'balanced';
                this.timeline = [];
                this.objectTracker = new Map();
                
                this.init();
            }
            
            async init() {
                await this.setupCamera();
                this.setupVisionEngine();
                this.setupUI();
                this.setupCompanion();
                this.startMainLoop();
            }
            
            async setupCamera() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', frameRate: { ideal: 25 } }
                });
                this.video.srcObject = stream;
                
                // Set canvas size to match video
                this.video.onloadedmetadata = () => {
                    this.canvas.width = this.video.videoWidth;
                    this.canvas.height = this.video.videoHeight;
                };
            }
            
            setupVisionEngine() {
                // MediaPipe initialization would go here
                // For MVP, using simplified object tracking
                this.detectionConfig = {
                    maxObjects: 10,
                    confidence: 0.6,
                    tracking: true
                };
                
                // Mock detection for prototype
                this.mockDetector = {
                    detect: async (video) => {
                        // In real implementation, this would use MediaPipe/TensorFlow.js
                        return this.generateMockDetections();
                    }
                };
            }
            
            generateMockDetections() {
                // Simulate real detection data
                const objects = [];
                const types = ['person', 'vehicle', 'text', 'object'];
                
                for (let i = 0; i < 3; i++) {
                    objects.push({
                        id: `obj_${Date.now()}_${i}`,
                        type: types[Math.floor(Math.random() * types.length)],
                        confidence: 0.7 + Math.random() * 0.3,
                        bbox: [
                            Math.random() * 0.6,
                            Math.random() * 0.6,
                            0.2 + Math.random() * 0.3,
                            0.2 + Math.random() * 0.3
                        ],
                        trackId: i
                    });
                }
                
                return objects;
            }
            
            setupUI() {
                // Core buttons
                document.getElementById('activate-btn').onclick = () => this.toggleActivation();
                document.getElementById('lock-btn').onclick = () => this.toggleLock();
                document.getElementById('mission-btn').onclick = () => this.toggleMissionDrawer();
                
                // Mission buttons
                document.querySelectorAll('.mission-btn').forEach(btn => {
                    btn.onclick = (e) => this.switchMission(e.target.dataset.mode);
                });
            }
            
            setupCompanion() {
                this.companionAura = document.getElementById('companion-aura');
                this.updateCompanionMood('calm');
            }
            
            toggleActivation() {
                this.isActive = !this.isActive;
                const btn = document.getElementById('activate-btn');
                btn.classList.toggle('active', this.isActive);
                
                if (this.isActive) {
                    this.companionSpeak("Systems online. Tracking activated.");
                    this.updateCompanionMood('curious');
                } else {
                    this.companionSpeak("Standing by.");
                    this.updateCompanionMood('calm');
                }
            }
            
            toggleLock() {
                if (!this.isActive) return;
                
                // Simple target locking logic
                if (!this.lockedTarget && this.currentDetections?.length > 0) {
                    this.lockedTarget = this.currentDetections[0];
                    this.companionSpeak(`Target locked. Tracking ${this.lockedTarget.type}`);
                } else {
                    this.lockedTarget = null;
                    this.companionSpeak("Target released");
                }
            }
            
            toggleMissionDrawer() {
                document.getElementById('mission-drawer').classList.toggle('open');
            }
            
            switchMission(mode) {
                this.currentMode = mode;
                
                // Update UI
                document.querySelectorAll('.mission-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === mode);
                });
                
                // Mission-specific behaviors
                const missionConfigs = {
                    film: { mood: 'curious', message: "Film mode active. Ready for creative work." },
                    safety: { mood: 'alert', message: "Safety mode engaged. Monitoring environment." },
                    travel: { mood: 'calm', message: "Travel mode activated. Ready to explore." }
                };
                
                const config = missionConfigs[mode];
                this.updateCompanionMood(config.mood);
                this.companionSpeak(config.message);
                
                this.toggleMissionDrawer(); // Close drawer
            }
            
            updateCompanionMood(mood) {
                this.companionMood = mood;
                this.companionAura.className = `companion-aura ${mood}`;
            }
            
            companionSpeak(message) {
                // Use Web Speech API
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(message);
                    utterance.rate = 0.9;
                    utterance.pitch = 1.2;
                    speechSynthesis.speak(utterance);
                }
                
                // Add to timeline
                this.addToTimeline('companion', message);
            }
            
            addToTimeline(type, data) {
                this.timeline.push({
                    timestamp: Date.now(),
                    type: type,
                    data: data,
                    mode: this.currentMode,
                    mood: this.companionMood
                });
                
                // Keep timeline manageable
                if (this.timeline.length > 1000) {
                    this.timeline = this.timeline.slice(-500);
                }
            }
            
            async processFrame() {
                if (!this.isActive) return;
                
                const startTime = performance.now();
                
                // Run detection
                this.currentDetections = await this.mockDetector.detect(this.video);
                
                // Update object tracking
                this.updateObjectTracking(this.currentDetections);
                
                // Process based on current mission
                this.processMissionLogic();
                
                // Update scene understanding
                this.updateSceneSummary();
                
                // Draw overlay
                this.drawOverlay();
                
                // Update FPS counter
                this.updatePerformanceStats(startTime);
            }
            
            updateObjectTracking(detections) {
                const currentFrame = Date.now();
                
                detections.forEach(det => {
                    if (this.objectTracker.has(det.trackId)) {
                        const existing = this.objectTracker.get(det.trackId);
                        existing.lastSeen = currentFrame;
                        existing.bbox = det.bbox;
                        existing.trajectory.push({
                            x: det.bbox[0] + det.bbox[2]/2,
                            y: det.bbox[1] + det.bbox[3]/2,
                            timestamp: currentFrame
                        });
                    } else {
                        this.objectTracker.set(det.trackId, {
                            id: det.trackId,
                            type: det.type,
                            firstSeen: currentFrame,
                            lastSeen: currentFrame,
                            bbox: det.bbox,
                            trajectory: [{
                                x: det.bbox[0] + det.bbox[2]/2,
                                y: det.bbox[1] + det.bbox[3]/2,
                                timestamp: currentFrame
                            }]
                        });
                    }
                });
                
                // Clean up old tracks
                const cleanupThreshold = 2000; // 2 seconds
                for (let [id, track] of this.objectTracker.entries()) {
                    if (currentFrame - track.lastSeen > cleanupThreshold) {
                        this.objectTracker.delete(id);
                    }
                }
            }
            
            processMissionLogic() {
                switch (this.currentMode) {
                    case 'safety':
                        this.processSafetyMode();
                        break;
                    case 'film':
                        this.processFilmMode();
                        break;
                    case 'travel':
                        this.processTravelMode();
                        break;
                }
            }
            
            processSafetyMode() {
                const people = Array.from(this.objectTracker.values())
                    .filter(obj => obj.type === 'person');
                
                if (people.length > 3) {
                    this.updateCompanionMood('alert');
                    if (this.companionMood !== 'alert') {
                        this.companionSpeak("Multiple people detected in area");
                    }
                }
            }
            
            processFilmMode() {
                // Film mode logic - composition helpers, etc.
                const objects = Array.from(this.objectTracker.values());
                if (objects.length >= 2) {
                    // Check for interesting compositions
                    this.updateCompanionMood('curious');
                }
            }
            
            processTravelMode() {
                // Travel mode logic - text detection, translation prep
                const texts = Array.from(this.objectTracker.values())
                    .filter(obj => obj.type === 'text');
                
                if (texts.length > 0 && this.companionMood === 'calm') {
                    this.updateCompanionMood('curious');
                    this.companionSpeak("Text detected. Ready for translation.");
                }
            }
            
            updateSceneSummary() {
                const objects = Array.from(this.objectTracker.values());
                const summaryEl = document.getElementById('scene-summary');
                const countEl = document.getElementById('object-count');
                
                countEl.textContent = `Objects: ${objects.length}`;
                
                if (objects.length === 0) {
                    summaryEl.textContent = "Clear scene";
                } else {
                    const types = [...new Set(objects.map(obj => obj.type))];
                    summaryEl.textContent = `Tracking: ${types.join(', ')}`;
                }
            }
            
            drawOverlay() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (!this.isActive || !this.currentDetections) return;
                
                this.ctx.strokeStyle = '#00ff88';
                this.ctx.lineWidth = 2;
                this.ctx.font = '12px monospace';
                this.ctx.fillStyle = '#00ff88';
                
                this.currentDetections.forEach(det => {
                    const [x, y, width, height] = det.bbox;
                    const absX = x * this.canvas.width;
                    const absY = y * this.canvas.height;
                    const absWidth = width * this.canvas.width;
                    const absHeight = height * this.canvas.height;
                    
                    // Draw bounding box
                    this.ctx.strokeRect(absX, absY, absWidth, absHeight);
                    
                    // Draw label
                    this.ctx.fillText(
                        `${det.type} ${Math.round(det.confidence * 100)}%`,
                        absX, absY - 5
                    );
                    
                    // Draw trajectory if available
                    const track = this.objectTracker.get(det.trackId);
                    if (track && track.trajectory.length > 1) {
                        this.ctx.beginPath();
                        this.ctx.strokeStyle = '#0088ff';
                        track.trajectory.forEach((point, index) => {
                            const pointX = point.x * this.canvas.width;
                            const pointY = point.y * this.canvas.height;
                            
                            if (index === 0) {
                                this.ctx.moveTo(pointX, pointY);
                            } else {
                                this.ctx.lineTo(pointX, pointY);
                            }
                        });
                        this.ctx.stroke();
                    }
                });
                
                // Draw locked target highlight
                if (this.lockedTarget) {
                    const [x, y, width, height] = this.lockedTarget.bbox;
                    this.ctx.strokeStyle = '#ff4444';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(
                        x * this.canvas.width,
                        y * this.canvas.height,
                        width * this.canvas.width,
                        height * this.canvas.height
                    );
                }
            }
            
            updatePerformanceStats(startTime) {
                const frameTime = performance.now() - startTime;
                const fps = Math.round(1000 / frameTime);
                
                document.getElementById('fps-counter').textContent = `FPS: ${fps}`;
                
                // Adaptive performance adjustment
                if (fps < 15 && this.performanceMode !== 'performance') {
                    this.performanceMode = 'performance';
                    this.companionSpeak("Switching to performance mode");
                } else if (fps > 25 && this.performanceMode !== 'quality') {
                    this.performanceMode = 'quality';
                }
            }
            
            startMainLoop() {
                const loop = () => {
                    this.processFrame();
                    requestAnimationFrame(loop);
                };
                loop();
            }
        }
        
        // Initialize the console when page loads
        window.addEventListener('load', () => {
            new FieldConsole();
        });
    </script>
</body>
</html>
