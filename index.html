<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OMEGA: ADVANCED HUMANOID VISION SYSTEM</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        :root {
            --hud-primary: #00ff41;
            --hud-secondary: #008f11;
            --hud-alert: #ff0000;
            --hud-warn: #ffcc00;
            --hud-info: #0080ff;
            --hud-critical: #ff0066;
            --bg-dark: #050505;
            --glass: rgba(0, 20, 0, 0.85);
            --glass-dark: rgba(0, 10, 0, 0.95);
            --neon-glow: 0 0 10px currentColor;
        }

        * { 
            box-sizing: border-box; 
            user-select: none; 
            -webkit-touch-callout: none; 
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0; 
            overflow: hidden; 
            background: var(--bg-dark);
            font-family: 'Courier New', 'Consolas', monospace;
            color: var(--hud-primary);
            width: 100vw; 
            height: 100vh;
            line-height: 1.2;
        }

        #viewport { 
            position: relative; 
            width: 100%; 
            height: 100%; 
        }
        
        #camera-feed {
            position: absolute; 
            width: 100%; 
            height: 100%; 
            object-fit: cover;
            z-index: 0; 
            filter: contrast(1.4) brightness(0.7) hue-rotate(90deg) saturate(1.3);
            opacity: 0.5;
        }
        
        #hud-canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 10; 
        }

        #ui-layer {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            z-index: 20; 
            pointer-events: none;
            display: flex; 
            flex-direction: column; 
            justify-content: space-between;
            padding: max(12px, env(safe-area-inset-top));
        }

        /* Panel anchors (for auto-avoid) */
        #panel-metrics {
            position: absolute;
            top: max(12px, env(safe-area-inset-top));
            left: 12px;
        }
        #panel-avionics {
            position: absolute;
            top: max(12px, env(safe-area-inset-top));
            right: 12px;
        }
        #panel-analytics {
            position: absolute;
            left: 12px;
            bottom: 160px;
        }
        #panel-target {
            position: absolute;
            right: 160px;
            top: 110px;
        }

        .hud-panel {
            background: var(--glass); 
            border: 1px solid var(--hud-primary);
            border-left: 3px solid var(--hud-primary);
            padding: 8px 12px; 
            margin: 6px; 
            width: fit-content;
            backdrop-filter: blur(4px);
            box-shadow: var(--neon-glow);
            clip-path: polygon(0 0, calc(100% - 6px) 0, 100% 6px, 100% 100%, 6px 100%, 0 calc(100% - 6px));
            font-size: 11px;
        }
        
        .hud-panel-wide {
            width: auto;
            min-width: 240px;
            max-width: 280px;
        }
        
        .panel-title {
            font-size: 10px;
            font-weight: bold;
            color: var(--hud-secondary);
            margin-bottom: 6px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        .hud-text { 
            font-size: 10px; 
            letter-spacing: 0.5px; 
            margin-bottom: 3px; 
            text-shadow: var(--neon-glow);
            display: flex;
            justify-content: space-between;
        }
        
        .hud-value { 
            font-weight: bold; 
            color: #fff;
            margin-left: 8px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 6px;
        }

        #radar-container {
            position: absolute; 
            bottom: 15px; 
            right: 15px;
            width: 140px; 
            height: 140px;
            border-radius: 50%;
            background: var(--glass-dark);
            border: 2px solid var(--hud-primary);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
            overflow: hidden;
            z-index: 30;
        }
        
        #radar-container::after {
            content: ''; 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: conic-gradient(from 0deg, transparent 0deg, transparent 270deg, rgba(0,255,65,0.4) 360deg);
            border-radius: 50%;
            animation: radar-scan 3s linear infinite;
        }
        
        .radar-grid {
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            border: 1px solid rgba(0,255,65,0.3); 
            border-radius: 50%; 
            pointer-events: none;
        }
        
        .radar-cross {
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            width: 100%; 
            height: 1px; 
            background: rgba(0,255,65,0.3);
        }
        
        .radar-blip {
            position: absolute; 
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: var(--neon-glow);
            transition: all 0.2s ease-out;
            z-index: 2;
        }
        
        .radar-range {
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: var(--hud-secondary);
        }
        
        @keyframes radar-scan { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }

        #boot-overlay {
            position: fixed; 
            inset: 0; 
            background: #000; 
            z-index: 9999;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            color: var(--hud-primary);
            background: radial-gradient(circle at center, #001100 0%, #000000 70%);
        }
        
        .boot-title {
            font-size: 42px;
            font-weight: 900;
            margin-bottom: 8px;
            letter-spacing: 6px;
            text-shadow: 0 0 20px var(--hud-primary);
            background: linear-gradient(90deg, var(--hud-primary), var(--hud-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .boot-subtitle {
            opacity: 0.7; 
            margin-bottom: 30px;
            font-size: 13px;
            letter-spacing: 2px;
        }
        
        #btn-init {
            background: transparent; 
            color: var(--hud-primary); 
            border: 2px solid var(--hud-primary);
            padding: 14px 50px; 
            font-family: inherit; 
            font-size: 15px; 
            font-weight: bold;
            letter-spacing: 3px; 
            cursor: pointer; 
            margin-top: 30px;
            transition: all 0.3s ease;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
            pointer-events: auto;
        }
        
        #btn-init::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,65,0.4), transparent);
            transition: left 0.5s;
        }
        
        #btn-init:hover::before {
            left: 100%;
        }
        
        #btn-init:hover { 
            background: var(--hud-primary); 
            color: #000; 
            box-shadow: 0 0 25px var(--hud-primary);
        }
        
        .status-list {
            text-align: left; 
            font-size: 11px; 
            line-height: 1.6; 
            opacity: 0.9;
            margin-top: 25px;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .status-led { 
            display: inline-block; 
            width: 8px; 
            height: 8px; 
            background: #333; 
            border-radius: 50%; 
            margin-right: 10px; 
            position: relative;
        }
        
        .status-led::after {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 50%;
            box-shadow: 0 0 6px currentColor;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .status-led.active { 
            background: var(--hud-primary);
        }
        
        .status-led.active::after {
            opacity: 1;
        }
        
        .status-led.error { 
            background: var(--hud-alert);
        }
        
        .status-led.error::after {
            opacity: 1;
        }
        
        .status-led.warning { 
            background: var(--hud-warn);
        }
        
        .status-led.warning::after {
            opacity: 1;
        }
        
        .status-led.loading {
            background: var(--hud-info);
            animation: pulse 1.5s infinite;
        }

        #system-status {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: var(--glass-dark);
            border-top: 1px solid var(--hud-secondary);
            padding: 6px 12px;
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            z-index: 25;
            backdrop-filter: blur(4px);
        }
        
        .status-section {
            display: flex;
            align-items: center;
        }
        
        .status-item-compact {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        
        .status-indicator {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            margin-right: 5px;
            position: relative;
        }
        
        .status-indicator::after {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 50%;
            box-shadow: 0 0 4px currentColor;
        }
        
        .status-ok { 
            background: var(--hud-primary); 
        }
        
        .status-warn { 
            background: var(--hud-warn); 
        }
        
        .status-error { 
            background: var(--hud-alert); 
        }
        
        .status-offline { 
            background: #444; 
        }

        /* Control Panel */
        #control-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: var(--glass-dark);
            border: 1px solid var(--hud-primary);
            padding: 8px;
            border-radius: 4px;
            z-index: 40;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            display: none;
        }

        .control-btn {
            background: transparent;
            border: 1px solid var(--hud-secondary);
            color: var(--hud-primary);
            padding: 4px 8px;
            margin: 2px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 2px;
        }

        .control-btn:hover {
            background: var(--hud-secondary);
        }

        .control-btn.active {
            background: var(--hud-primary);
            color: black;
        }

        #toggle-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 35;
            pointer-events: auto;
            background: var(--glass);
            border: 1px solid var(--hud-primary);
            color: var(--hud-primary);
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 2px;
        }

        /* Permission Overlay */
        #permission-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9998;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--hud-primary);
            text-align: center;
            padding: 20px;
        }

        .permission-content {
            background: var(--glass-dark);
            border: 2px solid var(--hud-primary);
            padding: 20px;
            border-radius: 8px;
            max-width: 400px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes targetLock {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.7; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .critical-alert {
            animation: alertPulse 0.5s infinite;
        }

        @keyframes alertPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .hud-panel-wide {
                min-width: 220px;
                max-width: 250px;
            }
            
            #radar-container {
                width: 120px;
                height: 120px;
                bottom: 10px;
                right: 10px;
            }
            
            .boot-title {
                font-size: 32px;
                letter-spacing: 4px;
            }

            .hud-panel {
                padding: 6px 10px;
                margin: 4px;
            }
        }

        @media (max-width: 480px) {
            .hud-panel {
                padding: 4px 8px;
            }
            
            .status-grid {
                grid-template-columns: 1fr;
            }
            
            #system-status {
                flex-direction: column;
                gap: 2px;
                font-size: 8px;
            }

            #radar-container {
                width: 100px;
                height: 100px;
            }
        }
    </style>
</head>
<body>

    <div id="viewport">
        <video id="camera-feed" autoplay playsinline muted></video>
        <canvas id="hud-canvas"></canvas>
        
        <div id="ui-layer">
            <!-- Top Row: System Status -->
            <div style="display:flex; justify-content:space-between; width:100%;">
                <div class="hud-panel" id="panel-metrics">
                    <div class="panel-title">SYSTEM METRICS</div>
                    <div class="hud-text">AI CPU: <span id="val-cpu" class="hud-value">0</span> ms</div>
                    <div class="hud-text">AI FPS: <span id="val-ai-fps" class="hud-value">0</span></div>
                    <div class="hud-text">RENDER FPS: <span id="val-render-fps" class="hud-value">0</span></div>
                    <div class="hud-text">TRACKED: <span id="val-tracked" class="hud-value">0</span></div>
                </div>
                
                <div class="hud-panel" id="panel-avionics">
                    <div class="panel-title">AVIONICS</div>
                    <div class="hud-text">PITCH: <span id="val-pitch" class="hud-value">0.0°</span></div>
                    <div class="hud-text">ROLL: <span id="val-roll" class="hud-value">0.0°</span></div>
                    <div class="hud-text">HEADING: <span id="val-heading" class="hud-value">0.0°</span></div>
                    <div class="hud-text">G-FORCE: <span id="val-g" class="hud-value">1.00</span></div>
                </div>
            </div>
            
            <!-- Middle: Analytics -->
            <div class="hud-panel hud-panel-wide" id="panel-analytics" style="margin-top: auto; margin-bottom: 160px;">
                <div class="panel-title">TACTICAL ANALYTICS</div>
                <div class="hud-text">ACTIVE OBJECTS: <span id="val-active" class="hud-value">0</span></div>
                <div class="hud-text">PERSONS (5M): <span id="val-persons" class="hud-value">0</span></div>
                <div class="hud-text">CLOSEST PERSON: <span id="val-closest-person" class="hud-value">--</span></div>
                <div class="hud-text">DOMINANT CLASS: <span id="val-top-label" class="hud-value">--</span></div>
            </div>
            
            <!-- Target Acquisition -->
            <div class="hud-panel hud-panel-wide" id="panel-target" style="margin-left: auto; margin-right: 160px;">
                <div class="panel-title">PRIMARY TARGET</div>
                <div class="hud-text">CLASS: <span id="val-target-label" class="hud-value">--</span></div>
                <div class="hud-text">DISTANCE: <span id="val-target-dist" class="hud-value">--</span></div>
                <div class="hud-text">BEARING: <span id="val-target-bearing" class="hud-value">--</span></div>
                <div class="hud-text">MOTION: <span id="val-target-state" class="hud-value">--</span></div>
                <div class="hud-text">CONFIDENCE: <span id="val-target-conf" class="hud-value">--</span></div>
            </div>

            <!-- Radar -->
            <div id="radar-container">
                <div class="radar-grid" style="width: 33%; height: 33%;"></div>
                <div class="radar-grid" style="width: 66%; height: 66%;"></div>
                <div class="radar-cross"></div>
                <div class="radar-cross" style="transform: translate(-50%, -50%) rotate(90deg);"></div>
                <div id="radar-blips"></div>
                <div class="radar-range">RANGE: 50M</div>
            </div>
        </div>
        
        <!-- System Status Bar -->
        <div id="system-status">
            <div class="status-section">
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-cam"></span>
                    <span>OPTICAL</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-ai"></span>
                    <span>AI</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-gyro"></span>
                    <span>GYRO</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-tracker"></span>
                    <span>TRACKER</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-memory"></span>
                    <span>MEMORY</span>
                </div>
            </div>
            <div class="status-section">
                <span id="status-message">SYSTEM_STANDBY</span>
            </div>
        </div>

        <!-- Control Panel Toggle -->
        <button id="toggle-controls">CONTROLS</button>

        <!-- Control Panel -->
        <div id="control-panel">
            <div class="panel-title">CONTROL PANEL</div>
            <div>
                <button class="control-btn" id="btn-quality-low">LOW</button>
                <button class="control-btn active" id="btn-quality-balanced">BALANCED</button>
                <button class="control-btn" id="btn-quality-high">HIGH</button>
            </div>
            <div style="margin-top: 8px;">
                <button class="control-btn" id="btn-calibrate">CALIBRATE DEPTH</button>
                <button class="control-btn" id="btn-export">EXPORT DATA</button>
                <button class="control-btn" id="btn-clear">CLEAR MEMORY</button>
            </div>
            <div style="margin-top: 8px;">
                <button class="control-btn active" id="btn-hud-on">HUD ON</button>
                <button class="control-btn" id="btn-hud-off">HUD OFF</button>
            </div>
        </div>
    </div>

    <!-- Boot Screen -->
    <div id="boot-overlay">
        <div class="boot-title">OMEGA</div>
        <div class="boot-subtitle">ADVANCED HUMANOID VISION SYSTEM</div>
        
        <div class="status-list">
            <div class="status-item">
                <span class="status-led" id="led-cam"></span>
                <span>OPTICAL SENSOR ARRAY</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-ai"></span>
                <span>NEURAL NETWORK (COCO-SSD)</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-gyro"></span>
                <span>INERTIAL NAVIGATION</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-tracker"></span>
                <span>MULTI-OBJECT TRACKER</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-memory"></span>
                <span>KNOWLEDGE BASE</span>
            </div>
        </div>
        
        <button id="btn-init">INITIALIZE SYSTEM</button>
    </div>

    <!-- Permission Overlay -->
    <div id="permission-overlay">
        <div class="permission-content">
            <div style="font-size: 18px; margin-bottom: 15px;">PERMISSION REQUIRED</div>
            <div style="margin-bottom: 20px; font-size: 14px;">
                Camera access is required for the vision system to function. Please allow camera permissions when prompted.
            </div>
            <button id="btn-retry-permission" style="
                background: transparent;
                border: 2px solid var(--hud-primary);
                color: var(--hud-primary);
                padding: 10px 20px;
                font-family: inherit;
                cursor: pointer;
            ">RETRY PERMISSION</button>
        </div>
    </div>

<script>
/**
 * OMEGA: ADVANCED HUMANOID VISION SYSTEM
 * Optimized Version with Critical Fixes
 */

// ============================================================================
// CONFIGURATION - OPTIMIZED
// ============================================================================

const CONFIG = {
    AI: {
        MODEL_TYPE: 'lite_mobilenet_v2',
        CONFIDENCE_THRESHOLD: 0.65,
        MAX_DETECTIONS: 20,
        INFERENCE_RATE: 12,
        QUALITY_PRESETS: {
            LOW: { rate: 8, blur: 0 },
            BALANCED: { rate: 12, blur: 4 },
            HIGH: { rate: 15, blur: 8 }
        }
    },
    
    TRACKING: {
        MAX_AGE: 30,
        MIN_IOU: 0.4,
        MAX_ASSOCIATION_DISTANCE: 0.3,
        VELOCITY_SMOOTHING: 0.85,
        MAX_TRACKS: 15
    },
    
    PHYSICS: {
        HORIZONTAL_FOV: 67.5,
        VERTICAL_FOV: 52.5,
        MAX_RANGE: 50,
        MIN_RANGE: 0.5,
        PERSON_HEIGHT: 1.75,
        VEHICLE_HEIGHT: 1.6,
        IS_CALIBRATED: false
    },
    
    RADAR: {
        RANGE: 50,
        MAX_BLIPS: 10
    },
    
    MEMORY: {
        MAX_EVENTS: 1000,
        STORAGE_KEY: 'omega_vision_data'
    },
    
    UI: {
        UPDATE_RATE: 30
    }
};

// ============================================================================
// CORE UTILITIES - OPTIMIZED
// ============================================================================

const Utils = {
    clamp: (num, min, max) => Math.min(Math.max(num, min), max),
    
    map: (value, x1, y1, x2, y2) => (value - x1) * (y2 - x2) / (y1 - x1) + x2,
    
    distance: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
    
    iou: (rect1, rect2) => {
        const x1 = Math.max(rect1.x, rect2.x);
        const y1 = Math.max(rect1.y, rect2.y);
        const x2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width);
        const y2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);
        
        const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
        const area1 = rect1.width * rect1.height;
        const area2 = rect2.width * rect2.height;
        const union = area1 + area2 - intersection;
        
        return union > 0 ? intersection / union : 0;
    },
    
    ema: (current, previous, factor) => {
        return previous * factor + current * (1 - factor);
    },
    
    generateId: () => 'id_' + Math.random().toString(36).substr(2, 9),
    
    formatNumber: (value, decimals = 1) => value.toFixed(decimals)
};

// ============================================================================
// AVIONICS - FIXED ROTATION RATE READING
// ============================================================================

class Avionics {
    constructor() {
        this.pitch = 0;
        this.roll = 0;
        this.heading = 0;
        this.gForce = 1.0;
        this.rotationRate = { alpha: 0, beta: 0, gamma: 0 };
        this.isAvailable = false;
    }

    async init() {
        try {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                const state = await DeviceOrientationEvent.requestPermission();
                if (state !== 'granted') throw new Error("GYRO PERMISSION DENIED");
            }
            
            // DeviceOrientation for orientation
            window.addEventListener('deviceorientation', e => {
                this.pitch = e.beta || 0;
                this.roll = e.gamma || 0;
                this.heading = e.alpha || 0;
            });
            
            // DeviceMotion for rotation rate and acceleration
            window.addEventListener('devicemotion', e => {
                const acc = e.accelerationIncludingGravity;
                if (acc) {
                    const {x, y, z} = acc;
                    this.gForce = Math.sqrt(x*x + y*y + z*z) / 9.81;
                }
                
                // Fix: Read rotationRate from devicemotion, not deviceorientation
                if (e.rotationRate) {
                    this.rotationRate = {
                        alpha: e.rotationRate.alpha || 0,
                        beta: e.rotationRate.beta || 0,
                        gamma: e.rotationRate.gamma || 0
                    };
                }
            });
            
            this.isAvailable = true;
            return true;
            
        } catch (error) {
            console.warn("Avionics skipped:", error);
            this.isAvailable = false;
            return false;
        }
    }

    getOrientation() {
        return {
            pitch: this.pitch,
            roll: this.roll,
            heading: this.heading
        };
    }

    getMotion() {
        return {
            gForce: this.gForce,
            rotationRate: { ...this.rotationRate }
        };
    }
}

// ============================================================================
// VISION ENGINE - ADAPTIVE INFERENCE RATE
// ============================================================================

class VisionEngine {
    constructor() {
        this.model = null;
        this.isModelLoaded = false;
        this.inferenceStats = {
            lastTime: 0,
            averageTime: 0,
            aiFps: 0,
            renderFps: 0
        };
        this.qualityPreset = 'BALANCED';
        this.lastRenderTime = 0;
    }

    async init() {
        try {
            await tf.ready();
            this.model = await cocoSsd.load({ 
                base: CONFIG.AI.MODEL_TYPE 
            });
            this.isModelLoaded = true;
            return true;
        } catch (error) {
            console.error("Vision engine failed:", error);
            return false;
        }
    }

    async detect(videoEl) {
        if (!this.model || !this.isModelLoaded) return [];
        
        const startTime = performance.now();
        
        try {
            const results = await this.model.detect(
                videoEl, 
                CONFIG.AI.MAX_DETECTIONS, 
                CONFIG.AI.CONFIDENCE_THRESHOLD
            );
            
            const processingTime = performance.now() - startTime;
            this._updateInferenceStats(processingTime);
            
            return results;
        } catch (error) {
            console.error("Detection error:", error);
            return [];
        }
    }

    _updateInferenceStats(processingTime) {
        this.inferenceStats.lastTime = processingTime;
        this.inferenceStats.averageTime = Utils.ema(
            processingTime,
            this.inferenceStats.averageTime,
            0.95
        );
        this.inferenceStats.aiFps = 1000 / Math.max(1, this.inferenceStats.averageTime);
    }

    updateRenderFPS() {
        const now = performance.now();
        if (this.lastRenderTime > 0) {
            const frameTime = now - this.lastRenderTime;
            this.inferenceStats.renderFps = 1000 / Math.max(1, frameTime);
        }
        this.lastRenderTime = now;
    }

    setQualityPreset(preset) {
        this.qualityPreset = preset;
    }

    getInferenceRate() {
        return CONFIG.AI.QUALITY_PRESETS[this.qualityPreset].rate;
    }

    getStatus() {
        return {
            isModelLoaded: this.isModelLoaded,
            ...this.inferenceStats
        };
    }
}

// ============================================================================
// OBJECT TRACKER - IMPROVED DATA ASSOCIATION
// ============================================================================

class ObjectTracker {
    constructor() {
        this.tracks = new Map();
        this.nextId = 1;
        this.frameCount = 0;
        this.inferenceRate = CONFIG.AI.INFERENCE_RATE;
    }

    update(detections, timestamp, inferenceRate = CONFIG.AI.INFERENCE_RATE) {
        this.frameCount++;
        this.inferenceRate = inferenceRate;

        const currentDetections = detections.map(det => ({
            bbox: {
                x: det.bbox[0],
                y: det.bbox[1],
                width: det.bbox[2],
                height: det.bbox[3]
            },
            label: det.class,
            confidence: det.score,
            timestamp
        }));

        this._updateTracks(currentDetections, timestamp);
        this._removeExpiredTracks(timestamp);

        if (this.tracks.size > CONFIG.TRACKING.MAX_TRACKS) this._pruneTracks();
        return Array.from(this.tracks.values());
    }

    _predictBbox(track, timestamp) {
        if (!track.velocity || track.status === 'new') return { ...track.bbox };
        const dt = (timestamp - track.lastUpdateTime) / 1000;
        if (dt <= 0) return { ...track.bbox };
        return {
            x: track.bbox.x + track.velocity.vx * dt,
            y: track.bbox.y + track.velocity.vy * dt,
            width: track.bbox.width,
            height: track.bbox.height
        };
    }

    _updateTracks(detections, timestamp) {
        const usedDetections = new Set();

        for (const [id, track] of this.tracks.entries()) {
            if (track.status === 'lost') continue;

            const predicted = this._predictBbox(track, timestamp);

            let bestMatch = null;
            let bestScore = -Infinity;

            for (let i = 0; i < detections.length; i++) {
                if (usedDetections.has(i)) continue;

                const detection = detections[i];

                // Predictive IoU + center distance
                const iouNow  = Utils.iou(track.bbox, detection.bbox);
                const iouPred = Utils.iou(predicted, detection.bbox);
                const iouScore = Math.max(iouNow, iouPred);

                const predCx = predicted.x + predicted.width / 2;
                const predCy = predicted.y + predicted.height / 2;
                const detCx  = detection.bbox.x + detection.bbox.width / 2;
                const detCy  = detection.bbox.y + detection.bbox.height / 2;

                const centerDist = Utils.distance(predCx, predCy, detCx, detCy) /
                    Math.sqrt(window.innerWidth * window.innerHeight);

                const labelScore = track.label === detection.label ? 1 : 0.35;
                const velocityScore = this._calculateVelocityScore(track, detection, timestamp);

                const totalScore =
                    iouScore * 0.45 +
                    (1 - centerDist) * 0.35 +
                    labelScore * 0.12 +
                    velocityScore * 0.08;

                const labelGate = (track.label === detection.label);
                const closeGate = centerDist < CONFIG.TRACKING.MAX_ASSOCIATION_DISTANCE;
                const accept =
                    (iouScore > CONFIG.TRACKING.MIN_IOU) ||
                    (labelGate && closeGate && totalScore > 0.45);

                if (accept && totalScore > bestScore) {
                    bestScore = totalScore;
                    bestMatch = { index: i, detection };
                }
            }

            if (bestMatch) {
                this._updateTrack(track, bestMatch.detection, timestamp);
                usedDetections.add(bestMatch.index);
            } else {
                track.status = 'lost';
                track.lastSeen = timestamp;
            }
        }

        for (let i = 0; i < detections.length; i++) {
            if (!usedDetections.has(i)) this._createTrack(detections[i], timestamp);
        }
    }

    _calculateVelocityScore(track, detection, timestamp) {
        if (!track.lastPosition || track.status === 'new') return 0.5;
        const dt = (timestamp - track.lastUpdateTime) / 1000;
        if (dt <= 0) return 0.5;

        const predX = track.bbox.x + (track.velocity?.vx || 0) * dt;
        const predY = track.bbox.y + (track.velocity?.vy || 0) * dt;
        const dist = Utils.distance(predX, predY, detection.bbox.x, detection.bbox.y);
        const maxDist = Math.sqrt(window.innerWidth * window.innerHeight) * 0.12;
        return Math.max(0, 1 - (dist / maxDist));
    }

    _updateTrack(track, detection, timestamp) {
        const dt = (timestamp - track.lastUpdateTime) / 1000;

        track.rawBbox = { ...detection.bbox };
        track.bbox.x = Utils.ema(detection.bbox.x, track.bbox.x, 0.7);
        track.bbox.y = Utils.ema(detection.bbox.y, track.bbox.y, 0.7);
        track.bbox.width = Utils.ema(detection.bbox.width, track.bbox.width, 0.7);
        track.bbox.height = Utils.ema(detection.bbox.height, track.bbox.height, 0.7);

        if (track.lastPosition && dt > 0) {
            const dx = (track.bbox.x - track.lastPosition.x) / dt;
            const dy = (track.bbox.y - track.lastPosition.y) / dt;
            track.velocity = {
                vx: Utils.ema(dx, track.velocity?.vx || 0, CONFIG.TRACKING.VELOCITY_SMOOTHING),
                vy: Utils.ema(dy, track.velocity?.vy || 0, CONFIG.TRACKING.VELOCITY_SMOOTHING)
            };
        }

        track.lastPosition = { x: track.bbox.x, y: track.bbox.y };
        track.lastUpdateTime = timestamp;
        track.status = track.status === 'new' ? 'active' : track.status;
        track.label = detection.label;
        track.confidence = detection.confidence;
    }

    _createTrack(detection, timestamp) {
        const id = this.nextId++;
        this.tracks.set(id, {
            id,
            label: detection.label,
            confidence: detection.confidence,
            bbox: { ...detection.bbox },
            rawBbox: { ...detection.bbox },
            firstSeen: timestamp,
            lastSeen: timestamp,
            lastUpdateTime: timestamp,
            status: 'new',
            velocity: { vx: 0, vy: 0 },
            lastPosition: { x: detection.bbox.x, y: detection.bbox.y }
        });
    }

    _removeExpiredTracks(timestamp) {
        const tracksArray = Array.from(this.tracks.entries());
        const frameTTLms = CONFIG.TRACKING.MAX_AGE * (1000 / Math.max(1, this.inferenceRate));

        for (const [id, track] of tracksArray) {
            if (track.status === 'lost' && timestamp - track.lastSeen > frameTTLms) {
                this.tracks.delete(id);
            }
        }
    }

    _pruneTracks() {
        const arr = Array.from(this.tracks.entries());
        arr.sort((a, b) => b[1].confidence - a[1].confidence);
        while (this.tracks.size > CONFIG.TRACKING.MAX_TRACKS) {
            const [id] = arr.pop();
            this.tracks.delete(id);
        }
    }

    getActiveTracks() {
        return Array.from(this.tracks.values()).filter(t => t.status !== 'lost');
    }

    getStats() {
        const active = this.getActiveTracks();
        return {
            totalTracks: this.tracks.size,
            activeTracks: active.length,
            newTracks: active.filter(t => t.status === 'new').length
        };
    }
}


// ============================================================================
// PHYSICS ENGINE - CORRECTED COORDINATE MAPPING
// ============================================================================

class PhysicsEngine {
    constructor() {
        this.videoWidth = 1280;
        this.videoHeight = 720;
        this.scaleX = 1;
        this.scaleY = 1;
        this.offsetX = 0;
        this.offsetY = 0;
    }

    updateVideoDimensions(video) {
        if (video.videoWidth && video.videoHeight) {
            this.videoWidth = video.videoWidth;
            this.videoHeight = video.videoHeight;

            this.offsetX = 0; 
            this.offsetY = 0;

            const videoAspect = this.videoWidth / this.videoHeight;
            const screenAspect = window.innerWidth / window.innerHeight;

            if (videoAspect > screenAspect) {
                this.scaleX = window.innerWidth / this.videoWidth;
                this.scaleY = this.scaleX;
                this.offsetY = (window.innerHeight - this.videoHeight * this.scaleY) / 2;
            } else {
                this.scaleY = window.innerHeight / this.videoHeight;
                this.scaleX = this.scaleY;
                this.offsetX = (window.innerWidth - this.videoWidth * this.scaleX) / 2;
            }
        }
    }

    analyze(tracks) {
        return tracks.map(track => {
            const enhanced = { ...track };

            const screenBbox = this._videoToScreenBbox(track.bbox);
            enhanced.screenBbox = screenBbox;

            const centerX = screenBbox.x + screenBbox.width / 2;
            const centerY = screenBbox.y + screenBbox.height / 2;

            enhanced.screenPosition = {
                xNorm: (centerX / window.innerWidth) * 2 - 1,
                yNorm: (centerY / window.innerHeight) * 2 - 1
            };

            enhanced.bearingDeg = this._computeBearing(enhanced.screenPosition.xNorm);

            const depthMeters = this._computeDepthMeters(track);
            const depthNorm   = Utils.clamp(1 - (depthMeters / CONFIG.PHYSICS.MAX_RANGE), 0, 1);

            enhanced.depthMeters   = depthMeters;
            enhanced.depthNorm     = depthNorm;
            enhanced.depthEstimate = depthMeters;

            enhanced.motionAnalysis = this._analyzeMotion(track);

            return enhanced;
        });
    }

    predictVideoBbox(track, horizonSec = 0.75) {
        if (!track.velocity) return { ...track.bbox };
        return {
            x: track.bbox.x + (track.velocity.vx || 0) * horizonSec,
            y: track.bbox.y + (track.velocity.vy || 0) * horizonSec,
            width: track.bbox.width,
            height: track.bbox.height
        };
    }

    predictScreenBbox(track, horizonSec = 0.75) {
        const predVideo = this.predictVideoBbox(track, horizonSec);
        return this._videoToScreenBbox(predVideo);
    }

    _videoToScreenBbox(videoBbox) {
        return {
            x: videoBbox.x * this.scaleX + this.offsetX,
            y: videoBbox.y * this.scaleY + this.offsetY,
            width: videoBbox.width * this.scaleX,
            height: videoBbox.height * this.scaleY
        };
    }

    _computeBearing(xNorm) {
        return (xNorm || 0) * (CONFIG.PHYSICS.HORIZONTAL_FOV / 2);
    }

    _computeDepthMeters(track) {
        const bboxHeightPx = track.bbox.height;
        const bboxHeightNorm = bboxHeightPx / this.videoHeight;

        let physicalHeight;
        switch (track.label) {
            case 'person': physicalHeight = CONFIG.PHYSICS.PERSON_HEIGHT; break;
            case 'car':
            case 'truck':
            case 'bus': physicalHeight = CONFIG.PHYSICS.VEHICLE_HEIGHT; break;
            default: physicalHeight = 1.0;
        }

        const focalLengthPx = (this.videoHeight / 2) /
            Math.tan(CONFIG.PHYSICS.VERTICAL_FOV * Math.PI / 360);

        const denom = Math.max(1e-6, bboxHeightNorm * this.videoHeight);
        const depth = (focalLengthPx * physicalHeight) / denom;

        return Utils.clamp(depth, CONFIG.PHYSICS.MIN_RANGE, CONFIG.PHYSICS.MAX_RANGE);
    }

    _analyzeMotion(track) {
        if (!track.velocity || track.status === 'new') {
            return { motionState: 'unknown', radialSpeed: 0 };
        }

        const scaleChange = track.velocity.vy / window.innerHeight;
        let motionState = 'static';

        if (scaleChange > 0.02) motionState = 'approaching';
        else if (scaleChange < -0.01) motionState = 'receding';
        else if (Math.abs(scaleChange) < 0.005) motionState = 'static';
        else motionState = 'moving';

        return { motionState, radialSpeed: scaleChange };
    }

    calibrateDepth(knownDistance, track) {
        CONFIG.PHYSICS.IS_CALIBRATED = true;
        return knownDistance / Math.max(1e-6, track.depthMeters);
    }
}


// ============================================================================
// RADAR SYSTEM - FIXED BEARING HANDLING
// ============================================================================

class RadarSystem {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.width = 140;
        this.height = 140;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        this.maxRadius = this.width / 2 - 5;
    }

    update(tracks) {
        // Clear previous blips efficiently
        if (this.container.children.length > 4) { // Keep grid elements
            const blips = this.container.querySelectorAll('.radar-blip');
            blips.forEach(blip => blip.remove());
        }
        
        // Limit number of blips
        const displayTracks = tracks.slice(0, CONFIG.RADAR.MAX_BLIPS);
        
        displayTracks.forEach(track => {
            // Fix: Check for null/undefined bearingDeg properly
            if (track.bearingDeg == null) return;
            
            const blip = this._createBlip(track);
            if (blip) {
                this.container.appendChild(blip);
            }
        });
    }

    _createBlip(track) {
        // Fix: Handle bearingDeg = 0 case
        const bearingDeg = track.bearingDeg !== null && track.bearingDeg !== undefined ? track.bearingDeg : 0;
        const angle = bearingDeg * Math.PI / 180;
        
        // Convert depth to radar radius
        const depth = track.depthEstimate;
        const range = (depth / CONFIG.PHYSICS.MAX_RANGE) * this.maxRadius;
        
        const x = this.centerX + range * Math.sin(angle);
        const y = this.centerY - range * Math.cos(angle);
        
        const blip = document.createElement('div');
        blip.className = 'radar-blip';
        blip.style.left = `${x}px`;
        blip.style.top = `${y}px`;
        
        // Size based on object type
        let size = 6;
        let color = CONFIG.UI.COLOR_CODING.LOW;
        
        switch (track.label) {
            case 'person':
                size = 8;
                color = CONFIG.UI.COLOR_CODING.HIGH;
                break;
            case 'car':
            case 'truck':
                size = 10;
                color = CONFIG.UI.COLOR_CODING.MEDIUM;
                break;
        }
        
        // Adjust for motion
        if (track.motionAnalysis.motionState === 'approaching') {
            size += 2;
            blip.style.animation = 'pulse 1s infinite';
        }
        
        blip.style.width = `${size}px`;
        blip.style.height = `${size}px`;
        blip.style.backgroundColor = color;
        
        return blip;
    }
}

// ============================================================================
// KNOWLEDGE BASE - PERSISTENT STORAGE
// ============================================================================

class KnowledgeBase {
    constructor() {
        this.events = [];
        this.loadFromStorage();
    }

    recordEvent(type, data, timestamp = Date.now()) {
        const event = {
            type,
            data,
            timestamp,
            id: Utils.generateId()
        };
        
        this.events.push(event);
        
        // Maintain size limits
        if (this.events.length > CONFIG.MEMORY.MAX_EVENTS) {
            this.events.shift();
        }
        
        // Auto-save periodically
        if (this.events.length % 10 === 0) {
            this.saveToStorage();
        }
        
        return event.id;
    }

    saveToStorage() {
        try {
            const data = {
                events: this.events.slice(-500), // Keep recent events
                timestamp: Date.now()
            };
            localStorage.setItem(CONFIG.MEMORY.STORAGE_KEY, JSON.stringify(data));
        } catch (error) {
            console.warn("Failed to save to storage:", error);
        }
    }

    loadFromStorage() {
        try {
            const stored = localStorage.getItem(CONFIG.MEMORY.STORAGE_KEY);
            if (stored) {
                const data = JSON.parse(stored);
                this.events = data.events || [];
            }
        } catch (error) {
            console.warn("Failed to load from storage:", error);
        }
    }

    clear() {
        this.events = [];
        localStorage.removeItem(CONFIG.MEMORY.STORAGE_KEY);
    }

    exportData() {
        const data = {
            events: this.events,
            exportTime: new Date().toISOString(),
            totalEvents: this.events.length
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `omega_vision_export_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    getActiveObjectCount() {
        const recentTime = Date.now() - 5000;
        const activeObjects = new Set();
        
        for (const event of this.events.slice().reverse()) {
            if (event.timestamp < recentTime) break;
            if (event.data.objectId && (event.type === 'object_detected' || event.type === 'object_updated')) {
                activeObjects.add(event.data.objectId);
            }
        }
        
        return activeObjects.size;
    }

    getPersonDetectionsInLast(minutes) {
        const cutoff = Date.now() - (minutes * 60 * 1000);
        return this.events.filter(event => 
            event.timestamp >= cutoff && 
            event.data.label === 'person'
        ).length;
    }

    getClosestPerson() {
        const personEvents = this.events.filter(event => 
            event.data.label === 'person' &&
            event.data.depthEstimate !== undefined
        );
        
        if (personEvents.length === 0) return null;
        
        const closest = personEvents.reduce((prev, current) => 
            (prev.data.depthEstimate < current.data.depthEstimate) ? prev : current
        );
        
        return {
            distance: closest.data.depthEstimate,
            bearing: closest.data.bearingDeg || 0
        };
    }

    getMostCommonLabelInLast(minutes) {
        const cutoff = Date.now() - (minutes * 60 * 1000);
        const recentEvents = this.events.filter(event => event.timestamp >= cutoff);
        
        const labelCounts = {};
        recentEvents.forEach(event => {
            const label = event.data.label;
            labelCounts[label] = (labelCounts[label] || 0) + 1;
        });
        
        let maxCount = 0;
        let mostCommon = 'none';
        
        for (const [label, count] of Object.entries(labelCounts)) {
            if (count > maxCount) {
                maxCount = count;
                mostCommon = label;
            }
        }
        
        return mostCommon;
    }
}

// ============================================================================
// HUD RENDERER - OPTIMIZED
// ============================================================================

class HUDRenderer {
    constructor() {
        this.canvas = document.getElementById('hud-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        this.hudEnabled = true;
        window.addEventListener('resize', () => this.resize());
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    render(avionicsData, tracks, primaryTarget) {
        if (!this.hudEnabled) { this.clear(); return; }
        this.clear();
        this.ctx.imageSmoothingEnabled = false;

        this.drawHorizon(avionicsData);
        this.drawCrosshair();
        this.drawTargetBoxes(tracks);
        if (primaryTarget) this.drawPrimaryTarget(primaryTarget);
    }

    drawHorizon(avionicsData) {
        const { width, height } = this.canvas;
        const ctx = this.ctx;
        const { pitch, roll } = avionicsData.getOrientation();

        ctx.save();
        ctx.translate(width/2, height/2);
        ctx.rotate(roll * Math.PI / 180);
        const horizonY = pitch * 2;

        ctx.fillStyle = 'rgba(0, 50, 100, 0.3)';
        ctx.fillRect(-width, -height, width * 2, height + horizonY);

        ctx.fillStyle = 'rgba(101, 67, 33, 0.3)';
        ctx.fillRect(-width, horizonY, width * 2, height);

        ctx.strokeStyle = 'rgba(0, 255, 65, 0.5)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-width, horizonY);
        ctx.lineTo(width, horizonY);
        ctx.stroke();
        ctx.restore();
    }

    drawCrosshair() {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        const ctx = this.ctx;

        ctx.strokeStyle = CONFIG.UI.COLOR_CODING.LOW;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(cx, cy, 20, 0, Math.PI * 2);
        ctx.moveTo(cx - 10, cy); ctx.lineTo(cx - 30, cy);
        ctx.moveTo(cx + 10, cy); ctx.lineTo(cx + 30, cy);
        ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy - 30);
        ctx.moveTo(cx, cy + 10); ctx.lineTo(cx, cy + 30);
        ctx.stroke();

        ctx.fillStyle = CONFIG.UI.COLOR_CODING.HIGH;
        ctx.fillRect(cx - 1, cy - 1, 2, 2);
    }

    drawTargetBoxes(tracks) { tracks.forEach(t => this.drawTargetBox(t)); }

    drawTargetBox(track) {
        const bbox = track.screenBbox || track.bbox;
        const { x, y, width, height } = bbox;
        const ctx = this.ctx;

        let color = CONFIG.UI.COLOR_CODING.LOW;
        if (track.label === 'person') color = CONFIG.UI.COLOR_CODING.HIGH;
        else if (['car','truck','bus'].includes(track.label)) color = CONFIG.UI.COLOR_CODING.MEDIUM;

        const bracketSize = Math.min(width, height) * 0.15;

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 5;
        ctx.shadowColor = color;
        ctx.beginPath();

        ctx.moveTo(x, y + bracketSize);
        ctx.lineTo(x, y);
        ctx.lineTo(x + bracketSize, y);

        ctx.moveTo(x + width - bracketSize, y);
        ctx.lineTo(x + width, y);
        ctx.lineTo(x + width, y + bracketSize);

        ctx.moveTo(x + width, y + height - bracketSize);
        ctx.lineTo(x + width, y + height);
        ctx.lineTo(x + width - bracketSize, y + height);

        ctx.moveTo(x + bracketSize, y + height);
        ctx.lineTo(x, y + height);
        ctx.lineTo(x, y + height - bracketSize);

        ctx.stroke();
        ctx.shadowBlur = 0;

        // ✅ Motion prediction visual: dashed future box
        if (track.predictedScreenBbox) {
            const pb = track.predictedScreenBbox;
            ctx.save();
            ctx.globalAlpha = 0.35;
            ctx.setLineDash([4, 4]);
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = color;
            ctx.strokeRect(pb.x, pb.y, pb.width, pb.height);
            ctx.setLineDash([]);
            ctx.restore();
        }

        const label = `${track.label.toUpperCase()} ${Math.floor(track.confidence * 100)}%`;
        const dist = CONFIG.PHYSICS.IS_CALIBRATED
            ? `~${Math.floor(track.depthMeters)}m`
            : `${Math.floor((track.depthNorm ?? 0) * 100)}%`;

        ctx.font = "bold 10px monospace";
        const textWidth = ctx.measureText(label).width;

        const labelY = Math.max(0, y - 25);

        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(x, labelY, textWidth + 10, 20);

        ctx.fillStyle = color;
        ctx.fillText(label, x + 5, labelY + 14);
        ctx.fillStyle = '#fff';
        ctx.font = "9px monospace";
        ctx.fillText(dist, x + 5, labelY + 30);
    }

    drawPrimaryTarget(target) {
        const bbox = target.predictedScreenBbox || target.screenBbox || target.bbox;
        const centerX = bbox.x + bbox.width / 2;
        const centerY = bbox.y + bbox.height / 2;
        const ctx = this.ctx;

        const pulsePhase = (Date.now() % 1000) / 1000;
        const radius = Math.max(bbox.width, bbox.height) / 2 + 15 +
            Math.sin(pulsePhase * Math.PI * 2) * 5;

        ctx.strokeStyle = CONFIG.UI.COLOR_CODING.HIGH;
        ctx.lineWidth = 2;
        ctx.setLineDash([5,5]);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    setHudEnabled(enabled) { this.hudEnabled = enabled; }
}


// ============================================================================
// UI AUTO-AVOIDANCE (PANELS STEER AWAY FROM IMPORTANT AREAS)
// ============================================================================

class UIAvoider {
    constructor(panels) {
        this.panels = panels.filter(Boolean);
        this.state = new Map();
        this.refreshAnchors();
        window.addEventListener('resize', () => this.refreshAnchors());
    }

    refreshAnchors() {
        this.state.clear();
        this.panels.forEach(el => {
            const r = el.getBoundingClientRect();
            this.state.set(el.id, {
                anchor: { l: r.left, t: r.top, w: r.width, h: r.height },
                offset: { x: 0, y: 0 }
            });
            el.style.willChange = 'transform';
        });
    }

    update(importantRect) {
        if (!importantRect) {
            // ease back to anchor
            this.state.forEach((s, id) => {
                s.offset.x = Utils.ema(0, s.offset.x, 0.8);
                s.offset.y = Utils.ema(0, s.offset.y, 0.8);
                const el = document.getElementById(id);
                if (el) el.style.transform = `translate(${s.offset.x}px, ${s.offset.y}px)`;
            });
            return;
        }

        const icx = (importantRect.left + importantRect.right) / 2;
        const icy = (importantRect.top + importantRect.bottom) / 2;

        this.state.forEach((s, id) => {
            const el = document.getElementById(id);
            if (!el) return;

            const { l, t, w, h } = s.anchor;

            const panelRect = {
                left: l + s.offset.x,
                top: t + s.offset.y,
                right: l + s.offset.x + w,
                bottom: t + s.offset.y + h
            };

            const overlap = !(
                panelRect.right < importantRect.left ||
                panelRect.left > importantRect.right ||
                panelRect.bottom < importantRect.top ||
                panelRect.top > importantRect.bottom
            );

            let desiredX = 0, desiredY = 0;

            if (overlap) {
                const pcx = panelRect.left + w / 2;
                const pcy = panelRect.top + h / 2;

                let vx = pcx - icx;
                let vy = pcy - icy;
                const mag = Math.hypot(vx, vy) || 1;
                vx /= mag; vy /= mag;

                const push = Math.min(140, 70 + mag * 0.08);
                desiredX = vx * push;
                desiredY = vy * push;
            }

            // clamp within screen bounds
            const targetLeft = Utils.clamp(l + desiredX, 6, window.innerWidth - w - 6);
            const targetTop  = Utils.clamp(t + desiredY, 6, window.innerHeight - h - 6);
            desiredX = targetLeft - l;
            desiredY = targetTop - t;

            s.offset.x = Utils.ema(desiredX, s.offset.x, 0.82);
            s.offset.y = Utils.ema(desiredY, s.offset.y, 0.82);

            el.style.transform = `translate(${s.offset.x}px, ${s.offset.y}px)`;
        });
    }
}

// ============================================================================
// OMEGA KERNEL - OPTIMIZED WITH ALL FIXES
// ============================================================================

class OmegaKernel {
    constructor() {
        this.avionics = new Avionics();
        this.vision   = new VisionEngine();
        this.tracker  = new ObjectTracker();
        this.physics  = new PhysicsEngine();
        this.radar    = new RadarSystem('radar-blips');
        this.memory   = new KnowledgeBase();
        this.renderer = new HUDRenderer();

        this.predictionHorizonSec = 0.75; // ~0.5–1.0s lookahead

        this.isRunning = false;
        this.video = document.getElementById('camera-feed');
        this.trackedObjects = [];
        this.primaryTarget = null;

        // Magnetic lock state
        this.lockedTargetId = null;
        this.lockLostSince = null;
        this.lockSwitchMargin = 0.12; // hysteresis margin

        this.lastAITime = 0;
        this._setupControls();

        // UI auto-avoid panels
        this.uiAvoider = new UIAvoider([
            document.getElementById('panel-metrics'),
            document.getElementById('panel-avionics'),
            document.getElementById('panel-analytics'),
            document.getElementById('panel-target')
        ]);
    }

    _setupControls() {
        document.getElementById('toggle-controls').addEventListener('click', () => {
            const panel = document.getElementById('control-panel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        });

        document.getElementById('btn-quality-low').addEventListener('click', () => this._setQuality('LOW'));
        document.getElementById('btn-quality-balanced').addEventListener('click', () => this._setQuality('BALANCED'));
        document.getElementById('btn-quality-high').addEventListener('click', () => this._setQuality('HIGH'));

        document.getElementById('btn-hud-on').addEventListener('click', () => this._setHudEnabled(true));
        document.getElementById('btn-hud-off').addEventListener('click', () => this._setHudEnabled(false));

        document.getElementById('btn-export').addEventListener('click', () => this.memory.exportData());
        document.getElementById('btn-clear').addEventListener('click', () => {
            if (confirm('Clear all memory data?')) this.memory.clear();
        });

        document.getElementById('btn-calibrate').addEventListener('click', () => this._startCalibration());
        document.getElementById('btn-retry-permission').addEventListener('click', () => this._retryPermission());
    }

    _setQuality(preset) {
        this.vision.setQualityPreset(preset);

        ['low','balanced','high'].forEach(k => {
            const btn = document.getElementById(`btn-quality-${k}`);
            btn && btn.classList.remove('active');
        });
        document.getElementById(`btn-quality-${preset.toLowerCase()}`).classList.add('active');

        const blur = CONFIG.AI.QUALITY_PRESETS[preset].blur;
        document.getElementById('ui-layer').style.backdropFilter = `blur(${blur}px)`;
    }

    _setHudEnabled(enabled) {
        this.renderer.setHudEnabled(enabled);
        document.getElementById('btn-hud-on').classList.toggle('active', enabled);
        document.getElementById('btn-hud-off').classList.toggle('active', !enabled);
    }

    async boot() {
        try {
            this._updateStatus('INITIALIZING...');

            this._updateBootLED('led-gyro', 'loading');
            const avionicsReady = await this.avionics.init();
            this._updateBootLED('led-gyro', avionicsReady ? 'active' : 'warning');

            this._updateBootLED('led-cam', 'loading');
            const cameraReady = await this._initCamera();
            this._updateBootLED('led-cam', cameraReady ? 'active' : 'error');

            if (!cameraReady) { this._showPermissionOverlay(); return; }

            this._updateBootLED('led-ai', 'loading');
            const visionReady = await this.vision.init();
            this._updateBootLED('led-ai', visionReady ? 'active' : 'error');

            this._updateBootLED('led-tracker', 'active');
            this._updateBootLED('led-memory', 'active');

            document.getElementById('boot-overlay').style.display = 'none';
            this.isRunning = true;
            this._updateStatus('SYSTEM_OPERATIONAL');

            this.aiCycle();
            this.renderCycle();
        } catch (error) {
            console.error("Boot failed:", error);
            this._updateStatus(`ERROR: ${error.message}`);
        }
    }

    async _initCamera() {
        try {
            if (!navigator.mediaDevices?.getUserMedia) throw new Error('getUserMedia not supported');

            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }, 
                audio: false 
            });

            this.video.srcObject = stream;
            await new Promise(resolve => {
                this.video.onloadedmetadata = () => this.video.play().then(resolve);
            });

            this.physics.updateVideoDimensions(this.video);
            return true;
        } catch (error) {
            console.error("Camera init failed:", error);
            return false;
        }
    }

    _showPermissionOverlay() {
        document.getElementById('permission-overlay').style.display = 'flex';
        this._updateStatus('CAMERA_PERMISSION_REQUIRED');
    }

    _retryPermission() {
        document.getElementById('permission-overlay').style.display = 'none';
        setTimeout(() => this.boot(), 100);
    }

    async aiCycle() {
        if (!this.isRunning) return;

        const now = performance.now();
        const rate = this.vision.getInferenceRate();
        const aiInterval = 1000 / rate;

        if (now - this.lastAITime >= aiInterval) {
            this.lastAITime = now;
            try {
                const detections = await this.vision.detect(this.video);
                const rawTracks = this.tracker.update(detections, Date.now(), rate);
                this.trackedObjects = this.physics.analyze(rawTracks);

                // Attach prediction (0.5–1s horizon)
                this.trackedObjects.forEach(t => {
                    t.predictedScreenBbox = this.physics.predictScreenBbox(t, this.predictionHorizonSec);
                    const pb = t.predictedScreenBbox;
                    const cx = pb.x + pb.width / 2;
                    const cy = pb.y + pb.height / 2;
                    t.predictedScreenPosition = {
                        xNorm: (cx / window.innerWidth) * 2 - 1,
                        yNorm: (cy / window.innerHeight) * 2 - 1
                    };
                });

                this._updateMemory(this.trackedObjects);
                this._updatePrimaryTarget();
            } catch (error) {
                console.error("AI cycle error:", error);
            }
        }

        const nextCycle = Math.max(0, aiInterval - (performance.now() - this.lastAITime));
        setTimeout(() => this.aiCycle(), nextCycle);
    }

    renderCycle() {
        if (!this.isRunning) return;

        this.vision.updateRenderFPS();
        this.renderer.render(this.avionics, this.trackedObjects, this.primaryTarget);
        this.radar.update(this.trackedObjects);

        // UI avoid important area (use predicted primary bbox)
        if (this.primaryTarget?.predictedScreenBbox) {
            const b = this.primaryTarget.predictedScreenBbox;
            const pad = 18;
            const importantRect = {
                left: b.x - pad,
                top: b.y - pad,
                right: b.x + b.width + pad,
                bottom: b.y + b.height + pad
            };
            this.uiAvoider.update(importantRect);
        } else {
            this.uiAvoider.update(null);
        }

        this._updateUI();
        performanceMonitor.update();

        requestAnimationFrame(() => this.renderCycle());
    }

    _updateMemory(tracks) {
        const tracksArray = Array.from(this.tracker.tracks.values());

        tracks.forEach(track => {
            const eventType = track.status === 'new' ? 'object_detected' : 'object_updated';
            this.memory.recordEvent(eventType, {
                objectId: track.id,
                label: track.label,
                confidence: track.confidence,
                depthMeters: track.depthMeters,
                depthNorm: track.depthNorm,
                bearingDeg: track.bearingDeg,
                motionState: track.motionAnalysis?.motionState
            });
        });

        const lostTracks = tracksArray.filter(t => t.status === 'lost');
        lostTracks.forEach(track => {
            this.memory.recordEvent('object_lost', {
                objectId: track.id,
                label: track.label
            });
        });
    }

    _scoreTrack(track) {
        const pb = track.predictedScreenBbox || track.screenBbox;
        const cx = pb.x + pb.width / 2;
        const cy = pb.y + pb.height / 2;
        const scx = window.innerWidth / 2;
        const scy = window.innerHeight / 2;

        const diag = Math.hypot(window.innerWidth, window.innerHeight);
        const centerDist = Math.hypot(cx - scx, cy - scy) / diag; // 0..1
        const centerScore = Utils.clamp(1 - centerDist * 1.8, 0, 1);

        const areaNorm = (pb.width * pb.height) / (window.innerWidth * window.innerHeight);
        const sizeScore = Utils.clamp(areaNorm / 0.20, 0, 1);

        const confScore = track.confidence || 0;

        const labelBonus = track.label === 'person' ? 0.15 : 0;

        let score = centerScore * 0.55 + confScore * 0.25 + sizeScore * 0.20 + labelBonus;

        if (this.lockedTargetId === track.id) score += 0.25; // magnetic boost

        return score;
    }

    _updatePrimaryTarget() {
        if (!this.trackedObjects.length) {
            this.primaryTarget = null;
            this.lockedTargetId = null;
            this.lockLostSince = null;
            return;
        }

        const candidates = this.trackedObjects;
        let best = candidates[0];
        let bestScore = this._scoreTrack(best);

        for (let i = 1; i < candidates.length; i++) {
            const s = this._scoreTrack(candidates[i]);
            if (s > bestScore) {
                bestScore = s;
                best = candidates[i];
            }
        }

        // Resolve current locked target score
        const locked = this.lockedTargetId != null
            ? candidates.find(t => t.id === this.lockedTargetId)
            : null;

        if (locked) {
            const lockedScore = this._scoreTrack(locked);

            // Only switch if best significantly better
            if (best.id !== locked.id && bestScore > lockedScore + this.lockSwitchMargin) {
                this.lockedTargetId = best.id;
                this.primaryTarget = best;
                this.lockLostSince = null;
            } else {
                this.primaryTarget = locked;
                this.lockLostSince = null;
            }
        } else {
            // No locked target yet (or lost)
            if (this.lockLostSince == null) this.lockLostSince = Date.now();

            const lostFor = Date.now() - this.lockLostSince;
            if (lostFor > 300 || bestScore > 0.25) {  // acquire quickly
                this.lockedTargetId = best.id;
                this.primaryTarget = best;
                this.lockLostSince = null;
            } else {
                this.primaryTarget = best;
            }
        }
    }

    _updateUI() {
        const visionStatus = this.vision.getStatus();
        document.getElementById('val-cpu').textContent = Utils.formatNumber(visionStatus.lastTime, 1);
        document.getElementById('val-ai-fps').textContent = Utils.formatNumber(visionStatus.aiFps, 1);
        document.getElementById('val-render-fps').textContent = Utils.formatNumber(visionStatus.renderFps, 1);

        const orientation = this.avionics.getOrientation();
        document.getElementById('val-pitch').textContent = Utils.formatNumber(orientation.pitch, 1) + '°';
        document.getElementById('val-roll').textContent = Utils.formatNumber(orientation.roll, 1) + '°';
        document.getElementById('val-heading').textContent = Utils.formatNumber(orientation.heading, 1) + '°';
        document.getElementById('val-g').textContent = Utils.formatNumber(this.avionics.gForce, 2);

        const trackerStats = this.tracker.getStats();
        document.getElementById('val-tracked').textContent = trackerStats.activeTracks;

        document.getElementById('val-active').textContent = this.memory.getActiveObjectCount();
        document.getElementById('val-persons').textContent = this.memory.getPersonDetectionsInLast(5);

        const closestPerson = this.memory.getClosestPerson();
        document.getElementById('val-closest-person').textContent = closestPerson
            ? `~${Utils.formatNumber(closestPerson.distance, 1)}m @ ${Utils.formatNumber(closestPerson.bearing, 0)}°`
            : '--';

        document.getElementById('val-top-label').textContent = this.memory.getMostCommonLabelInLast(5);

        if (this.primaryTarget) {
            document.getElementById('val-target-label').textContent = this.primaryTarget.label.toUpperCase();

            const distText = CONFIG.PHYSICS.IS_CALIBRATED
                ? `~${Utils.formatNumber(this.primaryTarget.depthMeters, 1)}m`
                : `${Math.floor((this.primaryTarget.depthNorm ?? 0) * 100)}%`;

            document.getElementById('val-target-dist').textContent = distText;

            // ✅ FIX: bearing could be 0, so don't treat as falsy
            const bearing = (this.primaryTarget.bearingDeg ?? 0);
            document.getElementById('val-target-bearing').textContent =
                `${Utils.formatNumber(bearing, 1)}°`;

            document.getElementById('val-target-state').textContent =
                (this.primaryTarget.motionAnalysis?.motionState || 'unknown').toUpperCase();
            document.getElementById('val-target-conf').textContent =
                `${Math.floor(this.primaryTarget.confidence * 100)}%`;
        }

        this._updateSystemStatus();
    }

    _updateSystemStatus() {
        document.getElementById('status-cam').className =
            `status-indicator ${this.video.srcObject ? 'status-ok' : 'status-error'}`;
        document.getElementById('status-ai').className =
            `status-indicator ${this.vision.isModelLoaded ? 'status-ok' : 'status-error'}`;
        document.getElementById('status-gyro').className =
            `status-indicator ${this.avionics.isAvailable ? 'status-ok' : 'status-offline'}`;
        document.getElementById('status-tracker').className =
            `status-indicator ${this.trackedObjects.length ? 'status-ok' : 'status-warn'}`;
        document.getElementById('status-memory').className =
            `status-indicator ${this.memory.events.length ? 'status-ok' : 'status-warn'}`;
    }

    _updateBootLED(ledId, state) {
        const led = document.getElementById(ledId);
        led.className = 'status-led';
        if (state === 'active') led.classList.add('active');
        else if (state === 'error') led.classList.add('error');
        else if (state === 'warning') led.classList.add('warning');
        else if (state === 'loading') led.classList.add('loading');
    }

    _updateStatus(message) {
        document.getElementById('status-message').textContent = message;
    }

    _startCalibration() {
        if (!this.trackedObjects.length) { alert('No objects detected for calibration'); return; }
        const distance = prompt('Enter known distance to object (meters):');
        if (distance && !isNaN(distance)) {
            const knownDistance = parseFloat(distance);
            const track = this.trackedObjects[0];
            this.physics.calibrateDepth(knownDistance, track);
            alert('Depth calibration completed');
        }
    }

    shutdown() {
        this.isRunning = false;
        if (this.video.srcObject) {
            this.video.srcObject.getTracks().forEach(track => track.stop());
        }
        this.memory.saveToStorage();
    }
}


// ============================================================================
// SYSTEM INITIALIZATION
// ============================================================================

const OMEGA = new OmegaKernel();

document.getElementById('btn-init').addEventListener('click', () => {
    const btn = document.getElementById('btn-init');
    btn.textContent = 'INITIALIZING...';
    btn.disabled = true;
    OMEGA.boot();
});

// Handle visibility changes for performance
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // Reduce processing when in background
        OMEGA.vision.setQualityPreset('LOW');
    }
});

window.addEventListener('beforeunload', () => {
    OMEGA.shutdown();
});

// Add performance monitoring
const performanceMonitor = {
    frames: 0,
    lastTime: performance.now(),
    update: function() {
        this.frames++;
        const now = performance.now();
        if (now >= this.lastTime + 1000) {
            const fps = (this.frames * 1000) / (now - this.lastTime);
            this.frames = 0;
            this.lastTime = now;
            
            // Adaptive quality adjustment
            if (fps < 20 && OMEGA.vision.qualityPreset !== 'LOW') {
                OMEGA._setQuality('LOW');
            }
        }
    }
};

console.log("OMEGA: Advanced Humanoid Vision System - Optimized Version Loaded");
</script>
</body>
</html>
