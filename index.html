<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OMEGA: HUMANOID VISION SYSTEM v2.0</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        :root {
            --hud-primary: #00ff41;   /* Matrix Green */
            --hud-secondary: #008f11; /* Dimmed Green */
            --hud-alert: #ff0000;     /* Critical Red */
            --hud-warn: #ffcc00;      /* Warning Yellow */
            --bg-dark: #050505;
            --glass: rgba(0, 20, 0, 0.8);
        }

        /* --- CORE SETUP --- */
        * { box-sizing: border-box; user-select: none; -webkit-touch-callout: none; }
        body {
            margin: 0; overflow: hidden; background: var(--bg-dark);
            font-family: 'Consolas', 'Monaco', monospace;
            color: var(--hud-primary);
            width: 100vw; height: 100vh;
        }

        /* --- VIEWPORT & LAYERS --- */
        #viewport { position: relative; width: 100%; height: 100%; }
        
        /* Video Layer: High Contrast for Machine Vision aesthetic */
        #camera-feed {
            position: absolute; width: 100%; height: 100%; object-fit: cover;
            z-index: 0; filter: sepia(0.5) hue-rotate(70deg) contrast(1.2) brightness(0.8);
            opacity: 0.6;
        }
        
        /* HUD Canvas: Vector Graphics */
        #hud-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }

        /* --- UI PANELS --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: max(20px, env(safe-area-inset-top));
        }

        .hud-panel {
            background: var(--glass); border-left: 3px solid var(--hud-primary);
            padding: 8px 12px; margin: 10px; width: fit-content;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.1);
        }
        .hud-text { font-size: 12px; letter-spacing: 1px; margin-bottom: 4px; text-shadow: 0 0 5px var(--hud-primary); }
        .hud-value { font-weight: bold; color: #fff; }

        /* --- RADAR COMPONENT --- */
        #radar-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 140px; height: 140px;
            border-radius: 50%;
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid var(--hud-primary);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
            overflow: hidden;
            z-index: 30;
        }
        #radar-container::after {
            /* Scanning Line Animation */
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: conic-gradient(from 0deg, transparent 0deg, transparent 270deg, rgba(0,255,65,0.4) 360deg);
            border-radius: 50%;
            animation: radar-scan 2s linear infinite;
        }
        /* Radar Grid Lines */
        .radar-grid {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            border: 1px solid rgba(0,255,65,0.3); border-radius: 50%; pointer-events: none;
        }
        .radar-cross {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; height: 1px; background: rgba(0,255,65,0.3);
        }
        .radar-blip {
            position: absolute; width: 6px; height: 6px; border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px currentColor;
            transition: all 0.2s ease-out;
        }
        @keyframes radar-scan { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- BOOT SCREEN --- */
        #boot-overlay {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--hud-primary);
        }
        #btn-init {
            background: transparent; color: var(--hud-primary); border: 2px solid var(--hud-primary);
            padding: 15px 50px; font-family: inherit; font-size: 16px; font-weight: bold;
            letter-spacing: 3px; cursor: pointer; margin-top: 20px;
            transition: 0.3s; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }
        #btn-init:hover { background: var(--hud-primary); color: #000; box-shadow: 0 0 30px var(--hud-primary); }
        
        .status-led { display: inline-block; width: 8px; height: 8px; background: #333; border-radius: 50%; margin-right: 8px; }
        .status-led.active { background: var(--hud-primary); box-shadow: 0 0 10px var(--hud-primary); }

    </style>
</head>
<body>

    <div id="viewport">
        <video id="camera-feed" autoplay playsinline muted></video>
        <canvas id="hud-canvas"></canvas>
        
        <div id="ui-layer">
            <div style="display:flex; justify-content:space-between; width:100%;">
                <div class="hud-panel">
                    <div class="hud-text">SYSTEM CPU: <span id="val-cpu" class="hud-value">0</span> ms</div>
                    <div class="hud-text">VISION FPS: <span id="val-fps" class="hud-value">0</span></div>
                </div>
                <div class="hud-panel" style="text-align:right;">
                    <div class="hud-text">GYRO-X: <span id="val-pitch" class="hud-value">0</span>°</div>
                    <div class="hud-text">GYRO-Y: <span id="val-roll" class="hud-value">0</span>°</div>
                    <div class="hud-text">G-FORCE: <span id="val-g" class="hud-value">1.0</span></div>
                </div>
            </div>

            <div id="radar-container">
                <div class="radar-grid" style="width: 33%; height: 33%;"></div>
                <div class="radar-grid" style="width: 66%; height: 66%;"></div>
                <div class="radar-cross"></div>
                <div class="radar-cross" style="transform: translate(-50%, -50%) rotate(90deg);"></div>
                <div id="radar-blips"></div>
            </div>
        </div>
    </div>

    <div id="boot-overlay">
        <div style="font-size: 40px; font-weight: 900; margin-bottom: 10px; letter-spacing: 5px;">OMEGA</div>
        <div style="opacity: 0.7; margin-bottom: 30px;">HUMANOID OPERATING SYSTEM</div>
        <div style="text-align: left; font-size: 12px; line-height: 1.6; opacity: 0.8;">
            <div><span class="status-led" id="led-cam"></span> OPTICAL SENSORS</div>
            <div><span class="status-led" id="led-ai"></span> NEURAL ENGINE (COCO-SSD)</div>
            <div><span class="status-led" id="led-gyro"></span> AVIONICS / GYRO</div>
        </div>
        <button id="btn-init">INITIALIZE SYSTEM</button>
    </div>

<script>
/**
 * OMEGA OS - Humanoid Vision Kernel
 * Standard: World-Class Clean Code
 * Architecture: Event-Driven / Component Based
 */

// --- CONFIGURATION ---
const CONFIG = {
    CONFIDENCE_THRESHOLD: 0.55,
    RADAR_RANGE_METER: 50, // Simulated max range
    HUD_COLOR_SAFE: '#00ff41',
    HUD_COLOR_HOSTILE: '#ff0000',
    HUD_COLOR_NEUTRAL: '#ffcc00'
};

// --- MODULE: UTILITIES ---
const Utils = {
    clamp: (num, min, max) => Math.min(Math.max(num, min), max),
    map: (value, x1, y1, x2, y2) => (value - x1) * (y2 - x2) / (y1 - x1) + x2
};

// --- MODULE: RADAR SYSTEM ---
class RadarSystem {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.width = 140; // Matches CSS
        this.height = 140;
    }

    update(predictions) {
        this.container.innerHTML = ''; // Clear old blips

        predictions.forEach(p => {
            const blip = document.createElement('div');
            blip.className = 'radar-blip';
            
            // 1. Calculate Azimuth (Angle)
            // Center of screen is 0 degrees. Left is negative, Right is positive.
            const centerX = p.bbox[0] + (p.bbox[2] / 2);
            const screenW = window.innerWidth;
            // Normalize -1 to 1
            const azimuth = Utils.map(centerX, 0, screenW, -1, 1); 

            // 2. Calculate Distance (Range)
            // The larger the object (height), the closer it is.
            // Inverse relationship.
            const screenH = window.innerHeight;
            const heightRatio = p.bbox[3] / screenH; 
            // Simplified depth estimation: 0 (far) to 1 (close) -> mapped to radius
            let distance = 1 - Math.min(heightRatio, 1);
            // Push it out a bit so it's not always center
            distance = Utils.map(distance, 0, 1, 0.1, 0.9); 

            // 3. Convert Polar to Cartesian for CSS placement
            // Radar center is (0,0) in logic, but (70,70) in pixels
            const r = (this.width / 2) * distance;
            // Spread angle limit (e.g., camera view is approx 60-90 degrees FOV)
            const theta = azimuth * (Math.PI / 4); // +/- 45 degrees

            const x = r * Math.sin(theta);
            const y = -r * Math.cos(theta); // Up is negative in CSS

            // 4. Style & Position
            blip.style.left = `${(this.width/2) + x}px`;
            blip.style.top = `${(this.height/2) + y}px`;
            blip.style.backgroundColor = p.class === 'person' ? CONFIG.HUD_COLOR_HOSTILE : CONFIG.HUD_COLOR_NEUTRAL;
            
            this.container.appendChild(blip);
        });
    }
}

// --- MODULE: AVIONICS (SENSORS) ---
class Avionics {
    constructor() {
        this.pitch = 0;
        this.roll = 0;
        this.gForce = 1.0;
    }

    async init() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            const state = await DeviceOrientationEvent.requestPermission();
            if (state !== 'granted') throw new Error("GYRO PERMISSION DENIED");
        }
        
        window.addEventListener('deviceorientation', e => {
            this.pitch = e.beta || 0; // X-axis
            this.roll = e.gamma || 0; // Y-axis
        });
        
        window.addEventListener('devicemotion', e => {
            const acc = e.accelerationIncludingGravity;
            if (acc) {
                const {x, y, z} = acc;
                this.gForce = Math.sqrt(x*x + y*y + z*z) / 9.81;
            }
        });
        document.getElementById('led-gyro').classList.add('active');
    }
}

// --- MODULE: NEURAL VISION (AI) ---
class VisionSystem {
    constructor() {
        this.model = null;
        this.isProcessing = false;
        this.lastInferenceTime = 0;
        this.predictions = [];
    }

    async init() {
        await tf.ready();
        this.model = await cocoSsd.load({ base: 'lite_mobilenet_v2' }); // Use lite version for speed
        document.getElementById('led-ai').classList.add('active');
    }

    async detect(videoEl) {
        if (!this.model || this.isProcessing || videoEl.readyState !== 4) return;
        
        this.isProcessing = true;
        const start = performance.now();
        
        try {
            // Run inference
            const results = await this.model.detect(videoEl, 10, CONFIG.CONFIDENCE_THRESHOLD);
            this.predictions = results;
        } catch (e) {
            console.error("AI Error", e);
        }
        
        this.lastInferenceTime = Math.floor(performance.now() - start);
        this.isProcessing = false;
    }
}

// --- MODULE: HUD RENDERER ---
class HUDRenderer {
    constructor() {
        this.canvas = document.getElementById('hud-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    drawHorizon(pitch, roll) {
        const { width, height } = this.canvas;
        const ctx = this.ctx;
        
        ctx.save();
        ctx.translate(width/2, height/2);
        ctx.rotate(roll * Math.PI / 180);
        ctx.translate(0, pitch * 5); // Sensitivity

        // Artificial Horizon Line
        ctx.strokeStyle = 'rgba(0, 255, 65, 0.5)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-width, 0); ctx.lineTo(width, 0);
        ctx.stroke();

        // Pitch Ladder
        for (let i = -3; i <= 3; i++) {
            if (i === 0) continue;
            const y = i * 50;
            const w = 60 - (Math.abs(i) * 10);
            ctx.beginPath();
            ctx.moveTo(-w, y); ctx.lineTo(w, y);
            ctx.stroke();
            // Text
            ctx.fillStyle = 'rgba(0, 255, 65, 0.7)';
            ctx.font = "10px monospace";
            ctx.fillText(i * 10, w + 5, y + 3);
        }
        ctx.restore();
    }

    drawTargetBox(p) {
        const [x, y, w, h] = p.bbox;
        const isPerson = p.class === 'person';
        const color = isPerson ? CONFIG.HUD_COLOR_HOSTILE : CONFIG.HUD_COLOR_SAFE;
        
        const ctx = this.ctx;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 5;
        ctx.shadowColor = color;

        // Draw Corners only (Tactical look)
        const lineLen = w * 0.2;
        ctx.beginPath();
        
        // Top Left
        ctx.moveTo(x, y + lineLen); ctx.lineTo(x, y); ctx.lineTo(x + lineLen, y);
        // Top Right
        ctx.moveTo(x + w - lineLen, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w, y + lineLen);
        // Bottom Right
        ctx.moveTo(x + w, y + h - lineLen); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w - lineLen, y + h);
        // Bottom Left
        ctx.moveTo(x + lineLen, y + h); ctx.lineTo(x, y + h); ctx.lineTo(x, y + h - lineLen);
        
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Label
        ctx.fillStyle = color;
        ctx.font = "bold 10px Consolas";
        const label = `${p.class.toUpperCase()} [${Math.floor(p.score * 100)}%]`;
        ctx.fillText(label, x, y - 8);
    }

    drawCrosshair() {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        const ctx = this.ctx;

        ctx.strokeStyle = CONFIG.HUD_COLOR_SAFE;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(cx, cy, 20, 0, Math.PI * 2);
        ctx.moveTo(cx - 10, cy); ctx.lineTo(cx - 30, cy);
        ctx.moveTo(cx + 10, cy); ctx.lineTo(cx + 30, cy);
        ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy - 30);
        ctx.moveTo(cx, cy + 10); ctx.lineTo(cx, cy + 30);
        ctx.stroke();
        
        // Center Dot
        ctx.fillStyle = CONFIG.HUD_COLOR_HOSTILE;
        ctx.fillRect(cx - 1, cy - 1, 2, 2);
    }
}

// --- CORE: KERNEL ---
const Kernel = {
    video: document.getElementById('camera-feed'),
    avionics: new Avionics(),
    vision: new VisionSystem(),
    renderer: new HUDRenderer(),
    radar: new RadarSystem('radar-blips'),
    
    isRunning: false,

    async boot() {
        try {
            // 1. Request Sensors (Must be user triggered)
            await this.avionics.init().catch(e => console.warn("Sensors skipped:", e));
            
            // 2. Camera Access
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }, 
                audio: false 
            });
            this.video.srcObject = stream;
            document.getElementById('led-cam').classList.add('active');

            // 3. Load AI
            await this.vision.init();

            // 4. Start Loop
            document.getElementById('boot-overlay').style.display = 'none';
            this.isRunning = true;
            this.cycle();

        } catch (e) {
            alert("SYSTEM FAILURE: " + e.message);
        }
    },

    cycle() {
        if (!this.isRunning) return;
        requestAnimationFrame(() => this.cycle());

        // 1. AI Inference (Async - Non-blocking)
        this.vision.detect(this.video);

        // 2. Render HUD
        this.renderer.clear();
        this.renderer.drawHorizon(this.avionics.pitch, this.avionics.roll);
        this.renderer.drawCrosshair();

        // 3. Draw Objects & Radar
        const targets = this.vision.predictions;
        targets.forEach(target => {
            this.renderer.drawTargetBox(target);
        });
        
        // Update Radar with latest predictions
        this.radar.update(targets);

        // 4. Update UI Stats
        document.getElementById('val-cpu').innerText = this.vision.lastInferenceTime;
        document.getElementById('val-fps').innerText = (1000 / Math.max(1, this.vision.lastInferenceTime)).toFixed(0);
        document.getElementById('val-pitch').innerText = this.avionics.pitch.toFixed(0);
        document.getElementById('val-roll').innerText = this.avionics.roll.toFixed(0);
        document.getElementById('val-g').innerText = this.avionics.gForce.toFixed(2);
    }
};

// --- ENTRY POINT ---
document.getElementById('btn-init').addEventListener('click', () => {
    Kernel.boot();
});

</script>
</body>
</html>
