<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OMEGA: ZERO-POINT TRACKING</title>
    
    <!-- AI Core -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2"></script>
    <!-- 3D Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        :root {
            --p: #00ff9d; --s: #008f7a; --a: #ff2a6d; --w: #ffae00;
            --bg: #000; --glass: rgba(0, 20, 10, 0.9);
            --font: 'Segoe UI', monospace;
        }
        
        body { margin: 0; overflow: hidden; background: var(--bg); color: var(--p); font-family: var(--font); }
        
        #viewport { position: relative; width: 100vw; height: 100vh; }
        
        #camera-feed { 
            position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; 
            z-index: 0; opacity: 0.9; filter: contrast(1.1) brightness(0.9);
        }
        
        #layer-3d { position: absolute; inset: 0; z-index: 5; pointer-events: none; }
        #hud-canvas { position: absolute; inset: 0; z-index: 10; pointer-events: none; }
        
        /* CROSSHAIR */
        .crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px; border: 1px solid rgba(0, 255, 157, 0.5);
            z-index: 15; pointer-events: none;
        }
        .crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: var(--p); transform: translate(-50%, -50%); box-shadow: 0 0 10px var(--p);
        }

        /* UI */
        #ui-layer { position: absolute; inset: 0; z-index: 20; padding: 20px; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        .panel {
            background: var(--glass); border-left: 4px solid var(--p);
            padding: 10px 15px; margin-bottom: 5px; backdrop-filter: blur(10px);
            pointer-events: auto; width: fit-content; border-radius: 4px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .label { font-size: 9px; color: #00a8ff; font-weight: 900; letter-spacing: 2px; }
        .val { font-size: 14px; color: #fff; font-weight: bold; font-family: monospace; }
        
        /* LOCK STATUS */
        .lock-status {
            position: absolute; top: 60%; left: 50%; transform: translateX(-50%);
            font-size: 12px; font-weight: 900; letter-spacing: 3px;
            text-shadow: 0 0 10px currentColor; transition: color 0.3s;
        }

        /* RADAR */
        #radar {
            position: absolute; bottom: 30px; right: 20px;
            width: 140px; height: 140px; border-radius: 50%;
            background: rgba(0,10,5,0.95); border: 2px solid var(--s);
            overflow: hidden; pointer-events: auto; z-index: 25;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.2);
        }
        .radar-scan { position: absolute; inset: 0; background: conic-gradient(transparent 270deg, var(--p)); opacity: 0.2; animation: scan 2s linear infinite; border-radius: 50%; }
        .blip { position: absolute; width: 6px; height: 6px; background: var(--p); border-radius: 50%; transform: translate(-50%,-50%); transition: all 0.1s; }
        @keyframes scan { to { transform: rotate(360deg); } }

        /* BOOT SCREEN */
        #boot { position: fixed; inset: 0; background: #000; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #loader { width: 60px; height: 60px; border: 4px solid #111; border-top: 4px solid var(--p); border-radius: 50%; animation: spin 0.8s infinite; margin: 30px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        button { background: var(--p); border: none; color: #000; padding: 15px 40px; font-weight: 900; cursor: pointer; letter-spacing: 2px; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%); }
        button:hover { background: #fff; box-shadow: 0 0 20px var(--p); }
    </style>
</head>
<body>

    <div id="viewport">
        <video id="camera-feed" autoplay playsinline muted></video>
        <canvas id="layer-3d"></canvas>
        <canvas id="hud-canvas"></canvas>
        
        <div class="crosshair"></div>
        <div id="lock-msg" class="lock-status" style="color:rgba(255,255,255,0.5)">SCANNING</div>

        <div id="ui-layer">
            <!-- TOP INFO -->
            <div style="display:flex; justify-content:space-between; width:100%">
                <div class="panel">
                    <div class="label">ZERO-POINT TRACKER</div>
                    <div>FPS: <span id="fps" class="val">0</span></div>
                    <div>MS: <span id="ms" class="val">0</span></div>
                </div>
                <div class="panel" style="text-align:right;">
                    <div class="label">TARGETS</div>
                    <div>ACTIVE: <span id="count" class="val">0</span></div>
                    <div>LOCKED: <span id="locked" class="val" style="color:var(--a)">NONE</span></div>
                </div>
            </div>
            
            <!-- RADAR -->
            <div id="radar">
                <div class="radar-scan"></div>
                <!-- GRID LINES -->
                <div style="position:absolute; top:50%; left:0; width:100%; height:1px; background:rgba(0,255,157,0.3)"></div>
                <div style="position:absolute; left:50%; top:0; height:100%; width:1px; background:rgba(0,255,157,0.3)"></div>
            </div>
        </div>
    </div>

    <div id="boot">
        <h1 style="color:var(--p); letter-spacing: 8px; font-size: 32px; margin:0;">OMEGA</h1>
        <div style="color:#666; font-size: 12px; letter-spacing: 4px;">ZERO-POINT SYSTEM</div>
        <div id="loader"></div>
        <button id="btn-start" onclick="OMEGA.start()" style="display:none;">ENGAGE</button>
    </div>

<script>
/**
 * OMEGA: ZERO-POINT TRACKER
 * Algorithm: Predictive Velocity + Center-Weighted Matching
 */

const CONFIG = {
    AI_CONFIDENCE: 0.45,  // ลดลงเล็กน้อยเพื่อให้จับไวขึ้น (แล้วเรามากรองเอง)
    TRACKING: {
        MAX_LOST: 25,     // จำได้นานขึ้น (ประมาณ 1 วินาทีถ้าหลุด)
        SMOOTHING: 0.15,  // ค่าความหนึบ (ยิ่งน้อยยิ่งหนึบ แต่จะดีเลย์นิดๆ)
        MATCH_DIST: 150   // ระยะพิกเซลที่จะยอมรับว่าเป็นตัวเดิม
    },
    PHYSICS: { FOV: 60, CAM_H: 1.5 }
};

// --- MATH KERNEL ---
const Vector = {
    dist: (a, b) => Math.hypot(a.x - b.x, a.y - b.y),
    lerp: (a, b, t) => a + (b - a) * t,
    getCenter: (box) => ({ x: box[0] + box[2]/2, y: box[1] + box[3]/2 })
};

// --- PREDICTIVE TRACKER CLASS (THE BRAIN) ---
class PredictiveTracker {
    constructor() {
        this.tracks = [];
        this.nextId = 1;
    }

    update(detections, width, height) {
        // 1. PREDICT: ขยับ Tracker ไปข้างหน้าตามความเร็วเดิม (เดาอนาคต)
        this.tracks.forEach(t => {
            t.x += t.vx;
            t.y += t.vy;
            t.lost++; // สมมติว่าหายไปก่อน
        });

        // 2. MATCH: จับคู่ Detection ใหม่ กับ Tracker ที่มีอยู่
        detections.forEach(det => {
            const center = Vector.getCenter(det.bbox);
            let bestDist = CONFIG.TRACKING.MATCH_DIST; // รัศมีค้นหา
            let bestTrack = null;

            // หาตัวที่ใกล้ที่สุด (Nearest Neighbor)
            this.tracks.forEach(t => {
                const d = Vector.dist({x: t.x, y: t.y}, center);
                if (d < bestDist) {
                    bestDist = d;
                    bestTrack = t;
                }
            });

            if (bestTrack) {
                // *** เจอตัวเดิม ***
                
                // คำนวณความเร็วใหม่ (New Velocity)
                const newVx = center.x - bestTrack.x;
                const newVy = center.y - bestTrack.y;
                
                // อัปเดตความเร็วแบบ Smooth (EMA Filter)
                bestTrack.vx = Vector.lerp(bestTrack.vx, newVx, 0.4);
                bestTrack.vy = Vector.lerp(bestTrack.vy, newVy, 0.4);

                // อัปเดตตำแหน่งแบบ "หนึบ" (Lerp)
                bestTrack.x = Vector.lerp(bestTrack.x, center.x, CONFIG.TRACKING.SMOOTHING);
                bestTrack.y = Vector.lerp(bestTrack.y, center.y, CONFIG.TRACKING.SMOOTHING);
                
                // อัปเดตขนาดกล่อง
                bestTrack.w = Vector.lerp(bestTrack.w, det.bbox[2], CONFIG.TRACKING.SMOOTHING);
                bestTrack.h = Vector.lerp(bestTrack.h, det.bbox[3], CONFIG.TRACKING.SMOOTHING);

                bestTrack.lost = 0; // เจอแล้ว รีเซ็ตค่า lost
                bestTrack.score = det.score;
            } else {
                // *** ตัวใหม่ ***
                this.tracks.push({
                    id: this.nextId++,
                    x: center.x, y: center.y,
                    w: det.bbox[2], h: det.bbox[3],
                    vx: 0, vy: 0, // ความเร็วเริ่มต้น 0
                    class: det.class,
                    score: det.score,
                    lost: 0,
                    history: [] // เก็บประวัติการเดิน (Optional)
                });
            }
        });

        // 3. PRUNE: ลบตัวที่หายไปนานเกินกำหนด
        this.tracks = this.tracks.filter(t => t.lost < CONFIG.TRACKING.MAX_LOST);

        return this.tracks;
    }
}

// --- RENDERER (VISUALS) ---
class HUDRenderer {
    constructor() {
        this.canvas = document.getElementById('hud-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.radar = document.getElementById('radar');
        this.resize();
        
        // 3D Scene Setup
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(CONFIG.PHYSICS.FOV, window.innerWidth/window.innerHeight, 0.1, 1000);
        this.renderer3D = new THREE.WebGLRenderer({canvas: document.getElementById('layer-3d'), alpha: true});
        this.renderer3D.setSize(window.innerWidth, window.innerHeight);
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        if(this.renderer3D) {
            this.renderer3D.setSize(window.innerWidth, window.innerHeight);
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
        }
    }

    render(video, tracks) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Scale Factors
        const sx = this.canvas.width / video.videoWidth;
        const sy = this.canvas.height / video.videoHeight;
        
        // Center Screen
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        let lockedTarget = null;
        let minCenterDist = 9999;

        tracks.forEach(t => {
            // คำนวณพิกัดบนจอ
            const screenX = t.x * sx;
            const screenY = t.y * sy;
            const screenW = t.w * sx;
            const screenH = t.h * sy;
            
            // คำนวณระยะห่างจากเป้ากลางจอ (เพื่อหา Lock Target)
            const distToCenter = Vector.dist({x: screenX, y: screenY}, {x: cx, y: cy});
            if(distToCenter < minCenterDist) {
                minCenterDist = distToCenter;
                lockedTarget = t;
            }

            // สี: ถ้าเป็นเป้าที่ล็อกอยู่จะเป็นสีแดง ถ้าไม่ใช่เป็นสีเขียว
            const isLocked = (t === lockedTarget && distToCenter < 150);
            const color = isLocked ? '#ff2a6d' : (t.class === 'person' ? '#ffae00' : '#00ff9d');
            const lw = isLocked ? 3 : 1;

            // --- 1. Draw Tech Box (มุม 4 ด้าน) ---
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = lw;
            this.ctx.beginPath();
            const boxX = screenX - screenW/2;
            const boxY = screenY - screenH/2;
            const L = screenW * 0.25;

            // TL, TR, BR, BL
            this.ctx.moveTo(boxX, boxY + L); this.ctx.lineTo(boxX, boxY); this.ctx.lineTo(boxX + L, boxY);
            this.ctx.moveTo(boxX + screenW - L, boxY); this.ctx.lineTo(boxX + screenW, boxY); this.ctx.lineTo(boxX + screenW, boxY + L);
            this.ctx.moveTo(boxX + screenW, boxY + screenH - L); this.ctx.lineTo(boxX + screenW, boxY + screenH); this.ctx.lineTo(boxX + screenW - L, boxY + screenH);
            this.ctx.moveTo(boxX + L, boxY + screenH); this.ctx.lineTo(boxX, boxY + screenH); this.ctx.lineTo(boxX, boxY + screenH - L);
            this.ctx.stroke();

            // --- 2. Draw Lock Line ---
            this.ctx.beginPath();
            this.ctx.moveTo(cx, cy);
            this.ctx.lineTo(screenX, screenY);
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 1;
            this.ctx.globalAlpha = isLocked ? 0.8 : 0.3; // จางๆ ถ้าไม่ได้ล็อก
            this.ctx.setLineDash([4, 4]);
            this.ctx.stroke();
            this.ctx.globalAlpha = 1.0;
            this.ctx.setLineDash([]);

            // --- 3. Text Info ---
            this.ctx.fillStyle = color;
            this.ctx.font = isLocked ? "bold 14px monospace" : "10px monospace";
            const distM = (1.7 * 800) / t.h; // Distance Calc
            this.ctx.fillText(`ID_${t.id} [${distM.toFixed(1)}m]`, boxX, boxY - 10);
            
            // --- 4. Prediction Dot (จุดทำนายอนาคต) ---
            // แสดงจุดที่ AI คิดว่าวัตถุจะไปต่อ
            const predX = (t.x + t.vx * 5) * sx;
            const predY = (t.y + t.vy * 5) * sy;
            this.ctx.fillStyle = '#fff';
            this.ctx.beginPath();
            this.ctx.arc(predX, predY, 2, 0, Math.PI*2);
            this.ctx.fill();
        });

        // Update Lock Status Text
        const lockMsg = document.getElementById('lock-msg');
        const lockVal = document.getElementById('locked');
        if (lockedTarget && minCenterDist < 150) {
            lockMsg.innerText = "LOCKED";
            lockMsg.style.color = "#ff2a6d";
            lockVal.innerText = lockedTarget.class.toUpperCase();
            lockVal.style.color = "#ff2a6d";
        } else {
            lockMsg.innerText = "SCANNING";
            lockMsg.style.color = "rgba(255,255,255,0.5)";
            lockVal.innerText = "NONE";
            lockVal.style.color = "#fff";
        }

        this.updateRadar(tracks, video.videoWidth);
    }

    updateRadar(tracks, vw) {
        // Clear radar
        const old = this.radar.querySelectorAll('.blip');
        old.forEach(el => el.remove());

        tracks.forEach(t => {
            const blip = document.createElement('div');
            blip.className = 'blip';
            
            // Map Screen X -> Angle, Screen Y -> Radius
            const angleRatio = (t.x / vw) - 0.5; // -0.5 to 0.5
            const angle = angleRatio * (CONFIG.PHYSICS.FOV * Math.PI / 180);
            
            const distM = (1.7 * 800) / t.h;
            const r = Math.min(distM * 3, 65); // Scale radius (max 65px)

            // Polar to Cartesian
            const rx = 70 + Math.sin(angle) * r;
            const ry = 70 - Math.cos(angle) * r;

            blip.style.left = rx + 'px';
            blip.style.top = ry + 'px';
            if (t.class === 'person') {
                blip.style.background = '#ffae00';
                blip.style.boxShadow = '0 0 5px #ffae00';
            }
            this.radar.appendChild(blip);
        });
    }
}

// --- MAIN SYSTEM ---
class System {
    constructor() {
        this.video = document.getElementById('camera-feed');
        this.tracker = new PredictiveTracker();
        this.hud = new HUDRenderer();
        this.model = null;
        this.isRunning = false;

        window.onresize = () => this.hud.resize();
    }

    async start() {
        const btn = document.getElementById('btn-start');
        btn.innerText = "LOADING AI CORE...";
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: {ideal: 1280}, height: {ideal: 720} },
                audio: false
            });
            this.video.srcObject = stream;
            await new Promise(r => this.video.onloadedmetadata = () => { this.video.play(); r(); });

            this.model = await cocoSsd.load({base: 'lite_mobilenet_v2'}); // Load Lite for speed
            
            document.getElementById('boot').style.display = 'none';
            this.isRunning = true;
            this.loop();
        } catch(e) {
            alert("Error: " + e.message);
        }
    }

    async loop() {
        if(!this.isRunning) return;
        const start = performance.now();

        // 1. Detect
        const detections = await this.model.detect(this.video, 20, CONFIG.AI_CONFIDENCE);
        
        // 2. Predictive Track
        const tracks = this.tracker.update(detections, this.video.videoWidth, this.video.videoHeight);
        
        // 3. Render
        this.hud.render(this.video, tracks);
        
        // 4. Stats
        const ms = Math.round(performance.now() - start);
        document.getElementById('fps').innerText = Math.round(1000/Math.max(1, ms));
        document.getElementById('ms').innerText = ms;
        document.getElementById('count').innerText = tracks.length;

        requestAnimationFrame(() => this.loop());
    }
}

const OMEGA = new System();
document.getElementById('btn-start').style.display = 'block';

</script>
</body>
</html>
