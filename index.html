<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OMEGA ULTIMATE: GPS Enhanced AI System</title>
    
    <!-- LIBRARIES -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@1.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@0.0.1"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css">

    <style>
        :root {
            --primary: #00ff9d; --secondary: #008f7a; --alert: #ff2a6d; 
            --warning: #ffcc00; --bg: #050505; --glass: rgba(0, 20, 10, 0.85);
            --font: 'Segoe UI', system-ui, sans-serif;
        }
        body { margin: 0; overflow: hidden; background: var(--bg); color: var(--primary); font-family: var(--font); }
        
        #viewport { position: relative; width: 100vw; height: 100vh; }
        #camera-feed { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0.6; }
        #hud-canvas { position: absolute; inset: 0; z-index: 10; }
        #layer-3d { position: absolute; inset: 0; z-index: 5; pointer-events: none; opacity: 0.7; }
        
        /* UI LAYERS */
        #ui-layer { position: absolute; inset: 0; z-index: 20; padding: 20px; display: flex; flex-direction: column; justify-content: space-between; pointer-events: none; }
        
        .panel {
            background: var(--glass); border-left: 4px solid var(--primary);
            padding: 15px; margin: 5px; backdrop-filter: blur(10px);
            pointer-events: auto; width: fit-content; border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.2);
            max-width: 300px;
        }
        .panel-title { font-size: 10px; font-weight: bold; color: #00a8ff; letter-spacing: 2px; margin-bottom: 5px; }
        .data-row { font-family: monospace; font-size: 12px; margin-bottom: 2px; display: flex; justify-content: space-between; min-width: 150px; }
        .val { font-weight: bold; color: #fff; }

        /* GPS MAP */
        #gps-map { 
            position: absolute; 
            bottom: 20px; 
            left: 20px; 
            width: 300px; 
            height: 200px;
            background: var(--glass);
            border: 2px solid var(--primary);
            border-radius: 10px;
            z-index: 25;
            pointer-events: auto;
        }

        /* RADAR */
        #radar-box {
            position: absolute; bottom: 20px; right: 20px; width: 150px; height: 150px;
            background: rgba(0,20,10,0.9); border-radius: 50%; border: 2px solid #00a8ff;
            overflow: hidden; pointer-events: auto; z-index: 30;
        }
        .blip { position: absolute; width: 6px; height: 6px; background: var(--alert); border-radius: 50%; transform: translate(-50%,-50%); box-shadow: 0 0 5px var(--alert); transition: all 0.2s; }

        /* BOOT SCREEN */
        #boot { position: fixed; inset: 0; background: #000; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .btn { padding: 15px 40px; background: var(--primary); border: none; font-weight: bold; cursor: pointer; margin-top: 20px; border-radius: 30px; }
        
        /* CONTROL PANEL */
        #controls { display: none; position: absolute; top: 60px; left: 20px; background: rgba(0,0,0,0.9); padding: 10px; pointer-events: auto; z-index: 40; border: 1px solid var(--primary); }
        .ctrl-btn { background: #333; color: var(--primary); border: 1px solid var(--primary); padding: 5px 10px; margin: 2px; cursor: pointer; font-size: 10px; }
        .ctrl-btn:hover { background: var(--primary); color: #000; }
        .ctrl-btn.active { background: var(--primary); color: #000; }

        /* VOICE INDICATOR */
        #voice-ind { position: absolute; top: 20px; right: 20px; background: var(--alert); color: white; padding: 5px 10px; border-radius: 15px; font-size: 10px; display: none; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } }

        /* POSE VISUALIZATION */
        .pose-point { position: absolute; width: 8px; height: 8px; background: #ff00ff; border-radius: 50%; z-index: 15; }
        .pose-line { position: absolute; background: #ff00ff; height: 2px; transform-origin: 0 0; z-index: 14; }

        /* FACE EMOTION */
        .emotion-display { position: absolute; background: rgba(255,42,109,0.8); color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; z-index: 16; }
    </style>
</head>
<body>

    <div id="viewport">
        <video id="camera-feed" autoplay playsinline muted></video>
        <canvas id="layer-3d"></canvas>
        <canvas id="hud-canvas"></canvas>
        
        <div id="ui-layer">
            <div style="display: flex; gap: 10px;">
                <div class="panel">
                    <div class="panel-title">SYSTEM STATUS</div>
                    <div class="data-row"><span>CPU:</span><span class="val" id="v-cpu">0ms</span></div>
                    <div class="data-row"><span>FPS:</span><span class="val" id="v-fps">0</span></div>
                    <div class="data-row"><span>TRACKS:</span><span class="val" id="v-tracks">0</span></div>
                    <div class="data-row"><span>GPS:</span><span class="val" id="v-gps">Acquiring...</span></div>
                </div>
                <div class="panel">
                    <div class="panel-title">PHYSICS & BIO</div>
                    <div class="data-row"><span>SPEED:</span><span class="val" id="v-spd">0 m/s</span></div>
                    <div class="data-row"><span>HDG:</span><span class="val" id="v-hdg">0Â°</span></div>
                    <div class="data-row"><span>POSE TRACK:</span><span class="val" id="v-pose">0</span></div>
                    <div class="data-row"><span>FACES:</span><span class="val" id="v-faces">0</span></div>
                </div>
            </div>

            <div class="panel" style="position: absolute; top: 50%; right: 20px; transform: translateY(-50%);">
                <div class="panel-title">TARGET LOCK</div>
                <div class="data-row"><span>TYPE:</span><span class="val" id="t-type">--</span></div>
                <div class="data-row"><span>DIST:</span><span class="val" id="t-dist">--</span></div>
                <div class="data-row"><span>EMOTION:</span><span class="val" id="t-emotion">--</span></div>
                <div class="data-row"><span>THREAT:</span><span class="val" id="t-threat" style="color:var(--primary)">LOW</span></div>
            </div>

            <!-- GPS MAP -->
            <div id="gps-map"></div>

            <!-- RADAR -->
            <div id="radar-box">
                <div style="position:absolute; inset:0; background: conic-gradient(transparent 270deg, #00a8ff); opacity: 0.3; animation: scan 3s linear infinite;"></div>
            </div>
        </div>

        <div style="position: absolute; top: 20px; left: 20px; z-index: 50;">
            <button onclick="document.getElementById('controls').style.display = 'block'" style="background:black; color:var(--primary); border:1px solid var(--primary); padding:5px;">CONTROLS</button>
        </div>

        <div id="controls">
            <div class="panel-title">COMMAND CENTER</div>
            <button class="ctrl-btn" onclick="OMEGA.voice.toggle()">VOICE CMD</button>
            <button class="ctrl-btn" onclick="OMEGA.recorder.toggle()">RECORD MISSION</button>
            <button class="ctrl-btn" onclick="OMEGA.toggleGPS()">GPS TRACKING</button>
            <button class="ctrl-btn" onclick="OMEGA.togglePose()">POSE DETECT</button>
            <button class="ctrl-btn" onclick="OMEGA.toggleFace()">FACE ANALYSIS</button>
            <button class="ctrl-btn" onclick="document.getElementById('controls').style.display='none'">CLOSE</button>
        </div>

        <div id="voice-ind">MIC ACTIVE</div>
    </div>

    <div id="boot">
        <h1 style="color:var(--primary); letter-spacing: 5px; text-shadow: 0 0 20px var(--primary);">OMEGA ULTIMATE</h1>
        <div style="color: #666; font-family: monospace;">LOADING ENHANCED KERNEL...</div>
        <button id="btn-init" class="btn" disabled>INITIALIZING...</button>
    </div>

<script>
/**
 * ðŸš€ OMEGA ULTIMATE: Enhanced with GPS, Pose & Face Detection
 */

const CONFIG = {
    AI: { CONFIDENCE: 0.6, MAX_OBJ: 15 },
    PHYSICS: { FOV: 60, FOCAL_LEN: 800, PERSON_H: 1.7 },
    TRACKING: { MAX_LOST: 10, IOU_THRESH: 0.4 },
    GPS: { UPDATE_INTERVAL: 5000 }
};

// --- ENHANCED PHYSICS SYSTEM ---
const Physics = {
    iou: (b1, b2) => {
        const x1 = Math.max(b1[0], b2[0]), y1 = Math.max(b1[1], b2[1]);
        const x2 = Math.min(b1[0]+b1[2], b2[0]+b2[2]), y2 = Math.min(b1[1]+b1[3], b2[1]+b2[3]);
        const inter = Math.max(0, x2-x1) * Math.max(0, y2-y1);
        return inter / ((b1[2]*b1[3]) + (b2[2]*b2[3]) - inter);
    },
    getDist: (h) => (CONFIG.PHYSICS.PERSON_H * CONFIG.PHYSICS.FOCAL_LEN) / h,
    project3D: (x, y, d, w, h) => {
        const nx = (x - w/2) / (w/2), ny = -(y - h/2) / (h/2);
        const tan = Math.tan((CONFIG.PHYSICS.FOV/2) * Math.PI/180);
        return { x: nx * d * tan * (w/h), y: ny * d * tan, z: -d };
    },
    // GPS-based distance calculation
    gpsDistance: (lat1, lon1, lat2, lon2) => {
        const R = 6371e3; // Earth's radius in meters
        const Ï†1 = lat1 * Math.PI/180, Ï†2 = lat2 * Math.PI/180;
        const Î”Ï† = (lat2-lat1) * Math.PI/180, Î”Î» = (lon2-lon1) * Math.PI/180;
        
        const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                Math.cos(Ï†1) * Math.cos(Ï†2) *
                Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        
        return R * c;
    }
};

// --- ENHANCED TRACKER WITH BIOMETRICS ---
class EnhancedTracker {
    constructor() {
        this.tracks = [];
        this.nextId = 1;
        this.poseDetector = null;
        this.faceDetector = null;
    }

    async initDetectors() {
        try {
            // Initialize Pose Detection
            this.poseDetector = await poseDetection.createDetector(
                poseDetection.SupportedModels.MoveNet
            );
            
            // Initialize Face Detection
            this.faceDetector = await faceLandmarksDetection.createDetector(
                faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh
            );
        } catch(e) {
            console.warn("Advanced detectors not available:", e);
        }
    }

    update(detections, w, h) {
        let newTracks = [];
        detections.forEach(det => {
            let best = null, maxIOU = 0;
            
            this.tracks.forEach(t => {
                const val = Physics.iou(det.bbox, t.bbox);
                if(val > maxIOU) { maxIOU = val; best = t; }
            });

            const dist = Physics.getDist(det.bbox[3]);
            const cx = det.bbox[0] + det.bbox[2]/2;
            const cy = det.bbox[1] + det.bbox[3]/2;
            const world = Physics.project3D(cx, cy, dist, w, h);

            if(best && maxIOU > CONFIG.TRACKING.IOU_THRESH) {
                best.bbox = det.bbox; best.score = det.score; best.lost = 0;
                best.dist = dist; best.world = world;
                best.vel = { x: world.x - (best.prev?.x||world.x), z: world.z - (best.prev?.z||world.z) };
                best.prev = world;
                newTracks.push(best);
            } else {
                newTracks.push({
                    id: this.nextId++, bbox: det.bbox, class: det.class, score: det.score,
                    lost: 0, dist: dist, world: world, vel: {x:0, z:0}, prev: world,
                    pose: null, face: null, emotion: 'neutral', biometrics: {}
                });
            }
        });

        this.tracks.forEach(t => {
            if(t.lost < CONFIG.TRACKING.MAX_LOST && !newTracks.find(nt => nt.id === t.id)) {
                t.lost++;
                newTracks.push(t);
            }
        });
        
        this.tracks = newTracks;
        return this.tracks;
    }

    // Enhanced with pose data
    async updatePoses(video) {
        if (!this.poseDetector) return;
        
        try {
            const poses = await this.poseDetector.estimatePoses(video);
            this.tracks.forEach(track => {
                if (track.class === 'person') {
                    // Simple pose assignment logic (in real app, use better matching)
                    track.pose = poses[0] || null;
                }
            });
        } catch(e) {
            console.warn("Pose detection failed:", e);
        }
    }

    // Enhanced with face analysis
    async updateFaces(video) {
        if (!this.faceDetector) return;
        
        try {
            const faces = await this.faceDetector.estimateFaces(video);
            this.tracks.forEach(track => {
                if (track.class === 'person') {
                    track.face = faces[0] || null;
                    // Simple emotion detection based on facial landmarks
                    if (track.face) {
                        track.emotion = this.analyzeEmotion(track.face);
                    }
                }
            });
        } catch(e) {
            console.warn("Face detection failed:", e);
        }
    }

    analyzeEmotion(face) {
        // Simplified emotion analysis based on landmark positions
        // In real application, use proper emotion detection model
        const landmarks = face.keypoints;
        if (landmarks.length < 10) return 'neutral';
        
        // Mock emotion analysis
        const emotions = ['happy', 'neutral', 'surprised', 'angry'];
        return emotions[Math.floor(Math.random() * emotions.length)];
    }
}

// --- GPS TRACKING SYSTEM ---
class GPSTracker {
    constructor() {
        this.watchId = null;
        this.currentPos = null;
        this.trackedPoints = [];
        this.map = null;
        this.marker = null;
        this.isActive = false;
    }

    initMap() {
        this.map = L.map('gps-map').setView([0, 0], 16);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap'
        }).addTo(this.map);
        
        this.marker = L.marker([0, 0]).addTo(this.map)
            .bindPopup("Current Position")
            .openPopup();
    }

    startTracking() {
        if (!navigator.geolocation) {
            alert("GPS not supported");
            return;
        }

        this.isActive = true;
        this.watchId = navigator.geolocation.watchPosition(
            (position) => {
                this.currentPos = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    speed: position.coords.speed || 0,
                    heading: position.coords.heading || 0,
                    timestamp: position.timestamp
                };
                
                this.updateMap();
                this.trackedPoints.push({...this.currentPos});
                
                document.getElementById('v-gps').innerHTML = 
                    `${this.currentPos.lat.toFixed(6)}, ${this.currentPos.lng.toFixed(6)}`;
                document.getElementById('v-spd').innerText = 
                    `${(this.currentPos.speed || 0).toFixed(1)} m/s`;
                document.getElementById('v-hdg').innerText = 
                    `${(this.currentPos.heading || 0).toFixed(0)}Â°`;
                    
            },
            (error) => {
                console.error("GPS Error:", error);
                document.getElementById('v-gps').innerText = "GPS Error";
            },
            {
                enableHighAccuracy: true,
                timeout: 5000,
                maximumAge: 0
            }
        );
    }

    stopTracking() {
        if (this.watchId) {
            navigator.geolocation.clearWatch(this.watchId);
            this.watchId = null;
        }
        this.isActive = false;
        document.getElementById('v-gps').innerText = "GPS Off";
    }

    updateMap() {
        if (!this.map || !this.currentPos) return;
        
        this.map.setView([this.currentPos.lat, this.currentPos.lng]);
        this.marker.setLatLng([this.currentPos.lat, this.currentPos.lng]);
        
        // Add tracking line
        if (this.trackedPoints.length > 1) {
            const line = L.polyline(this.trackedPoints.map(p => [p.lat, p.lng]), {
                color: '#00ff9d',
                weight: 3
            }).addTo(this.map);
        }
    }
}

// --- ENHANCED 3D SCENE WITH BIOMETRICS ---
class EnhancedScene3D {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({canvas: document.getElementById('layer-3d'), alpha:true});
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Enhanced grid with GPS coordinates
        const grid = new THREE.GridHelper(100, 50, 0x00ff9d, 0x003311);
        grid.position.y = -2;
        this.scene.add(grid);
        
        this.meshes = new Map();
        this.poseMeshes = new Map();
    }

    update(tracks) {
        const ids = tracks.map(t => t.id);
        
        // Update object meshes
        for(let [id, m] of this.meshes) {
            if(!ids.includes(id)) { this.scene.remove(m); this.meshes.delete(id); }
        }

        // Update pose meshes
        for(let [id, m] of this.poseMeshes) {
            if(!ids.includes(id)) { 
                m.forEach(item => this.scene.remove(item)); 
                this.poseMeshes.delete(id); 
            }
        }

        tracks.forEach(t => {
            // Main object mesh
            if(!this.meshes.has(t.id)) {
                const geo = new THREE.WireframeGeometry(new THREE.BoxGeometry(1, 2, 1));
                const mat = new THREE.LineBasicMaterial({color: 0x00ff9d});
                const mesh = new THREE.LineSegments(geo, mat);
                this.scene.add(mesh);
                this.meshes.set(t.id, mesh);
            }
            const mesh = this.meshes.get(t.id);
            if(t.world) mesh.position.set(t.world.x, -1, t.world.z);

            // Pose skeleton if available
            if(t.pose && t.pose.keypoints) {
                this.updatePoseSkeleton(t);
            }
        });

        this.renderer.render(this.scene, this.camera);
    }

    updatePoseSkeleton(track) {
        // Create pose skeleton in 3D space
        if (!this.poseMeshes.has(track.id)) {
            this.poseMeshes.set(track.id, []);
        }

        // Clear old pose
        this.poseMeshes.get(track.id).forEach(mesh => this.scene.remove(mesh));
        this.poseMeshes.set(track.id, []);

        // Add new pose points
        track.pose.keypoints.forEach(kp => {
            if (kp.score > 0.3) {
                const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                const material = new THREE.MeshBasicMaterial({color: 0xff00ff});
                const sphere = new THREE.Mesh(geometry, material);
                
                // Convert 2D pose to 3D (simplified)
                sphere.position.set(
                    (kp.x / 640 - 0.5) * 10,
                    -(kp.y / 480 - 0.5) * 10,
                    -track.dist * 0.1
                );
                
                this.scene.add(sphere);
                this.poseMeshes.get(track.id).push(sphere);
            }
        });
    }
}

// --- ENHANCED KERNEL WITH ALL SYSTEMS ---
class UltimateKernel {
    constructor() {
        this.video = document.getElementById('camera-feed');
        this.canvas = document.getElementById('hud-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.tracker = new EnhancedTracker();
        this.gpsTracker = new GPSTracker();
        this.voice = new VoiceSystem();
        this.recorder = new MissionRecorder();
        this.scene3D = new EnhancedScene3D();
        
        this.isRunning = false;
        this.poseEnabled = false;
        this.faceEnabled = false;
        
        this.resize();
        window.onresize = () => this.resize();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.scene3D.renderer.setSize(window.innerWidth, window.innerHeight);
        this.scene3D.camera.aspect = window.innerWidth / window.innerHeight;
        this.scene3D.camera.updateProjectionMatrix();
    }

    async boot() {
        try {
            // Load all AI models in parallel
            await Promise.all([
                this.loadObjectDetection(),
                this.tracker.initDetectors()
            ]);

            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: {ideal: 1280}, height: {ideal: 720} },
                audio: false
            });
            this.video.srcObject = stream;
            await new Promise(r => this.video.onloadedmetadata = () => { this.video.play(); r(); });

            // Initialize GPS
            this.gpsTracker.initMap();

            document.getElementById('boot').style.display = 'none';
            this.isRunning = true;
            this.loop();
        } catch(e) {
            alert("Boot Error: " + e.message);
        }
    }

    async loadObjectDetection() {
        this.model = await cocoSsd.load({base: 'lite_mobilenet_v2'});
    }

    toggleGPS() {
        if (this.gpsTracker.isActive) {
            this.gpsTracker.stopTracking();
        } else {
            this.gpsTracker.startTracking();
        }
    }

    togglePose() {
        this.poseEnabled = !this.poseEnabled;
        alert(`Pose Detection ${this.poseEnabled ? 'ENABLED' : 'DISABLED'}`);
    }

    toggleFace() {
        this.faceEnabled = !this.faceEnabled;
        alert(`Face Analysis ${this.faceEnabled ? 'ENABLED' : 'DISABLED'}`);
    }

    async loop() {
        if(!this.isRunning) return;
        const start = performance.now();

        // 1. Object Detection
        const detections = await this.model.detect(this.video, CONFIG.AI.MAX_OBJ, CONFIG.AI.CONFIDENCE);
        
        // 2. Enhanced Tracking
        const tracks = this.tracker.update(detections, this.video.videoWidth, this.video.videoHeight);
        
        // 3. Advanced AI Features
        if (this.poseEnabled) {
            await this.tracker.updatePoses(this.video);
        }
        if (this.faceEnabled) {
            await this.tracker.updateFaces(this.video);
        }

        // 4. 3D Update
        this.scene3D.update(tracks);

        // 5. Draw Enhanced HUD
        this.drawEnhancedHUD(tracks);
        this.updateUI(tracks, start);
        
        // 6. Record
        this.recorder.push({
            tracks: tracks,
            gps: this.gpsTracker.currentPos,
            timestamp: Date.now()
        });

        requestAnimationFrame(() => this.loop());
    }

    drawEnhancedHUD(tracks) {
        this.ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
        const sx = this.canvas.width / this.video.videoWidth;
        const sy = this.canvas.height / this.video.videoHeight;

        tracks.forEach(t => {
            if(t.lost > 2) return;
            const x = t.bbox[0]*sx, y = t.bbox[1]*sy, w = t.bbox[2]*sx, h = t.bbox[3]*sy;
            const color = t.class === 'person' ? '#ff2a6d' : '#00ff9d';
            
            // Bounding Box
            this.ctx.strokeStyle = color; this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x, y, w, h);
            
            // Enhanced Info
            this.ctx.fillStyle = color; this.ctx.font = "bold 12px monospace";
            this.ctx.fillText(`ID:${t.id} ${t.class.toUpperCase()}`, x, y-20);
            this.ctx.fillText(`${t.dist.toFixed(1)}m`, x, y-8);
            
            // Emotion Display
            if (t.emotion && t.class === 'person') {
                this.ctx.fillStyle = '#ffcc00';
                this.ctx.fillText(t.emotion.toUpperCase(), x, y + h + 15);
            }

            // Pose Visualization
            if (t.pose && this.poseEnabled) {
                this.drawPose(t.pose, sx, sy);
            }

            // Velocity Vector
            if(Math.abs(t.vel.x) > 0.01) {
                this.ctx.beginPath();
                this.ctx.moveTo(x+w/2, y+h/2);
                this.ctx.lineTo(x+w/2 + t.vel.x*100, y+h/2);
                this.ctx.strokeStyle = 'yellow';
                this.ctx.stroke();
            }
        });
    }

    drawPose(pose, sx, sy) {
        if (!pose.keypoints) return;
        
        pose.keypoints.forEach(kp => {
            if (kp.score > 0.3) {
                this.ctx.fillStyle = '#ff00ff';
                this.ctx.beginPath();
                this.ctx.arc(kp.x * sx, kp.y * sy, 4, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        });
    }

    updateUI(tracks, start) {
        // Performance Metrics
        const ms = Math.round(performance.now() - start);
        document.getElementById('v-cpu').innerText = ms + 'ms';
        document.getElementById('v-fps').innerText = Math.round(1000/Math.max(1, ms));
        document.getElementById('v-tracks').innerText = tracks.length;

        // Biometric Counts
        const poseCount = tracks.filter(t => t.pose).length;
        const faceCount = tracks.filter(t => t.face).length;
        document.getElementById('v-pose').innerText = poseCount;
        document.getElementById('v-faces').innerText = faceCount;

        // Target Info
        if(tracks.length > 0) {
            const t = tracks[0];
            document.getElementById('t-type').innerText = t.class.toUpperCase();
            document.getElementById('t-dist').innerText = t.dist.toFixed(1) + 'm';
            document.getElementById('t-emotion').innerText = t.emotion ? t.emotion.toUpperCase() : '--';
            
            const el = document.getElementById('t-threat');
            if(t.dist < 2 && t.class === 'person') {
                el.innerText = "CRITICAL"; el.style.color = "red";
            } else if (t.emotion === 'angry') {
                el.innerText = "WARNING"; el.style.color = "orange";
            } else {
                el.innerText = "LOW"; el.style.color = "#00ff9d";
            }
        }

        // Enhanced Radar with Biometrics
        const radar = document.getElementById('radar-box');
        const oldBlips = radar.getElementsByClassName('blip');
        while(oldBlips[0]) oldBlips[0].remove();
        
        tracks.forEach(t => {
            if(t.lost > 2) return;
            const blip = document.createElement('div');
            blip.className = 'blip';
            
            const rx = 75 + (t.world.x * 4);
            const ry = 75 + (-t.world.z * 4);
            
            if(rx > 0 && rx < 150 && ry > 0 && ry < 150) {
                blip.style.left = rx + 'px'; 
                blip.style.top = ry + 'px';
                
                // Color coding based on type and emotion
                if(t.class !== 'person') {
                    blip.style.background = '#00ff9d';
                } else if (t.emotion === 'angry') {
                    blip.style.background = 'orange';
                    blip.style.boxShadow = '0 0 8px orange';
                } else if (t.pose) {
                    blip.style.background = '#ff00ff';
                }
                
                radar.appendChild(blip);
            }
        });
    }
}

// Keep existing VoiceSystem and MissionRecorder classes from previous version
class VoiceSystem {
    constructor() {
        this.active = false;
        if('webkitSpeechRecognition' in window) {
            this.rec = new webkitSpeechRecognition();
            this.rec.continuous = false;
            this.rec.lang = 'en-US';
            this.rec.onresult = (e) => this.process(e.results[0][0].transcript);
            this.rec.onend = () => { if(this.active) this.rec.start(); };
        }
    }
    toggle() {
        this.active = !this.active;
        const ind = document.getElementById('voice-ind');
        if(this.active && this.rec) {
            this.rec.start();
            ind.style.display = 'block';
            alert("Voice: Say 'Target', 'Status', 'Record', 'GPS', 'Pose', 'Face'");
        } else {
            if(this.rec) this.rec.stop();
            ind.style.display = 'none';
        }
    }
    process(cmd) {
        console.log("Voice:", cmd);
        cmd = cmd.toLowerCase();
        if(cmd.includes('target')) alert("TARGET LOCKED");
        if(cmd.includes('status')) alert(`System OK. ${OMEGA.tracker.tracks.length} Targets.`);
        if(cmd.includes('record')) OMEGA.recorder.toggle();
        if(cmd.includes('gps')) OMEGA.toggleGPS();
        if(cmd.includes('pose')) OMEGA.togglePose();
        if(cmd.includes('face')) OMEGA.toggleFace();
    }
}

class MissionRecorder {
    constructor() { this.rec = false; this.data = []; }
    toggle() {
        this.rec = !this.rec;
        alert(this.rec ? "Recording Started..." : "Recording Saved (Console)");
        if(!this.rec) console.log(JSON.stringify(this.data));
    }
    push(data) { if(this.rec) this.data.push({t: Date.now(), ...data}); }
}

// Initialize Ultimate System
const OMEGA = new UltimateKernel();
const btn = document.getElementById('btn-init');
btn.disabled = false;
btn.innerText = "INITIALIZE ULTIMATE SYSTEM";
btn.onclick = () => {
    btn.innerText = "LOADING ENHANCED AI...";
    btn.disabled = true;
    OMEGA.boot();
};

</script>
</body>
</html>
