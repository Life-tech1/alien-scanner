<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OMEGA: ADVANCED HUMANOID VISION SYSTEM</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        :root {
            --hud-primary: #00ff41;
            --hud-secondary: #008f11;
            --hud-alert: #ff0000;
            --hud-warn: #ffcc00;
            --hud-info: #0080ff;
            --hud-critical: #ff0066;
            --bg-dark: #050505;
            --glass: rgba(0, 20, 0, 0.85);
            --glass-dark: rgba(0, 10, 0, 0.95);
            --neon-glow: 0 0 10px currentColor;
        }

        * { 
            box-sizing: border-box; 
            user-select: none; 
            -webkit-touch-callout: none; 
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0; 
            overflow: hidden; 
            background: var(--bg-dark);
            font-family: 'Courier New', 'Consolas', monospace;
            color: var(--hud-primary);
            width: 100vw; 
            height: 100vh;
            line-height: 1.2;
        }

        #viewport { 
            position: relative; 
            width: 100%; 
            height: 100%; 
        }
        
        #camera-feed {
            position: absolute; 
            width: 100%; 
            height: 100%; 
            object-fit: cover;
            z-index: 0; 
            filter: contrast(1.4) brightness(0.7) hue-rotate(90deg) saturate(1.3);
            opacity: 0.5;
        }
        
        #hud-canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 10; 
        }

        #ui-layer {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            z-index: 20; 
            pointer-events: none;
            display: flex; 
            flex-direction: column; 
            justify-content: space-between;
            padding: max(20px, env(safe-area-inset-top));
        }

        .hud-panel {
            background: var(--glass); 
            border: 1px solid var(--hud-primary);
            border-left: 3px solid var(--hud-primary);
            padding: 12px 16px; 
            margin: 8px; 
            width: fit-content;
            backdrop-filter: blur(8px);
            box-shadow: var(--neon-glow);
            clip-path: polygon(0 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 8px 100%, 0 calc(100% - 8px));
        }
        
        .hud-panel-wide {
            width: auto;
            min-width: 280px;
            max-width: 320px;
        }
        
        .panel-title {
            font-size: 11px;
            font-weight: bold;
            color: var(--hud-secondary);
            margin-bottom: 8px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        .hud-text { 
            font-size: 11px; 
            letter-spacing: 1px; 
            margin-bottom: 4px; 
            text-shadow: var(--neon-glow);
            display: flex;
            justify-content: space-between;
        }
        
        .hud-value { 
            font-weight: bold; 
            color: #fff;
            margin-left: 12px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        #radar-container {
            position: absolute; 
            bottom: 20px; 
            right: 20px;
            width: 160px; 
            height: 160px;
            border-radius: 50%;
            background: var(--glass-dark);
            border: 2px solid var(--hud-primary);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
            overflow: hidden;
            z-index: 30;
        }
        
        #radar-container::after {
            content: ''; 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: conic-gradient(from 0deg, transparent 0deg, transparent 270deg, rgba(0,255,65,0.4) 360deg);
            border-radius: 50%;
            animation: radar-scan 3s linear infinite;
        }
        
        .radar-grid {
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            border: 1px solid rgba(0,255,65,0.3); 
            border-radius: 50%; 
            pointer-events: none;
        }
        
        .radar-cross {
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            width: 100%; 
            height: 1px; 
            background: rgba(0,255,65,0.3);
        }
        
        .radar-blip {
            position: absolute; 
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: var(--neon-glow);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 2;
        }
        
        .radar-range {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            color: var(--hud-secondary);
        }
        
        @keyframes radar-scan { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }

        #boot-overlay {
            position: fixed; 
            inset: 0; 
            background: #000; 
            z-index: 9999;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            color: var(--hud-primary);
            background: radial-gradient(circle at center, #001100 0%, #000000 70%);
        }
        
        .boot-title {
            font-size: 48px;
            font-weight: 900;
            margin-bottom: 8px;
            letter-spacing: 8px;
            text-shadow: 0 0 20px var(--hud-primary);
            background: linear-gradient(90deg, var(--hud-primary), var(--hud-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .boot-subtitle {
            opacity: 0.7; 
            margin-bottom: 40px;
            font-size: 14px;
            letter-spacing: 3px;
        }
        
        #btn-init {
            background: transparent; 
            color: var(--hud-primary); 
            border: 2px solid var(--hud-primary);
            padding: 16px 60px; 
            font-family: inherit; 
            font-size: 16px; 
            font-weight: bold;
            letter-spacing: 4px; 
            cursor: pointer; 
            margin-top: 40px;
            transition: all 0.3s ease;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }
        
        #btn-init::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,65,0.4), transparent);
            transition: left 0.5s;
        }
        
        #btn-init:hover::before {
            left: 100%;
        }
        
        #btn-init:hover { 
            background: var(--hud-primary); 
            color: #000; 
            box-shadow: 0 0 30px var(--hud-primary);
        }
        
        .status-list {
            text-align: left; 
            font-size: 12px; 
            line-height: 1.8; 
            opacity: 0.9;
            margin-top: 30px;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .status-led { 
            display: inline-block; 
            width: 10px; 
            height: 10px; 
            background: #333; 
            border-radius: 50%; 
            margin-right: 12px; 
            position: relative;
        }
        
        .status-led::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            box-shadow: 0 0 8px currentColor;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .status-led.active { 
            background: var(--hud-primary);
        }
        
        .status-led.active::after {
            opacity: 1;
        }
        
        .status-led.error { 
            background: var(--hud-alert);
        }
        
        .status-led.error::after {
            opacity: 1;
        }
        
        .status-led.warning { 
            background: var(--hud-warn);
        }
        
        .status-led.warning::after {
            opacity: 1;
        }
        
        .status-led.loading {
            background: var(--hud-info);
            animation: pulse 1.5s infinite;
        }

        #system-status {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: var(--glass-dark);
            border-top: 1px solid var(--hud-secondary);
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            z-index: 25;
            backdrop-filter: blur(4px);
        }
        
        .status-section {
            display: flex;
            align-items: center;
        }
        
        .status-item-compact {
            display: flex;
            align-items: center;
            margin-right: 20px;
        }
        
        .status-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 6px;
            position: relative;
        }
        
        .status-indicator::after {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 50%;
            box-shadow: 0 0 6px currentColor;
        }
        
        .status-ok { 
            background: var(--hud-primary); 
        }
        
        .status-warn { 
            background: var(--hud-warn); 
        }
        
        .status-error { 
            background: var(--hud-alert); 
        }
        
        .status-offline { 
            background: #444; 
        }

        .target-acquisition {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 15;
            pointer-events: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes targetLock {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.7; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .critical-alert {
            animation: alertPulse 0.5s infinite;
        }

        @keyframes alertPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .hud-panel-wide {
                min-width: 250px;
                max-width: 280px;
            }
            
            #radar-container {
                width: 140px;
                height: 140px;
                bottom: 15px;
                right: 15px;
            }
            
            .boot-title {
                font-size: 36px;
                letter-spacing: 6px;
            }
        }

        @media (max-width: 480px) {
            .hud-panel {
                padding: 8px 12px;
            }
            
            .status-grid {
                grid-template-columns: 1fr;
            }
            
            #system-status {
                flex-direction: column;
                gap: 4px;
            }
        }
    </style>
</head>
<body>

    <div id="viewport">
        <video id="camera-feed" autoplay playsinline muted></video>
        <canvas id="hud-canvas"></canvas>
        
        <div id="ui-layer">
            <!-- Top Row: System Status -->
            <div style="display:flex; justify-content:space-between; width:100%;">
                <div class="hud-panel">
                    <div class="panel-title">SYSTEM METRICS</div>
                    <div class="hud-text">INFERENCE CPU: <span id="val-cpu" class="hud-value">0</span> ms</div>
                    <div class="hud-text">VISION FPS: <span id="val-fps" class="hud-value">0</span></div>
                    <div class="hud-text">ACTIVE TRACKS: <span id="val-tracked" class="hud-value">0</span></div>
                </div>
                
                <div class="hud-panel">
                    <div class="panel-title">AVIONICS</div>
                    <div class="hud-text">PITCH: <span id="val-pitch" class="hud-value">0.0°</span></div>
                    <div class="hud-text">ROLL: <span id="val-roll" class="hud-value">0.0°</span></div>
                    <div class="hud-text">HEADING: <span id="val-heading" class="hud-value">0.0°</span></div>
                    <div class="hud-text">G-FORCE: <span id="val-g" class="hud-value">1.00</span></div>
                </div>
            </div>
            
            <!-- Middle: Analytics -->
            <div class="hud-panel hud-panel-wide" style="margin-top: auto; margin-bottom: 180px;">
                <div class="panel-title">TACTICAL ANALYTICS</div>
                <div class="hud-text">ACTIVE OBJECTS: <span id="val-active" class="hud-value">0</span></div>
                <div class="hud-text">PERSON DETECTIONS (5M): <span id="val-persons" class="hud-value">0</span></div>
                <div class="hud-text">CLOSEST PERSON: <span id="val-closest-person" class="hud-value">--</span></div>
                <div class="hud-text">DOMINANT CLASS: <span id="val-top-label" class="hud-value">--</span></div>
            </div>
            
            <!-- Target Acquisition -->
            <div class="hud-panel hud-panel-wide" style="margin-left: auto; margin-right: 180px;">
                <div class="panel-title">PRIMARY TARGET</div>
                <div class="hud-text">CLASS: <span id="val-target-label" class="hud-value">--</span></div>
                <div class="hud-text">DISTANCE: <span id="val-target-dist" class="hud-value">--</span></div>
                <div class="hud-text">BEARING: <span id="val-target-bearing" class="hud-value">--</span></div>
                <div class="hud-text">MOTION STATE: <span id="val-target-state" class="hud-value">--</span></div>
                <div class="hud-text">CONFIDENCE: <span id="val-target-conf" class="hud-value">--</span></div>
            </div>

            <!-- Radar -->
            <div id="radar-container">
                <div class="radar-grid" style="width: 33%; height: 33%;"></div>
                <div class="radar-grid" style="width: 66%; height: 66%;"></div>
                <div class="radar-cross"></div>
                <div class="radar-cross" style="transform: translate(-50%, -50%) rotate(90deg);"></div>
                <div id="radar-blips"></div>
                <div class="radar-range">RANGE: 50M</div>
            </div>
        </div>
        
        <!-- System Status Bar -->
        <div id="system-status">
            <div class="status-section">
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-cam"></span>
                    <span>OPTICAL_SENSORS</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-ai"></span>
                    <span>NEURAL_ENGINE</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-gyro"></span>
                    <span>AVIONICS</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-tracker"></span>
                    <span>TRACKER</span>
                </div>
                <div class="status-item-compact">
                    <span class="status-indicator" id="status-memory"></span>
                    <span>KNOWLEDGE_BASE</span>
                </div>
            </div>
            <div class="status-section">
                <span id="status-message">SYSTEM_STANDBY</span>
            </div>
        </div>
    </div>

    <!-- Boot Screen -->
    <div id="boot-overlay">
        <div class="boot-title">OMEGA</div>
        <div class="boot-subtitle">ADVANCED HUMANOID VISION SYSTEM</div>
        
        <div class="status-list">
            <div class="status-item">
                <span class="status-led" id="led-cam"></span>
                <span>OPTICAL SENSOR ARRAY</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-ai"></span>
                <span>DEEP NEURAL NETWORK (COCO-SSD)</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-gyro"></span>
                <span>INERTIAL NAVIGATION SYSTEM</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-tracker"></span>
                <span>MULTI-OBJECT TRACKER</span>
            </div>
            <div class="status-item">
                <span class="status-led" id="led-memory"></span>
                <span>KNOWLEDGE BASE & ANALYTICS</span>
            </div>
        </div>
        
        <button id="btn-init">INITIALIZE SYSTEM</button>
    </div>

<script>
/**
 * OMEGA: ADVANCED HUMANOID VISION SYSTEM
 * Aerospace-Grade Architecture
 * World-Class Engineering Standards
 * 
 * Mathematical Rigor: Kalman Filtering, Coordinate Transforms, Physics-Based Modeling
 * AI Architecture: Modular, Extensible, Real-Time Processing
 * UX/UI: Human Factors Engineering, Information Hierarchy, Situational Awareness
 */

// ============================================================================
// MATHEMATICAL CONSTANTS & PHYSICAL PARAMETERS
// ============================================================================

const MATHEMATICAL_CONSTANTS = {
    GRAVITY: 9.80665, // m/s² (standard gravity)
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,
    EARTH_RADIUS: 6371000, // meters
    SPEED_OF_LIGHT: 299792458 // m/s
};

// ============================================================================
// CONFIGURATION MODULE - Aerospace Grade Parameters
// ============================================================================

/**
 * Global system configuration with physically accurate parameters
 * @namespace
 */
const CONFIG = {
    // AI Model Configuration
    AI: {
        MODEL_TYPE: 'lite_mobilenet_v2',
        CONFIDENCE_THRESHOLD: 0.65, // Higher threshold for reliability
        MAX_DETECTIONS: 25,
        INFERENCE_RATE: 12, // Hz - Optimized for mobile processing
        KALMAN_PROCESS_NOISE: 0.1,
        KALMAN_MEASUREMENT_NOISE: 0.5
    },
    
    // Tracking Configuration - Based on real tracking systems
    TRACKING: {
        MAX_AGE: 45, // frames before track deletion
        MIN_IOU: 0.4, // stricter association threshold
        MAX_ASSOCIATION_DISTANCE: 0.3, // normalized screen distance
        VELOCITY_SMOOTHING: 0.85,
        KALMAN_ENABLED: true,
        COASTING_FRAMES: 10 // frames to maintain track without measurements
    },
    
    // Physics & Sensor Configuration - Real-world parameters
    PHYSICS: {
        HORIZONTAL_FOV: 67.5, // degrees (typical smartphone camera)
        VERTICAL_FOV: 52.5,   // degrees
        MAX_RANGE: 50,        // meters
        MIN_RANGE: 0.5,       // meters
        PERSON_HEIGHT: 1.75,  // meters (average human)
        VEHICLE_HEIGHT: 1.6,  // meters (typical car height)
        DEPTH_ESTIMATION_METHOD: 'PERSPECTIVE', // 'PERSPECTIVE' or 'SIZE_BASED'
        
        // Motion classification thresholds (m/s)
        APPROACH_THRESHOLD: 0.15,
        RECEDE_THRESHOLD: -0.1,
        STATIC_THRESHOLD: 0.05,
        
        // Coordinate transformation parameters
        CAMERA_HEIGHT: 1.2, // meters (typical handheld height)
        PIXEL_TO_METER_RATIO: 0.001 // approximate conversion
    },
    
    // Radar Configuration - Based on real radar displays
    RADAR: {
        RANGE: 50, // meters
        AZIMUTH_RESOLUTION: 2, // degrees
        BLOB_SIZE_MIN: 4,
        BLOB_SIZE_MAX: 12,
        SWEEP_PERIOD: 3, // seconds
        PERSISTENCE: 0.7 // trail persistence factor
    },
    
    // Memory & Analytics Configuration
    MEMORY: {
        MAX_EVENTS: 2000,
        RETENTION_PERIOD: 3600000, // 1 hour in milliseconds
        ANALYTICS_UPDATE_RATE: 5, // Hz
        TREND_ANALYSIS_WINDOW: 300000 // 5 minutes for trend analysis
    },
    
    // UI Configuration - Human Factors Engineering
    UI: {
        UPDATE_RATE: 30, // Hz - Smooth visual updates
        STATUS_UPDATE_RATE: 10, // Hz - System status updates
        ALERT_DISPLAY_TIME: 5000, // ms
        COLOR_CODING: {
            CRITICAL: '#ff0066',
            HIGH: '#ff0000',
            MEDIUM: '#ffcc00',
            LOW: '#00ff41',
            INFO: '#0080ff'
        }
    },
    
    // System Performance Parameters
    PERFORMANCE: {
        TARGET_FRAME_TIME: 16.67, // ms (60 FPS)
        MAX_FRAME_TIME: 33.33,    // ms (30 FPS minimum)
        MEMORY_USAGE_LIMIT: 50,   // MB
        PROCESSING_PRIORITY: 'BALANCED' // 'PERFORMANCE' or 'BATTERY'
    }
};

// ============================================================================
// ADVANCED MATHEMATICAL UTILITIES
// ============================================================================

/**
 * Advanced mathematical and physics utilities
 * @namespace
 */
const AdvancedMath = {
    /**
     * 2D Vector class for mathematical operations
     */
    Vector2: class {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        
        add(v) { return new AdvancedMath.Vector2(this.x + v.x, this.y + v.y); }
        subtract(v) { return new AdvancedMath.Vector2(this.x - v.x, this.y - v.y); }
        multiply(scalar) { return new AdvancedMath.Vector2(this.x * scalar, this.y * scalar); }
        dot(v) { return this.x * v.x + this.y * v.y; }
        magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); }
        normalize() { 
            const mag = this.magnitude();
            return mag > 0 ? this.multiply(1 / mag) : new AdvancedMath.Vector2();
        }
        distanceTo(v) { return this.subtract(v).magnitude(); }
        clone() { return new AdvancedMath.Vector2(this.x, this.y); }
    },
    
    /**
     * 3D Vector class for spatial calculations
     */
    Vector3: class {
        constructor(x = 0, y = 0, z = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        
        // Vector operations
        add(v) { return new AdvancedMath.Vector3(this.x + v.x, this.y + v.y, this.z + v.z); }
        subtract(v) { return new AdvancedMath.Vector3(this.x - v.x, this.y - v.y, this.z - v.z); }
        multiply(scalar) { return new AdvancedMath.Vector3(this.x * scalar, this.y * scalar, this.z * scalar); }
        dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
        cross(v) { 
            return new AdvancedMath.Vector3(
                this.y * v.z - this.z * v.y,
                this.z * v.x - this.x * v.z,
                this.x * v.y - this.y * v.x
            );
        }
        magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }
        normalize() { 
            const mag = this.magnitude();
            return mag > 0 ? this.multiply(1 / mag) : new AdvancedMath.Vector3();
        }
        
        // Coordinate transformations
        toSpherical() {
            const r = this.magnitude();
            const theta = Math.acos(this.z / r); // inclination
            const phi = Math.atan2(this.y, this.x); // azimuth
            return { r, theta, phi };
        }
        
        fromSpherical(r, theta, phi) {
            return new AdvancedMath.Vector3(
                r * Math.sin(theta) * Math.cos(phi),
                r * Math.sin(theta) * Math.sin(phi),
                r * Math.cos(theta)
            );
        }
    },
    
    /**
     * Kalman Filter for state estimation
     */
    KalmanFilter: class {
        constructor(processNoise = 0.1, measurementNoise = 0.5, initialState = 0) {
            this.processNoise = processNoise;
            this.measurementNoise = measurementNoise;
            this.state = initialState;
            this.uncertainty = 1.0;
            this.isInitialized = false;
        }
        
        update(measurement) {
            if (!this.isInitialized) {
                this.state = measurement;
                this.isInitialized = true;
                return this.state;
            }
            
            // Prediction update
            const predictedUncertainty = this.uncertainty + this.processNoise;
            
            // Measurement update
            const kalmanGain = predictedUncertainty / (predictedUncertainty + this.measurementNoise);
            this.state = this.state + kalmanGain * (measurement - this.state);
            this.uncertainty = (1 - kalmanGain) * predictedUncertainty;
            
            return this.state;
        }
        
        reset() {
            this.isInitialized = false;
            this.uncertainty = 1.0;
        }
    },
    
    /**
     * Coordinate transformation utilities
     */
    CoordinateTransformer: class {
        constructor(screenWidth, screenHeight, fovHorizontal, fovVertical) {
            this.screenWidth = screenWidth;
            this.screenHeight = screenHeight;
            this.fovHorizontal = fovHorizontal * MATHEMATICAL_CONSTANTS.DEG_TO_RAD;
            this.fovVertical = fovVertical * MATHEMATICAL_CONSTANTS.DEG_TO_RAD;
            
            // Calculate focal lengths
            this.focalLengthX = (screenWidth / 2) / Math.tan(this.fovHorizontal / 2);
            this.focalLengthY = (screenHeight / 2) / Math.tan(this.fovVertical / 2);
        }
        
        /**
         * Convert screen coordinates to world bearing angles
         */
        screenToBearing(screenX, screenY) {
            const normalizedX = (screenX - this.screenWidth / 2) / this.focalLengthX;
            const normalizedY = (screenY - this.screenHeight / 2) / this.focalLengthY;
            
            const bearingX = Math.atan(normalizedX) * MATHEMATICAL_CONSTANTS.RAD_TO_DEG;
            const bearingY = Math.atan(normalizedY) * MATHEMATICAL_CONSTANTS.RAD_TO_DEG;
            
            return { azimuth: bearingX, elevation: bearingY };
        }
        
        /**
         * Estimate world coordinates from screen position and depth
         */
        screenToWorld(screenX, screenY, depth) {
            const bearing = this.screenToBearing(screenX, screenY);
            const azimuthRad = bearing.azimuth * MATHEMATICAL_CONSTANTS.DEG_TO_RAD;
            const elevationRad = bearing.elevation * MATHEMATICAL_CONSTANTS.DEG_TO_RAD;
            
            const x = depth * Math.sin(azimuthRad);
            const y = depth * Math.sin(elevationRad);
            const z = depth * Math.cos(azimuthRad) * Math.cos(elevationRad);
            
            return new AdvancedMath.Vector3(x, y, z);
        }
    },
    
    /**
     * Statistical analysis utilities
     */
    Statistics: {
        mean(values) {
            return values.reduce((sum, val) => sum + val, 0) / values.length;
        },
        
        standardDeviation(values) {
            const mean = this.mean(values);
            const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
            return Math.sqrt(this.mean(squaredDiffs));
        },
        
        exponentialMovingAverage(current, previous, alpha) {
            return alpha * current + (1 - alpha) * previous;
        },
        
        trendAnalysis(data, windowSize) {
            if (data.length < windowSize) return 0;
            
            const recent = data.slice(-windowSize);
            const x = recent.map((_, i) => i);
            const y = recent;
            
            // Linear regression
            const n = windowSize;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((a, b, i) => a + b * y[i], 0);
            const sumXX = x.reduce((a, b) => a + b * b, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            return slope;
        }
    },
    
    /**
     * Physics-based calculations
     */
    Physics: {
        /**
         * Estimate depth using perspective projection
         */
        estimateDepth(bboxHeight, screenHeight, physicalHeight, cameraHeight = CONFIG.PHYSICS.CAMERA_HEIGHT) {
            // Perspective projection formula: depth = (f * H) / h
            // where f is focal length, H is physical height, h is apparent height
            const focalLength = (screenHeight / 2) / Math.tan(CONFIG.PHYSICS.VERTICAL_FOV * MATHEMATICAL_CONSTANTS.DEG_TO_RAD / 2);
            const apparentHeight = bboxHeight;
            const depth = (focalLength * physicalHeight) / apparentHeight;
            
            // Adjust for camera height using similar triangles
            const groundDistance = Math.sqrt(Math.pow(depth, 2) - Math.pow(cameraHeight, 2));
            
            return Math.max(CONFIG.PHYSICS.MIN_RANGE, Math.min(CONFIG.PHYSICS.MAX_RANGE, groundDistance));
        },
        
        /**
         * Calculate relative velocity from screen motion
         */
        calculateScreenVelocity(prevPosition, currentPosition, deltaTime) {
            if (!prevPosition || deltaTime === 0) return new AdvancedMath.Vector2(0, 0);
            
            const dx = currentPosition.x - prevPosition.x;
            const dy = currentPosition.y - prevPosition.y;
            
            return new AdvancedMath.Vector2(dx / deltaTime, dy / deltaTime);
        },
        
        /**
         * Convert screen velocity to world velocity
         */
        screenToWorldVelocity(screenVelocity, depth, coordinateTransformer) {
            // Simplified conversion - in real system would use full camera model
            const scale = depth * CONFIG.PHYSICS.PIXEL_TO_METER_RATIO;
            return new AdvancedMath.Vector2(
                screenVelocity.x * scale,
                screenVelocity.y * scale
            );
        }
    }
};

// ============================================================================
// SENSOR FUSION & AVIONICS MODULE
// ============================================================================

/**
 * Advanced sensor fusion with Kalman filtering
 * @class
 */
class AdvancedAvionics {
    constructor() {
        this.orientation = { pitch: 0, roll: 0, heading: 0 };
        this.acceleration = new AdvancedMath.Vector3(0, 0, 0);
        this.rotationRate = new AdvancedMath.Vector3(0, 0, 0);
        this.gForce = 1.0;
        
        // Kalman filters for sensor fusion
        this.kalmanPitch = new AdvancedMath.KalmanFilter(0.1, 0.5);
        this.kalmanRoll = new AdvancedMath.KalmanFilter(0.1, 0.5);
        this.kalmanHeading = new AdvancedMath.KalmanFilter(0.5, 1.0);
        
        // Sensor status
        this.isAvailable = false;
        this.isCalibrated = false;
        this.calibrationSamples = [];
        this.calibrationRequired = 10;
        
        // Coordinate system
        this.referenceFrame = 'ENU'; // East-North-Up
    }

    /**
     * Initialize sensor systems with calibration
     */
    async init() {
        try {
            if (!this._checkSensorAvailability()) {
                throw new Error("Inertial sensors not available");
            }
            
            // Request permissions
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                const permission = await DeviceOrientationEvent.requestPermission();
                if (permission !== 'granted') {
                    throw new Error("Sensor permissions denied");
                }
            }
            
            // Set up sensor event listeners
            this._setupOrientationListener();
            this._setupMotionListener();
            
            this.isAvailable = true;
            console.log("AdvancedAvionics: Sensor system initialized");
            
            // Begin calibration
            this._startCalibration();
            
            return true;
            
        } catch (error) {
            console.error("AdvancedAvionics: Initialization failed -", error);
            this.isAvailable = false;
            return false;
        }
    }

    /**
     * Check for sensor availability
     */
    _checkSensorAvailability() {
        return !!(window.DeviceOrientationEvent && window.DeviceMotionEvent);
    }

    /**
     * Set up orientation sensor listening
     */
    _setupOrientationListener() {
        window.addEventListener('deviceorientation', (event) => {
            if (!this.isCalibrated && this.calibrationSamples.length < this.calibrationRequired) {
                this.calibrationSamples.push({
                    pitch: event.beta,
                    roll: event.gamma,
                    heading: event.alpha
                });
                
                if (this.calibrationSamples.length >= this.calibrationRequired) {
                    this._completeCalibration();
                }
                return;
            }
            
            // Apply Kalman filtering to orientation data
            const filteredPitch = this.kalmanPitch.update(event.beta || 0);
            const filteredRoll = this.kalmanRoll.update(event.gamma || 0);
            const filteredHeading = this.kalmanHeading.update(event.alpha || 0);
            
            this.orientation = {
                pitch: this._normalizeAngle(filteredPitch),
                roll: this._normalizeAngle(filteredRoll),
                heading: this._normalizeAngle(filteredHeading)
            };
            
            this.rotationRate = new AdvancedMath.Vector3(
                event.rotationRate.alpha || 0,
                event.rotationRate.beta || 0,
                event.rotationRate.gamma || 0
            );
        });
    }

    /**
     * Set up motion sensor listening
     */
    _setupMotionListener() {
        window.addEventListener('devicemotion', (event) => {
            const accel = event.accelerationIncludingGravity;
            if (!accel) return;
            
            this.acceleration = new AdvancedMath.Vector3(
                accel.x || 0,
                accel.y || 0,
                accel.z || 0
            );
            
            // Calculate G-force magnitude
            const accelMagnitude = this.acceleration.magnitude();
            this.gForce = accelMagnitude / MATHEMATICAL_CONSTANTS.GRAVITY;
        });
    }

    /**
     * Complete sensor calibration
     */
    _completeCalibration() {
        const avgPitch = AdvancedMath.Statistics.mean(this.calibrationSamples.map(s => s.pitch));
        const avgRoll = AdvancedMath.Statistics.mean(this.calibrationSamples.map(s => s.roll));
        
        // Set calibration offsets
        this.calibrationOffset = {
            pitch: avgPitch,
            roll: avgRoll
        };
        
        this.isCalibrated = true;
        console.log("AdvancedAvionics: Sensor calibration complete");
    }

    /**
     * Normalize angle to -180 to 180 range
     */
    _normalizeAngle(angle) {
        return ((angle + 180) % 360) - 180;
    }

    /**
     * Get current orientation with calibration applied
     */
    getOrientation() {
        if (!this.isCalibrated) return this.orientation;
        
        return {
            pitch: this.orientation.pitch - this.calibrationOffset.pitch,
            roll: this.orientation.roll - this.calibrationOffset.roll,
            heading: this.orientation.heading
        };
    }

    /**
     * Get motion data with physics-based processing
     */
    getMotion() {
        return {
            acceleration: this.acceleration.clone(),
            gForce: this.gForce,
            rotationRate: this.rotationRate.clone()
        };
    }

    /**
     * Get system status
     */
    getStatus() {
        return {
            isAvailable: this.isAvailable,
            isCalibrated: this.isCalibrated,
            calibrationProgress: this.calibrationSamples.length / this.calibrationRequired
        };
    }
}

// ============================================================================
// ADVANCED VISION ENGINE WITH PHYSICS-BASED PROCESSING
// ============================================================================

/**
 * Advanced vision engine with mathematical rigor
 * @class
 */
class AdvancedVisionEngine {
    constructor() {
        this.model = null;
        this.isModelLoaded = false;
        this.inferenceStats = {
            totalInferences: 0,
            averageTime: 0,
            lastTime: 0,
            fps: 0
        };
        this.coordinateTransformer = null;
    }

    /**
     * Initialize vision engine with coordinate transformation
     */
    async init() {
        try {
            await tf.ready();
            this.model = await cocoSsd.load({ 
                base: CONFIG.AI.MODEL_TYPE 
            });
            
            // Initialize coordinate transformer
            this.coordinateTransformer = new AdvancedMath.CoordinateTransformer(
                window.innerWidth,
                window.innerHeight,
                CONFIG.PHYSICS.HORIZONTAL_FOV,
                CONFIG.PHYSICS.VERTICAL_FOV
            );
            
            this.isModelLoaded = true;
            console.log("AdvancedVisionEngine: Model loaded with coordinate transformation");
            return true;
            
        } catch (error) {
            console.error("AdvancedVisionEngine: Initialization failed -", error);
            this.isModelLoaded = false;
            return false;
        }
    }

    /**
     * Perform object detection with physics-based processing
     */
    async detect(videoElement) {
        if (!this.model || !this.isModelLoaded || videoElement.readyState !== 4) {
            return [];
        }
        
        const startTime = performance.now();
        
        try {
            const detections = await this.model.detect(
                videoElement, 
                CONFIG.AI.MAX_DETECTIONS, 
                CONFIG.AI.CONFIDENCE_THRESHOLD
            );
            
            const processingTime = performance.now() - startTime;
            this._updateInferenceStats(processingTime);
            
            // Enhance detections with physics-based data
            return this._enhanceDetections(detections);
            
        } catch (error) {
            console.error("AdvancedVisionEngine: Detection failed -", error);
            return [];
        }
    }

    /**
     * Enhance detections with physics and coordinate data
     */
    _enhanceDetections(detections) {
        return detections.map(detection => {
            const bbox = detection.bbox;
            const centerX = bbox[0] + bbox[2] / 2;
            const centerY = bbox[1] + bbox[3] / 2;
            
            // Calculate bearing angles
            const bearing = this.coordinateTransformer.screenToBearing(centerX, centerY);
            
            // Estimate depth based on object type
            const depth = this._estimateObjectDepth(detection.class, bbox[3]);
            
            return {
                ...detection,
                physics: {
                    screenPosition: new AdvancedMath.Vector2(centerX, centerY),
                    bearing: bearing,
                    estimatedDepth: depth,
                    normalizedPosition: {
                        x: (centerX / window.innerWidth) * 2 - 1,
                        y: (centerY / window.innerHeight) * 2 - 1
                    }
                }
            };
        });
    }

    /**
     * Estimate object depth using physics-based methods
     */
    _estimateObjectDepth(objectClass, bboxHeight) {
        let physicalHeight;
        
        switch (objectClass) {
            case 'person':
                physicalHeight = CONFIG.PHYSICS.PERSON_HEIGHT;
                break;
            case 'car':
            case 'truck':
            case 'bus':
                physicalHeight = CONFIG.PHYSICS.VEHICLE_HEIGHT;
                break;
            default:
                physicalHeight = 1.0; // Default assumption
        }
        
        return AdvancedMath.Physics.estimateDepth(
            bboxHeight,
            window.innerHeight,
            physicalHeight
        );
    }

    /**
     * Update inference performance statistics
     */
    _updateInferenceStats(processingTime) {
        this.inferenceStats.totalInferences++;
        this.inferenceStats.lastTime = processingTime;
        this.inferenceStats.averageTime = AdvancedMath.Statistics.exponentialMovingAverage(
            processingTime,
            this.inferenceStats.averageTime,
            0.95
        );
        this.inferenceStats.fps = 1000 / Math.max(1, this.inferenceStats.averageTime);
    }

    /**
     * Get engine status and performance metrics
     */
    getStatus() {
        return {
            isModelLoaded: this.isModelLoaded,
            ...this.inferenceStats
        };
    }
}

// ============================================================================
// KALMAN-BASED MULTI-OBJECT TRACKER
// ============================================================================

/**
 * Advanced multi-object tracker with Kalman filtering
 * @class
 */
class AdvancedObjectTracker {
    constructor() {
        this.tracks = new Map();
        this.nextTrackId = 1;
        this.frameCount = 0;
        this.coordinateTransformer = new AdvancedMath.CoordinateTransformer(
            window.innerWidth,
            window.innerHeight,
            CONFIG.PHYSICS.HORIZONTAL_FOV,
            CONFIG.PHYSICS.VERTICAL_FOV
        );
    }

    /**
     * Update tracks with new detections using advanced data association
     */
    update(detections, timestamp) {
        this.frameCount++;
        
        // Convert detections to track format
        const currentDetections = detections.map(det => this._detectionToTrack(det, timestamp));
        
        // Predict existing tracks
        this._predictTracks(timestamp);
        
        // Data association using Hungarian algorithm
        const assignments = this._associateDetections(currentDetections);
        
        // Update assigned tracks
        this._updateAssignedTracks(assignments, currentDetections, timestamp);
        
        // Create new tracks for unassigned detections
        this._createNewTracks(assignments.unassignedDetections, currentDetections, timestamp);
        
        // Remove stale tracks
        this._removeStaleTracks(timestamp);
        
        return this.getActiveTracks();
    }

    /**
     * Convert detection to track format
     */
    _detectionToTrack(detection, timestamp) {
        return {
            detection: detection,
            physics: detection.physics,
            timestamp: timestamp,
            bbox: {
                x: detection.bbox[0],
                y: detection.bbox[1],
                width: detection.bbox[2],
                height: detection.bbox[3]
            }
        };
    }

    /**
     * Predict existing tracks using Kalman filtering
     */
    _predictTracks(timestamp) {
        for (const [trackId, track] of this.tracks) {
            if (track.status === 'coasting') {
                // Use motion model to predict position
                this._predictTrackPosition(track, timestamp);
            }
        }
    }

    /**
     * Predict track position using constant velocity model
     */
    _predictTrackPosition(track, timestamp) {
        if (!track.kalmanFilter || !track.lastUpdateTime) return;
        
        const deltaTime = (timestamp - track.lastUpdateTime) / 1000;
        
        // Simple constant velocity prediction
        if (track.velocity && deltaTime > 0) {
            track.bbox.x += track.velocity.x * deltaTime;
            track.bbox.y += track.velocity.y * deltaTime;
        }
    }

    /**
     * Associate detections to tracks using advanced metrics
     */
    _associateDetections(detections) {
        const assignments = {
            matches: [],
            unassignedDetections: [...detections.keys()],
            unassignedTracks: []
        };
        
        const activeTracks = this.getActiveTracks();
        
        if (activeTracks.length === 0 || detections.length === 0) {
            return assignments;
        }
        
        // Calculate cost matrix
        const costMatrix = this._calculateCostMatrix(activeTracks, detections);
        
        // Simple greedy assignment (replace with Hungarian algorithm for production)
        for (let i = 0; i < activeTracks.length; i++) {
            let bestMatch = -1;
            let bestScore = CONFIG.TRACKING.MIN_IOU;
            
            for (let j = 0; j < detections.length; j++) {
                if (assignments.unassignedDetections.includes(j)) {
                    const score = costMatrix[i][j];
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = j;
                    }
                }
            }
            
            if (bestMatch !== -1) {
                assignments.matches.push({ trackIndex: i, detectionIndex: bestMatch });
                assignments.unassignedDetections = assignments.unassignedDetections.filter(idx => idx !== bestMatch);
            } else {
                assignments.unassignedTracks.push(i);
            }
        }
        
        return assignments;
    }

    /**
     * Calculate cost matrix for data association
     */
    _calculateCostMatrix(tracks, detections) {
        const matrix = [];
        
        for (let i = 0; i < tracks.length; i++) {
            matrix[i] = [];
            const track = tracks[i];
            
            for (let j = 0; j < detections.length; j++) {
                const detection = detections[j];
                
                // Calculate IoU
                const iou = this._calculateIoU(track.bbox, detection.bbox);
                
                // Calculate center distance
                const trackCenter = new AdvancedMath.Vector2(
                    track.bbox.x + track.bbox.width / 2,
                    track.bbox.y + track.bbox.height / 2
                );
                const detCenter = new AdvancedMath.Vector2(
                    detection.bbox.x + detection.bbox.width / 2,
                    detection.bbox.y + detection.bbox.height / 2
                );
                const distance = trackCenter.distanceTo(detCenter) / Math.sqrt(window.innerWidth * window.innerHeight);
                
                // Combined score (IoU weighted higher)
                const score = iou * 0.7 + (1 - distance) * 0.3;
                matrix[i][j] = score;
            }
        }
        
        return matrix;
    }

    /**
     * Calculate Intersection over Union
     */
    _calculateIoU(bbox1, bbox2) {
        const x1 = Math.max(bbox1.x, bbox2.x);
        const y1 = Math.max(bbox1.y, bbox2.y);
        const x2 = Math.min(bbox1.x + bbox1.width, bbox2.x + bbox2.width);
        const y2 = Math.min(bbox1.y + bbox1.height, bbox2.y + bbox2.height);
        
        const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
        const area1 = bbox1.width * bbox1.height;
        const area2 = bbox2.width * bbox2.height;
        const union = area1 + area2 - intersection;
        
        return union > 0 ? intersection / union : 0;
    }

    /**
     * Update tracks with assigned detections
     */
    _updateAssignedTracks(assignments, detections, timestamp) {
        for (const match of assignments.matches) {
            const track = this.getActiveTracks()[match.trackIndex];
            const detection = detections[match.detectionIndex];
            
            this._updateTrack(track, detection, timestamp);
        }
    }

    /**
     * Update individual track with new detection
     */
    _updateTrack(track, detection, timestamp) {
        const deltaTime = (timestamp - track.lastUpdateTime) / 1000;
        
        // Update Kalman filter
        if (CONFIG.TRACKING.KALMAN_ENABLED) {
            if (!track.kalmanFilter) {
                track.kalmanFilter = {
                    x: new AdvancedMath.KalmanFilter(),
                    y: new AdvancedMath.KalmanFilter(),
                    width: new AdvancedMath.KalmanFilter(),
                    height: new AdvancedMath.KalmanFilter()
                };
            }
            
            track.bbox.x = track.kalmanFilter.x.update(detection.bbox.x);
            track.bbox.y = track.kalmanFilter.y.update(detection.bbox.y);
            track.bbox.width = track.kalmanFilter.width.update(detection.bbox.width);
            track.bbox.height = track.kalmanFilter.height.update(detection.bbox.height);
        } else {
            // Exponential moving average
            const alpha = 0.7;
            track.bbox.x = AdvancedMath.Statistics.exponentialMovingAverage(detection.bbox.x, track.bbox.x, alpha);
            track.bbox.y = AdvancedMath.Statistics.exponentialMovingAverage(detection.bbox.y, track.bbox.y, alpha);
            track.bbox.width = AdvancedMath.Statistics.exponentialMovingAverage(detection.bbox.width, track.bbox.width, alpha);
            track.bbox.height = AdvancedMath.Statistics.exponentialMovingAverage(detection.bbox.height, track.bbox.height, alpha);
        }
        
        // Update velocity
        if (track.lastPosition && deltaTime > 0) {
            track.velocity = AdvancedMath.Physics.calculateScreenVelocity(
                track.lastPosition,
                new AdvancedMath.Vector2(track.bbox.x + track.bbox.width / 2, track.bbox.y + track.bbox.height / 2),
                deltaTime
            );
        }
        
        // Update track properties
        track.lastPosition = new AdvancedMath.Vector2(
            track.bbox.x + track.bbox.width / 2,
            track.bbox.y + track.bbox.height / 2
        );
        track.lastUpdateTime = timestamp;
        track.status = 'active';
        track.consecutiveMisses = 0;
        
        // Update physics data
        track.physics = detection.physics;
        track.label = detection.detection.class;
        track.confidence = detection.detection.score;
    }

    /**
     * Create new tracks for unassigned detections
     */
    _createNewTracks(unassignedIndices, detections, timestamp) {
        for (const index of unassignedIndices) {
            const detection = detections[index];
            const trackId = this.nextTrackId++;
            
            this.tracks.set(trackId, {
                id: trackId,
                bbox: { ...detection.bbox },
                physics: detection.physics,
                label: detection.detection.class,
                confidence: detection.detection.score,
                firstSeen: timestamp,
                lastUpdateTime: timestamp,
                lastPosition: new AdvancedMath.Vector2(
                    detection.bbox.x + detection.bbox.width / 2,
                    detection.bbox.y + detection.bbox.height / 2
                ),
                status: 'new',
                consecutiveMisses: 0,
                velocity: new AdvancedMath.Vector2(0, 0)
            });
        }
    }

    /**
     * Remove stale tracks
     */
    _removeStaleTracks(timestamp) {
        for (const [trackId, track] of this.tracks) {
            const timeSinceUpdate = timestamp - track.lastUpdateTime;
            const maxAge = CONFIG.TRACKING.MAX_AGE * (1000 / CONFIG.AI.INFERENCE_RATE);
            
            if (timeSinceUpdate > maxAge) {
                this.tracks.delete(trackId);
            } else if (timeSinceUpdate > (1000 / CONFIG.AI.INFERENCE_RATE)) {
                track.status = 'coasting';
                track.consecutiveMisses++;
            }
        }
    }

    /**
     * Get active tracks
     */
    getActiveTracks() {
        return Array.from(this.tracks.values()).filter(track => 
            track.status !== 'coasting' || track.consecutiveMisses < CONFIG.TRACKING.COASTING_FRAMES
        );
    }

    /**
     * Get tracker statistics
     */
    getStats() {
        const activeTracks = this.getActiveTracks();
        return {
            totalTracks: this.tracks.size,
            activeTracks: activeTracks.length,
            newTracks: activeTracks.filter(t => t.status === 'new').length,
            frameCount: this.frameCount
        };
    }
}

// ============================================================================
// ADVANCED PHYSICS ENGINE
// ============================================================================

/**
 * Advanced physics engine with rigorous mathematical modeling
 * @class
 */
class AdvancedPhysicsEngine {
    constructor() {
        this.screenWidth = window.innerWidth;
        this.screenHeight = window.innerHeight;
        this.coordinateTransformer = new AdvancedMath.CoordinateTransformer(
            this.screenWidth,
            this.screenHeight,
            CONFIG.PHYSICS.HORIZONTAL_FOV,
            CONFIG.PHYSICS.VERTICAL_FOV
        );
        
        window.addEventListener('resize', () => {
            this.screenWidth = window.innerWidth;
            this.screenHeight = window.innerHeight;
            this.coordinateTransformer = new AdvancedMath.CoordinateTransformer(
                this.screenWidth,
                this.screenHeight,
                CONFIG.PHYSICS.HORIZONTAL_FOV,
                CONFIG.PHYSICS.VERTICAL_FOV
            );
        });
    }

    /**
     * Analyze tracks with advanced physics modeling
     */
    analyze(tracks) {
        return tracks.map(track => {
            const enhanced = { ...track };
            
            // Calculate advanced screen metrics
            enhanced.screenMetrics = this._calculateScreenMetrics(track);
            
            // Calculate world coordinates
            enhanced.worldPosition = this._calculateWorldPosition(track);
            
            // Calculate motion analysis
            enhanced.motionAnalysis = this._analyzeMotion(track);
            
            // Calculate threat assessment
            enhanced.threatAssessment = this._assessThreat(track);
            
            return enhanced;
        });
    }

    /**
     * Calculate detailed screen metrics
     */
    _calculateScreenMetrics(track) {
        const centerX = track.bbox.x + track.bbox.width / 2;
        const centerY = track.bbox.y + track.bbox.height / 2;
        
        return {
            center: new AdvancedMath.Vector2(centerX, centerY),
            normalizedPosition: {
                x: (centerX / this.screenWidth) * 2 - 1,
                y: (centerY / this.screenHeight) * 2 - 1
            },
            screenCoverage: (track.bbox.width * track.bbox.height) / (this.screenWidth * this.screenHeight),
            aspectRatio: track.bbox.width / track.bbox.height
        };
    }

    /**
     * Calculate world position using coordinate transformation
     */
    _calculateWorldPosition(track) {
        const screenMetrics = this._calculateScreenMetrics(track);
        const depth = track.physics.estimatedDepth;
        
        const worldPos = this.coordinateTransformer.screenToWorld(
            screenMetrics.center.x,
            screenMetrics.center.y,
            depth
        );
        
        // Calculate bearing and elevation
        const bearing = this.coordinateTransformer.screenToBearing(
            screenMetrics.center.x,
            screenMetrics.center.y
        );
        
        return {
            position: worldPos,
            bearing: bearing,
            distance: depth,
            spherical: worldPos.toSpherical()
        };
    }

    /**
     * Analyze object motion with physics-based calculations
     */
    _analyzeMotion(track) {
        if (!track.velocity || track.status === 'new') {
            return {
                screenVelocity: new AdvancedMath.Vector2(0, 0),
                worldVelocity: new AdvancedMath.Vector3(0, 0, 0),
                speed: 0,
                motionState: 'unknown',
                radialVelocity: 0
            };
        }
        
        // Calculate world velocity
        const worldVelocity = AdvancedMath.Physics.screenToWorldVelocity(
            track.velocity,
            track.physics.estimatedDepth,
            this.coordinateTransformer
        );
        
        // Calculate radial velocity (approaching/receding)
        // Simplified: use vertical screen motion as proxy
        const radialVelocity = -track.velocity.y / this.screenHeight;
        
        // Classify motion state
        let motionState = 'static';
        if (Math.abs(radialVelocity) > CONFIG.PHYSICS.APPROACH_THRESHOLD) {
            motionState = radialVelocity > 0 ? 'approaching' : 'receding';
        } else if (track.velocity.magnitude() > CONFIG.PHYSICS.STATIC_THRESHOLD) {
            motionState = 'moving';
        }
        
        return {
            screenVelocity: track.velocity.clone(),
            worldVelocity: worldVelocity,
            speed: worldVelocity.magnitude(),
            motionState: motionState,
            radialVelocity: radialVelocity
        };
    }

    /**
     * Assess threat level based on multiple factors
     */
    _assessThreat(track) {
        let threatLevel = 'LOW';
        let confidence = 0;
        
        // Factors for threat assessment
        const factors = {
            proximity: Math.max(0, 1 - (track.physics.estimatedDepth / CONFIG.PHYSICS.MAX_RANGE)),
            size: (track.bbox.width * track.bbox.height) / (this.screenWidth * this.screenHeight),
            motion: track.motionAnalysis?.motionState === 'approaching' ? 1 : 0,
            class: track.label === 'person' ? 0.8 : track.label === 'car' ? 0.6 : 0.3,
            confidence: track.confidence
        };
        
        // Weighted threat score
        const threatScore = (
            factors.proximity * 0.3 +
            factors.size * 0.2 +
            factors.motion * 0.25 +
            factors.class * 0.15 +
            factors.confidence * 0.1
        );
        
        // Classify threat level
        if (threatScore > 0.7) {
            threatLevel = 'HIGH';
            confidence = threatScore;
        } else if (threatScore > 0.4) {
            threatLevel = 'MEDIUM';
            confidence = threatScore;
        } else {
            threatLevel = 'LOW';
            confidence = 1 - threatScore;
        }
        
        return {
            level: threatLevel,
            score: threatScore,
            confidence: confidence,
            factors: factors
        };
    }
}

// ============================================================================
// ADVANCED RADAR SYSTEM WITH PHYSICS-BASED RENDERING
// ============================================================================

/**
 * Advanced radar system with realistic rendering
 * @class
 */
class AdvancedRadarSystem {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.width = 160;
        this.height = 160;
        this.center = new AdvancedMath.Vector2(this.width / 2, this.height / 2);
        this.maxRadius = this.width / 2 - 8;
        this.sweepAngle = 0;
        this.trails = new Map();
    }

    /**
     * Update radar display with advanced rendering
     */
    update(tracks) {
        this._updateSweep();
        this._updateTrails(tracks);
        this._renderRadar(tracks);
    }

    /**
     * Update radar sweep animation
     */
    _updateSweep() {
        this.sweepAngle += (360 / (CONFIG.RADAR.SWEEP_PERIOD * 60)) * 2; // 2x speed for smoothness
        if (this.sweepAngle >= 360) this.sweepAngle = 0;
    }

    /**
     * Update object trails for persistence
     */
    _updateTrails(tracks) {
        // Fade existing trails
        for (const [trackId, trail] of this.trails) {
            trail.opacity *= CONFIG.RADAR.PERSISTENCE;
            if (trail.opacity < 0.1) {
                this.trails.delete(trackId);
            }
        }
        
        // Update trails with current positions
        for (const track of tracks) {
            const radarPos = this._worldToRadar(track.worldPosition);
            this.trails.set(track.id, {
                position: radarPos,
                opacity: 1.0,
                type: track.label,
                motion: track.motionAnalysis.motionState
            });
        }
    }

    /**
     * Convert world coordinates to radar display coordinates
     */
    _worldToRadar(worldPosition) {
        const bearing = worldPosition.bearing.azimuth;
        const distance = worldPosition.distance;
        
        // Convert to radar coordinates (polar to Cartesian)
        const angle = bearing * MATHEMATICAL_CONSTANTS.DEG_TO_RAD;
        const range = (distance / CONFIG.RADAR.RANGE) * this.maxRadius;
        
        const x = this.center.x + range * Math.sin(angle);
        const y = this.center.y - range * Math.cos(angle); // Y inverted for display
        
        return new AdvancedMath.Vector2(x, y);
    }

    /**
     * Render complete radar display
     */
    _renderRadar(tracks) {
        // Clear previous blips
        this.container.innerHTML = '';
        
        // Add grid and crosshairs
        this._renderRadarBackground();
        
        // Render trails
        this._renderTrails();
        
        // Render current blips
        this._renderBlips(tracks);
        
        // Add range indicator
        this._renderRangeIndicator();
    }

    /**
     * Render radar background with grid
     */
    _renderRadarBackground() {
        // Range rings
        for (let i = 1; i <= 3; i++) {
            const ring = document.createElement('div');
            ring.className = 'radar-grid';
            ring.style.width = `${(i * 33)}%`;
            ring.style.height = `${(i * 33)}%`;
            this.container.appendChild(ring);
        }
        
        // Crosshairs
        const crosshair1 = document.createElement('div');
        crosshair1.className = 'radar-cross';
        this.container.appendChild(crosshair1);
        
        const crosshair2 = document.createElement('div');
        crosshair2.className = 'radar-cross';
        crosshair2.style.transform = 'translate(-50%, -50%) rotate(90deg)';
        this.container.appendChild(crosshair2);
    }

    /**
     * Render object trails
     */
    _renderTrails() {
        for (const [trackId, trail] of this.trails) {
            if (trail.opacity < 0.2) continue;
            
            const trailBlip = document.createElement('div');
            trailBlip.className = 'radar-blip';
            trailBlip.style.left = `${trail.position.x}px`;
            trailBlip.style.top = `${trail.position.y}px`;
            trailBlip.style.width = '3px';
            trailBlip.style.height = '3px';
            trailBlip.style.backgroundColor = this._getColorForType(trail.type);
            trailBlip.style.opacity = trail.opacity * 0.5;
            this.container.appendChild(trailBlip);
        }
    }

    /**
     * Render current object blips
     */
    _renderBlips(tracks) {
        for (const track of tracks) {
            const radarPos = this._worldToRadar(track.worldPosition);
            const blip = this._createBlip(track, radarPos);
            this.container.appendChild(blip);
        }
    }

    /**
     * Create individual radar blip
     */
    _createBlip(track, position) {
        const blip = document.createElement('div');
        blip.className = 'radar-blip';
        blip.style.left = `${position.x}px`;
        blip.style.top = `${position.y}px`;
        
        // Size based on object type and motion
        const baseSize = this._getBaseSize(track.label);
        const motionSize = this._getMotionSize(track.motionAnalysis.motionState);
        const size = baseSize + motionSize;
        
        blip.style.width = `${size}px`;
        blip.style.height = `${size}px`;
        blip.style.backgroundColor = this._getColorForType(track.label);
        
        // Add animation for approaching objects
        if (track.motionAnalysis.motionState === 'approaching') {
            blip.style.animation = 'pulse 1s infinite';
        }
        
        // Add threat level indication
        if (track.threatAssessment.level === 'HIGH') {
            blip.classList.add('critical-alert');
        }
        
        return blip;
    }

    /**
     * Get base blip size based on object type
     */
    _getBaseSize(label) {
        switch (label) {
            case 'person': return CONFIG.RADAR.BLOB_SIZE_MIN;
            case 'car': case 'truck': case 'bus': return CONFIG.RADAR.BLOB_SIZE_MAX;
            default: return (CONFIG.RADAR.BLOB_SIZE_MIN + CONFIG.RADAR.BLOB_SIZE_MAX) / 2;
        }
    }

    /**
     * Get size modifier based on motion state
     */
    _getMotionSize(motionState) {
        switch (motionState) {
            case 'approaching': return 3;
            case 'receding': return -1;
            default: return 0;
        }
    }

    /**
     * Get color based on object type
     */
    _getColorForType(label) {
        switch (label) {
            case 'person': return CONFIG.UI.COLOR_CODING.HIGH;
            case 'car': case 'truck': case 'bus': return CONFIG.UI.COLOR_CODING.MEDIUM;
            default: return CONFIG.UI.COLOR_CODING.LOW;
        }
    }

    /**
     * Render range indicator
     */
    _renderRangeIndicator() {
        const range = document.createElement('div');
        range.className = 'radar-range';
        range.textContent = `RANGE: ${CONFIG.RADAR.RANGE}M`;
        this.container.appendChild(range);
    }
}

// ============================================================================
// INTELLIGENT KNOWLEDGE BASE WITH ANALYTICS
// ============================================================================

/**
 * Intelligent knowledge base with advanced analytics
 * @class
 */
class IntelligentKnowledgeBase {
    constructor() {
        this.events = [];
        this.objectHistory = new Map();
        this.trends = {
            objectFrequency: new Map(),
            motionPatterns: new Map(),
            spatialDistribution: new Map()
        };
        this.analytics = {
            startTime: Date.now(),
            totalDetections: 0,
            objectStatistics: new Map(),
            threatAssessments: []
        };
        
        this._initializeAnalytics();
    }

    /**
     * Initialize analytics system
     */
    _initializeAnalytics() {
        // Set up periodic analytics updates
        setInterval(() => {
            this._updateTrendAnalysis();
        }, CONFIG.MEMORY.ANALYTICS_UPDATE_RATE * 1000);
    }

    /**
     * Record event with comprehensive metadata
     */
    recordEvent(type, data, timestamp = Date.now()) {
        const event = {
            id: this._generateEventId(),
            type: type,
            data: this._enhanceEventData(data),
            timestamp: timestamp,
            metadata: {
                systemState: this._getSystemState(),
                confidence: this._calculateEventConfidence(data)
            }
        };
        
        this.events.push(event);
        this._maintainEventLimit();
        this._updateObjectHistory(event);
        this._updateAnalytics(event);
        
        return event.id;
    }

    /**
     * Enhance event data with additional context
     */
    _enhanceEventData(data) {
        return {
            ...data,
            contextual: {
                timeOfDay: new Date().getHours(),
                activityLevel: this._calculateActivityLevel(),
                environmentalFactors: this._assessEnvironmentalFactors()
            }
        };
    }

    /**
     * Calculate current system activity level
     */
    _calculateActivityLevel() {
        const recentEvents = this.getEventsInLast(30000); // 30 seconds
        return Math.min(1, recentEvents.length / 50); // Normalize to 0-1
    }

    /**
     * Assess environmental factors
     */
    _assessEnvironmentalFactors() {
        // Placeholder for environmental assessment
        // In real system, would incorporate lighting, weather, etc.
        return {
            visibility: 1.0,
            stability: 0.8,
            complexity: 0.3
        };
    }

    /**
     * Calculate confidence for event
     */
    _calculateEventConfidence(data) {
        let confidence = 0.5; // Base confidence
        
        if (data.confidence) confidence += data.confidence * 0.3;
        if (data.trackAge > 10) confidence += 0.2;
        if (data.motionState === 'static') confidence += 0.1;
        
        return Math.min(1, confidence);
    }

    /**
     * Generate unique event ID
     */
    _generateEventId() {
        return `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Maintain event storage limits
     */
    _maintainEventLimit() {
        while (this.events.length > CONFIG.MEMORY.MAX_EVENTS) {
            this.events.shift();
        }
        
        // Remove old events
        const cutoff = Date.now() - CONFIG.MEMORY.RETENTION_PERIOD;
        this.events = this.events.filter(event => event.timestamp >= cutoff);
    }

    /**
     * Update object history
     */
    _updateObjectHistory(event) {
        if (!event.data.objectId) return;
        
        const objectId = event.data.objectId;
        if (!this.objectHistory.has(objectId)) {
            this.objectHistory.set(objectId, []);
        }
        
        const history = this.objectHistory.get(objectId);
        history.push(event);
        
        // Maintain history limits
        if (history.length > 100) {
            history.shift();
        }
    }

    /**
     * Update analytics data
     */
    _updateAnalytics(event) {
        this.analytics.totalDetections++;
        
        // Update object statistics
        if (event.data.label) {
            const stats = this.analytics.objectStatistics.get(event.data.label) || {
                count: 0,
                totalConfidence: 0,
                firstSeen: event.timestamp,
                lastSeen: event.timestamp
            };
            
            stats.count++;
            stats.totalConfidence += event.data.confidence || 0;
            stats.lastSeen = event.timestamp;
            
            this.analytics.objectStatistics.set(event.data.label, stats);
        }
        
        // Update threat assessments
        if (event.data.threatLevel) {
            this.analytics.threatAssessments.push({
                level: event.data.threatLevel,
                score: event.data.threatScore,
                timestamp: event.timestamp,
                objectId: event.data.objectId
            });
            
            // Maintain threat assessment history
            if (this.analytics.threatAssessments.length > 100) {
                this.analytics.threatAssessments.shift();
            }
        }
    }

    /**
     * Update trend analysis
     */
    _updateTrendAnalysis() {
        const recentEvents = this.getEventsInLast(CONFIG.MEMORY.TREND_ANALYSIS_WINDOW);
        
        // Analyze object frequency trends
        this._analyzeFrequencyTrends(recentEvents);
        
        // Analyze motion patterns
        this._analyzeMotionPatterns(recentEvents);
        
        // Analyze spatial distribution
        this._analyzeSpatialDistribution(recentEvents);
    }

    /**
     * Analyze frequency trends
     */
    _analyzeFrequencyTrends(events) {
        const frequencyData = events.map(event => ({
            timestamp: event.timestamp,
            label: event.data.label
        }));
        
        // Group by time windows and calculate frequencies
        // Implementation would include time-series analysis
    }

    /**
     * Analyze motion patterns
     */
    _analyzeMotionPatterns(events) {
        const motionEvents = events.filter(event => 
            event.data.motionState && event.data.motionState !== 'unknown'
        );
        
        // Analyze motion state distributions and transitions
    }

    /**
     * Analyze spatial distribution
     */
    _analyzeSpatialDistribution(events) {
        const spatialEvents = events.filter(event => 
            event.data.worldPosition && event.data.worldPosition.position
        );
        
        // Analyze spatial clustering and distributions
    }

    /**
     * Get events within time window
     */
    getEventsInLast(timeWindowMs) {
        const cutoff = Date.now() - timeWindowMs;
        return this.events.filter(event => event.timestamp >= cutoff);
    }

    /**
     * Get active object count with advanced filtering
     */
    getActiveObjectCount() {
        const recentEvents = this.getEventsInLast(5000); // 5 seconds
        const activeObjects = new Set();
        
        for (const event of recentEvents) {
            if (event.data.objectId && 
               (event.type === 'object_detected' || event.type === 'object_updated')) {
                activeObjects.add(event.data.objectId);
            }
        }
        
        return activeObjects.size;
    }

    /**
     * Get person detections with advanced filtering
     */
    getPersonDetectionsInLast(minutes) {
        const cutoff = Date.now() - (minutes * 60 * 1000);
        return this.events.filter(event => 
            event.timestamp >= cutoff && 
            event.data.label === 'person' &&
            event.metadata.confidence > 0.6
        ).length;
    }

    /**
     * Get closest person with confidence scoring
     */
    getClosestPerson() {
        const personEvents = this.events.filter(event => 
            event.data.label === 'person' &&
            event.type === 'object_updated' &&
            event.data.worldPosition &&
            event.metadata.confidence > 0.7
        );
        
        if (personEvents.length === 0) return null;
        
        const closest = personEvents.reduce((prev, current) => 
            (prev.data.worldPosition.distance < current.data.worldPosition.distance) ? prev : current
        );
        
        return {
            distance: closest.data.worldPosition.distance,
            bearing: closest.data.worldPosition.bearing.azimuth,
            confidence: closest.metadata.confidence,
            timestamp: closest.timestamp,
            objectId: closest.data.objectId
        };
    }

    /**
     * Get most common label with statistical significance
     */
    getMostCommonLabelInLast(minutes) {
        const cutoff = Date.now() - (minutes * 60 * 1000);
        const recentEvents = this.events.filter(event => 
            event.timestamp >= cutoff && 
            (event.type === 'object_detected' || event.type === 'object_updated') &&
            event.metadata.confidence > 0.5
        );
        
        const labelCounts = new Map();
        recentEvents.forEach(event => {
            const label = event.data.label;
            const count = labelCounts.get(label) || 0;
            labelCounts.set(label, count + 1);
        });
        
        let maxCount = 0;
        let mostCommon = 'none';
        
        for (const [label, count] of labelCounts) {
            if (count > maxCount) {
                maxCount = count;
                mostCommon = label;
            }
        }
        
        return {
            label: mostCommon,
            count: maxCount,
            confidence: maxCount / recentEvents.length
        };
    }

    /**
     * Get advanced analytics
     */
    getAdvancedAnalytics() {
        return {
            ...this.analytics,
            activityLevel: this._calculateActivityLevel(),
            objectDiversity: this.analytics.objectStatistics.size,
            threatLevel: this._calculateOverallThreatLevel(),
            systemUptime: Date.now() - this.analytics.startTime
        };
    }

    /**
     * Calculate overall threat level
     */
    _calculateOverallThreatLevel() {
        const recentThreats = this.analytics.threatAssessments.filter(
            assessment => Date.now() - assessment.timestamp < 300000 // 5 minutes
        );
        
        if (recentThreats.length === 0) return 'LOW';
        
        const avgScore = recentThreats.reduce((sum, assessment) => 
            sum + assessment.score, 0) / recentThreats.length;
        
        if (avgScore > 0.7) return 'HIGH';
        if (avgScore > 0.4) return 'MEDIUM';
        return 'LOW';
    }

    /**
     * Get current system state
     */
    _getSystemState() {
        return {
            memoryUsage: this.events.length,
            objectCount: this.objectHistory.size,
            lastUpdate: Date.now()
        };
    }
}

// ============================================================================
// ADVANCED HUD RENDERER WITH AEROSPACE-GRADE VISUALIZATION
// ============================================================================

/**
 * Advanced HUD renderer with aerospace-grade visualization
 * @class
 */
class AdvancedHUDRenderer {
    constructor() {
        this.canvas = document.getElementById('hud-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        
        // HUD state
        this.hudState = {
            brightness: 0.8,
            contrast: 1.2,
            alertLevel: 'NORMAL'
        };
        
        window.addEventListener('resize', () => this.resize());
    }

    /**
     * Resize canvas with high DPI support
     */
    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = window.innerWidth * dpr;
        this.canvas.height = window.innerHeight * dpr;
        this.canvas.style.width = `${window.innerWidth}px`;
        this.canvas.style.height = `${window.innerHeight}px`;
        this.ctx.scale(dpr, dpr);
    }

    /**
     * Clear canvas with optimized rendering
     */
    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Render complete HUD display
     */
    render(avionicsData, tracks, primaryTarget, systemStatus) {
        this.clear();
        
        // Set rendering quality
        this.ctx.imageSmoothingEnabled = false;
        this.ctx.textBaseline = 'top';
        
        // Render HUD elements in order of importance
        this._renderArtificialHorizon(avionicsData);
        this._renderTargetingReticle();
        this._renderTargetBoxes(tracks);
        this._renderPrimaryTarget(primaryTarget);
        this._renderSystemAlerts(systemStatus);
    }

    /**
     * Render artificial horizon with aviation standards
     */
    _renderArtificialHorizon(avionicsData) {
        const { width, height } = this.canvas;
        const ctx = this.ctx;
        const orientation = avionicsData.getOrientation();
        
        ctx.save();
        ctx.translate(width / 2, height / 2);
        ctx.rotate(orientation.roll * MATHEMATICAL_CONSTANTS.DEG_TO_RAD);
        
        // Sky and ground areas with perspective
        const horizonOffset = orientation.pitch * 2; // Sensitivity factor
        
        // Ground (gradient for depth)
        const groundGradient = ctx.createLinearGradient(0, horizonOffset, 0, height);
        groundGradient.addColorStop(0, 'rgba(101, 67, 33, 0.4)'); // Near
        groundGradient.addColorStop(1, 'rgba(67, 45, 23, 0.6)'); // Far
        
        ctx.fillStyle = groundGradient;
        ctx.fillRect(-width, horizonOffset, width * 2, height);
        
        // Sky (gradient for atmospheric perspective)
        const skyGradient = ctx.createLinearGradient(0, -height, 0, horizonOffset);
        skyGradient.addColorStop(0, 'rgba(0, 50, 100, 0.3)'); // Zenith
        skyGradient.addColorStop(1, 'rgba(0, 100, 200, 0.4)'); // Horizon
        
        ctx.fillStyle = skyGradient;
        ctx.fillRect(-width, -height, width * 2, height + horizonOffset);
        
        // Horizon line with glow effect
        ctx.strokeStyle = CONFIG.UI.COLOR_CODING.LOW;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10;
        ctx.shadowColor = CONFIG.UI.COLOR_CODING.LOW;
        ctx.beginPath();
        ctx.moveTo(-width, horizonOffset);
        ctx.lineTo(width, horizonOffset);
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Pitch ladder with aviation markings
        this._renderPitchLadder(horizonOffset);
        
        ctx.restore();
        
        // Aircraft reference symbol (fixed to viewport)
        this._renderAircraftReference();
    }

    /**
     * Render pitch ladder with aviation standards
     */
    _renderPitchLadder(horizonOffset) {
        const ctx = this.ctx;
        const width = this.canvas.width;
        
        ctx.strokeStyle = CONFIG.UI.COLOR_CODING.LOW;
        ctx.lineWidth = 1;
        ctx.fillStyle = CONFIG.UI.COLOR_CODING.LOW;
        ctx.font = '11px "Courier New", monospace';
        ctx.textAlign = 'center';
        
        // Major and minor pitch lines
        for (let i = -6; i <= 6; i++) {
            if (i === 0) continue;
            
            const pitchAngle = i * 10; // degrees
            const y = horizonOffset + (pitchAngle / 10) * 25; // 25 pixels per 10 degrees
            
            const isMajor = Math.abs(i) % 2 === 0;
            const lineLength = isMajor ? 80 : 50;
            const displayValue = Math.abs(pitchAngle);
            
            // Pitch line
            ctx.beginPath();
            ctx.moveTo(-lineLength / 2, y);
            ctx.lineTo(lineLength / 2, y);
            ctx.stroke();
            
            // Value labels for major lines
            if (isMajor) {
                ctx.fillText(`${displayValue}°`, lineLength / 2 + 25, y - 6);
                ctx.fillText(`${displayValue}°`, -lineLength / 2 - 25, y - 6);
            }
        }
    }

    /**
     * Render aircraft reference symbol
     */
    _renderAircraftReference() {
        const { width, height } = this.canvas;
        const ctx = this.ctx;
        const centerX = width / 2;
        const centerY = height / 2;
        
        ctx.strokeStyle = CONFIG.UI.COLOR_CODING.LOW;
        ctx.lineWidth = 2;
        
        // Wings
        ctx.beginPath();
        ctx.moveTo(centerX - 40, centerY);
        ctx.lineTo(centerX + 40, centerY);
        ctx.stroke();
        
        // Fuselage
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - 20);
        ctx.lineTo(centerX, centerY + 20);
        ctx.stroke();
        
        // Center dot
        ctx.fillStyle = CONFIG.UI.COLOR_CODING.HIGH;
        ctx.fillRect(centerX - 2, centerY - 2, 4, 4);
    }

    /**
     * Render targeting reticle with advanced features
     */
    _renderTargetingReticle() {
        const { width, height } = this.canvas;
        const ctx = this.ctx;
        const centerX = width / 2;
        const centerY = height / 2;
        
        // Outer circle with glow
        ctx.strokeStyle = CONFIG.UI.COLOR_CODING.LOW;
        ctx.lineWidth = 1.5;
        ctx.shadowBlur = 15;
        ctx.shadowColor = CONFIG.UI.COLOR_CODING.LOW;
        ctx.beginPath();
        ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Crosshair lines
        ctx.beginPath();
        ctx.moveTo(centerX - 15, centerY);
        ctx.lineTo(centerX - 50, centerY);
        ctx.moveTo(centerX + 15, centerY);
        ctx.lineTo(centerX + 50, centerY);
        ctx.moveTo(centerX, centerY - 15);
        ctx.lineTo(centerX, centerY - 50);
        ctx.moveTo(centerX, centerY + 15);
        ctx.lineTo(centerX, centerY + 50);
        ctx.stroke();
        
        // Inner circle for precision
        ctx.beginPath();
        ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
        ctx.stroke();
        
        // Center dot
        ctx.fillStyle = CONFIG.UI.COLOR_CODING.HIGH;
        ctx.fillRect(centerX - 1, centerY - 1, 2, 2);
    }

    /**
     * Render target boxes with advanced information
     */
    _renderTargetBoxes(tracks) {
        tracks.forEach(track => {
            this._renderTargetBox(track);
        });
    }

    /**
     * Render individual target box with threat coding
     */
    _renderTargetBox(track) {
        const { x, y, width, height } = track.bbox;
        const ctx = this.ctx;
        
        // Determine color based on threat level
        let color;
        switch (track.threatAssessment.level) {
            case 'HIGH':
                color = CONFIG.UI.COLOR_CODING.CRITICAL;
                break;
            case 'MEDIUM':
                color = CONFIG.UI.COLOR_CODING.MEDIUM;
                break;
            case 'LOW':
            default:
                color = CONFIG.UI.COLOR_CODING.LOW;
        }
        
        // Threat-based glow effect
        ctx.shadowBlur = track.threatAssessment.level === 'HIGH' ? 20 : 10;
        ctx.shadowColor = color;
        
        // Corner brackets (tactical style)
        const bracketSize = Math.min(width, height) * 0.15;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = track.threatAssessment.level === 'HIGH' ? 3 : 2;
        ctx.lineJoin = 'round';
        
        // Draw corner brackets
        ctx.beginPath();
        
        // Top left
        ctx.moveTo(x, y + bracketSize);
        ctx.lineTo(x, y);
        ctx.lineTo(x + bracketSize, y);
        
        // Top right
        ctx.moveTo(x + width - bracketSize, y);
        ctx.lineTo(x + width, y);
        ctx.lineTo(x + width, y + bracketSize);
        
        // Bottom right
        ctx.moveTo(x + width, y + height - bracketSize);
        ctx.lineTo(x + width, y + height);
        ctx.lineTo(x + width - bracketSize, y + height);
        
        // Bottom left
        ctx.moveTo(x + bracketSize, y + height);
        ctx.lineTo(x, y + height);
        ctx.lineTo(x, y + height - bracketSize);
        
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Information panel
        this._renderTargetInfo(track, x, y, color);
    }

    /**
     * Render target information panel
     */
    _renderTargetInfo(track, x, y, color) {
        const ctx = this.ctx;
        
        const label = `${track.label.toUpperCase()} ${Math.floor(track.confidence * 100)}%`;
        const distance = `~${Math.floor(track.worldPosition.distance)}m`;
        const bearing = `${Math.floor(track.worldPosition.bearing.azimuth)}°`;
        const motion = track.motionAnalysis.motionState.toUpperCase();
        
        // Measure text dimensions
        ctx.font = 'bold 10px "Courier New", monospace';
        const textMetrics = [
            ctx.measureText(label),
            ctx.measureText(distance),
            ctx.measureText(bearing),
            ctx.measureText(motion)
        ];
        
        const maxWidth = Math.max(...textMetrics.map(m => m.width));
        const panelWidth = maxWidth + 20;
        const panelHeight = 60;
        
        // Background panel
        ctx.fillStyle = 'rgba(0, 10, 0, 0.85)';
        ctx.fillRect(x, y - panelHeight, panelWidth, panelHeight);
        
        // Border
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y - panelHeight, panelWidth, panelHeight);
        
        // Text
        ctx.fillStyle = color;
        ctx.textAlign = 'left';
        
        let textY = y - panelHeight + 12;
        ctx.fillText(label, x + 10, textY);
        textY += 12;
        ctx.fillText(`DIST: ${distance}`, x + 10, textY);
        textY += 12;
        ctx.fillText(`BEAR: ${bearing}`, x + 10, textY);
        textY += 12;
        ctx.fillText(`MOTION: ${motion}`, x + 10, textY);
    }

    /**
     * Render primary target highlighting
     */
    _renderPrimaryTarget(primaryTarget) {
        if (!primaryTarget) return;
        
        const { x, y, width, height } = primaryTarget.bbox;
        const ctx = this.ctx;
        
        // Pulsing circle around primary target
        const centerX = x + width / 2;
        const centerY = y + height / 2;
        const radius = Math.max(width, height) / 2 + 10;
        
        const pulsePhase = (Date.now() % 1000) / 1000;
        const pulseScale = 1 + 0.2 * Math.sin(pulsePhase * Math.PI * 2);
        
        ctx.strokeStyle = CONFIG.UI.COLOR_CODING.HIGH;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * pulseScale, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Connection line to reticle
        const reticleX = this.canvas.width / 2;
        const reticleY = this.canvas.height / 2;
        
        ctx.strokeStyle = CONFIG.UI.COLOR_CODING.HIGH;
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 2]);
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(reticleX, reticleY);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    /**
     * Render system alerts and status
     */
    _renderSystemAlerts(systemStatus) {
        // System alerts would be rendered here
        // Implementation depends on specific alert requirements
    }
}

// ============================================================================
// ADVANCED SYSTEM KERNEL - AEROSPACE-Grade Architecture
// ============================================================================

/**
 * Advanced system kernel with fault tolerance and performance optimization
 * @class
 */
class AdvancedOmegaKernel {
    constructor() {
        // Advanced system components
        this.avionics = new AdvancedAvionics();
        this.vision = new AdvancedVisionEngine();
        this.tracker = new AdvancedObjectTracker();
        this.physics = new AdvancedPhysicsEngine();
        this.radar = new AdvancedRadarSystem('radar-blips');
        this.memory = new IntelligentKnowledgeBase();
        this.renderer = new AdvancedHUDRenderer();
        
        // System state with fault tolerance
        this.systemState = {
            isRunning: false,
            isInitialized: false,
            operationalMode: 'STANDBY',
            faultConditions: new Set(),
            performanceMetrics: {
                frameRate: 0,
                memoryUsage: 0,
                cpuLoad: 0,
                lastUpdate: 0
            }
        };
        
        // Timing and scheduling
        this.timing = {
            lastAICycle: 0,
            lastRenderCycle: 0,
            lastStatusUpdate: 0,
            aiInterval: 1000 / CONFIG.AI.INFERENCE_RATE,
            renderInterval: 1000 / CONFIG.UI.UPDATE_RATE,
            statusInterval: 1000 / CONFIG.UI.STATUS_UPDATE_RATE
        };
        
        // Data buffers
        this.trackedObjects = [];
        this.primaryTarget = null;
        this.systemStatus = {};
        
        // UI elements
        this.video = document.getElementById('camera-feed');
        
        // Bind methods for event handlers
        this.boot = this.boot.bind(this);
        this._aiProcessingCycle = this._aiProcessingCycle.bind(this);
        this._renderCycle = this._renderCycle.bind(this);
        this._statusUpdateCycle = this._statusUpdateCycle.bind(this);
        
        // Initialize system monitoring
        this._initializeSystemMonitoring();
    }

    /**
     * Initialize system monitoring and fault detection
     */
    _initializeSystemMonitoring() {
        // Performance monitoring
        this._startPerformanceMonitoring();
        
        // Fault detection
        this._startFaultDetection();
        
        // Resource management
        this._startResourceManagement();
    }

    /**
     * Start performance monitoring
     */
    _startPerformanceMonitoring() {
        setInterval(() => {
            this._updatePerformanceMetrics();
        }, 1000);
    }

    /**
     * Start fault detection
     */
    _startFaultDetection() {
        setInterval(() => {
            this._checkSystemHealth();
        }, 5000);
    }

    /**
     * Start resource management
     */
    _startResourceManagement() {
        // Monitor memory usage and manage resources
        // Implementation would include garbage collection guidance
        // and resource allocation optimization
    }

    /**
     * Update performance metrics
     */
    _updatePerformanceMetrics() {
        const now = Date.now();
        const deltaTime = now - this.systemState.performanceMetrics.lastUpdate;
        
        if (deltaTime > 0) {
            this.systemState.performanceMetrics.frameRate = 
                1000 / Math.max(16, this.timing.renderInterval);
            this.systemState.performanceMetrics.lastUpdate = now;
        }
    }

    /**
     * Check system health and detect faults
     */
    _checkSystemHealth() {
        const faults = new Set();
        
        // Check vision system
        if (!this.vision.isModelLoaded) {
            faults.add('VISION_SYSTEM_UNAVAILABLE');
        }
        
        // Check sensor availability
        if (!this.avionics.isAvailable) {
            faults.add('AVIONICS_UNAVAILABLE');
        }
        
        // Check performance
        if (this.systemState.performanceMetrics.frameRate < 30) {
            faults.add('PERFORMANCE_DEGRADED');
        }
        
        this.systemState.faultConditions = faults;
        
        // Update operational mode based on faults
        if (faults.size > 0) {
            this.systemState.operationalMode = 'DEGRADED';
        } else if (this.systemState.isRunning) {
            this.systemState.operationalMode = 'OPERATIONAL';
        }
    }

    /**
     * Initialize the advanced system
     */
    async boot() {
        try {
            this._updateSystemStatus('INITIALIZING_ADVANCED_SYSTEM');
            
            // 1. Initialize avionics with calibration
            this._updateBootLED('led-gyro', 'loading');
            const avionicsReady = await this.avionics.init();
            this._updateBootLED('led-gyro', avionicsReady ? 'active' : 'error');
            
            // 2. Initialize camera system
            this._updateBootLED('led-cam', 'loading');
            const cameraReady = await this._initializeCameraSystem();
            this._updateBootLED('led-cam', cameraReady ? 'active' : 'error');
            
            // 3. Initialize vision AI
            this._updateBootLED('led-ai', 'loading');
            const visionReady = await this.vision.init();
            this._updateBootLED('led-ai', visionReady ? 'active' : 'error');
            
            // 4. Initialize tracking and analytics
            this._updateBootLED('led-tracker', 'active');
            this._updateBootLED('led-memory', 'active');
            
            // Validate system readiness
            if (!cameraReady) {
                throw new Error("Camera system initialization failed");
            }
            
            // Set system state
            this.systemState.isInitialized = true;
            this.systemState.isRunning = true;
            this.systemState.operationalMode = 'OPERATIONAL';
            
            // Transition from boot screen
            this._transitionToOperationalMode();
            
            // Start system cycles
            this._startSystemCycles();
            
            this._updateSystemStatus('SYSTEM_OPERATIONAL');
            console.log("AdvancedOmegaKernel: System booted successfully");
            
        } catch (error) {
            console.error("AdvancedOmegaKernel: Boot sequence failed -", error);
            this._updateSystemStatus(`BOOT_FAILURE: ${error.message}`);
            this._handleBootFailure(error);
        }
    }

    /**
     * Initialize camera system with error handling
     */
    async _initializeCameraSystem() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: 30 }
                }, 
                audio: false 
            });
            
            this.video.srcObject = stream;
            
            // Wait for video to be ready with timeout
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error("Camera initialization timeout"));
                }, 10000);
                
                this.video.onloadedmetadata = () => {
                    clearTimeout(timeout);
                    this.video.play();
                    resolve();
                };
                
                this.video.onerror = () => {
                    clearTimeout(timeout);
                    reject(new Error("Camera video error"));
                };
            });
            
            return true;
            
        } catch (error) {
            console.error("Camera system initialization failed:", error);
            return false;
        }
    }

    /**
     * Transition from boot to operational mode
     */
    _transitionToOperationalMode() {
        // Hide boot screen with transition
        const bootOverlay = document.getElementById('boot-overlay');
        bootOverlay.style.opacity = '0';
        bootOverlay.style.transition = 'opacity 0.5s ease';
        
        setTimeout(() => {
            bootOverlay.style.display = 'none';
        }, 500);
    }

    /**
     * Start all system processing cycles
     */
    _startSystemCycles() {
        // Start AI processing cycle
        this._aiProcessingCycle();
        
        // Start render cycle
        this._renderCycle();
        
        // Start status update cycle
        this._statusUpdateCycle();
    }

    /**
     * AI processing cycle with advanced scheduling
     */
    async _aiProcessingCycle() {
        if (!this.systemState.isRunning) return;
        
        const now = performance.now();
        
        if (now - this.timing.lastAICycle >= this.timing.aiInterval) {
            this.timing.lastAICycle = now;
            
            try {
                // Run object detection
                const detections = await this.vision.detect(this.video);
                
                // Update object tracker
                const rawTracks = this.tracker.update(detections, Date.now());
                
                // Apply physics analysis
                this.trackedObjects = this.physics.analyze(rawTracks);
                
                // Update knowledge base
                this._updateKnowledgeBase(this.trackedObjects);
                
                // Update primary target
                this._updatePrimaryTarget();
                
            } catch (error) {
                console.error("AI processing cycle error:", error);
                this.systemState.faultConditions.add('AI_PROCESSING_ERROR');
            }
        }
        
        // Schedule next cycle with dynamic timing
        const nextCycle = Math.max(0, this.timing.aiInterval - (performance.now() - this.timing.lastAICycle));
        setTimeout(() => this._aiProcessingCycle(), nextCycle);
    }

    /**
     * Render cycle with performance optimization
     */
    _renderCycle() {
        if (!this.systemState.isRunning) return;
        
        const now = performance.now();
        
        if (now - this.timing.lastRenderCycle >= this.timing.renderInterval) {
            this.timing.lastRenderCycle = now;
            
            try {
                // Render complete HUD
                this.renderer.render(
                    this.avionics,
                    this.trackedObjects,
                    this.primaryTarget,
                    this.systemStatus
                );
                
                // Update radar display
                this.radar.update(this.trackedObjects);
                
            } catch (error) {
                console.error("Render cycle error:", error);
                this.systemState.faultConditions.add('RENDER_ERROR');
            }
        }
        
        // Continue render cycle
        requestAnimationFrame(() => this._renderCycle());
    }

    /**
     * Status update cycle for UI and monitoring
     */
    _statusUpdateCycle() {
        if (!this.systemState.isRunning) return;
        
        const now = Date.now();
        
        if (now - this.timing.lastStatusUpdate >= this.timing.statusInterval) {
            this.timing.lastStatusUpdate = now;
            
            try {
                // Update all UI elements
                this._updateUserInterface();
                
                // Update system status display
                this._updateSystemStatusDisplay();
                
            } catch (error) {
                console.error("Status update cycle error:", error);
            }
        }
        
        // Schedule next status update
        setTimeout(() => this._statusUpdateCycle(), this.timing.statusInterval);
    }

    /**
     * Update knowledge base with current tracking data
     */
    _updateKnowledgeBase(tracks) {
        tracks.forEach(track => {
            const eventType = track.status === 'new' ? 'object_detected' : 'object_updated';
            
            this.memory.recordEvent(eventType, {
                objectId: track.id,
                label: track.label,
                confidence: track.confidence,
                worldPosition: track.worldPosition,
                motionState: track.motionAnalysis.motionState,
                threatLevel: track.threatAssessment.level,
                threatScore: track.threatAssessment.score,
                trackAge: Date.now() - track.firstSeen
            }, Date.now());
        });
    }

    /**
     * Update primary target selection
     */
    _updatePrimaryTarget() {
        if (this.trackedObjects.length === 0) {
            this.primaryTarget = null;
            return;
        }
        
        // Select primary target based on multiple factors
        this.primaryTarget = this.trackedObjects.reduce((best, current) => {
            if (!best) return current;
            
            const bestScore = this._calculateTargetPriority(best);
            const currentScore = this._calculateTargetPriority(current);
            
            return currentScore > bestScore ? current : best;
        }, null);
    }

    /**
     * Calculate target priority score
     */
    _calculateTargetPriority(track) {
        let score = 0;
        
        // Proximity to center (higher priority for centered objects)
        const centerDistance = Math.abs(track.screenMetrics.normalizedPosition.x) + 
                             Math.abs(track.screenMetrics.normalizedPosition.y);
        score += (1 - centerDistance) * 0.3;
        
        // Threat level
        if (track.threatAssessment.level === 'HIGH') score += 0.3;
        else if (track.threatAssessment.level === 'MEDIUM') score += 0.2;
        
        // Proximity (closer objects have higher priority)
        score += (1 - (track.worldPosition.distance / CONFIG.PHYSICS.MAX_RANGE)) * 0.2;
        
        // Confidence
        score += track.confidence * 0.2;
        
        return score;
    }

    /**
     * Update all user interface elements
     */
    _updateUserInterface() {
        // System metrics
        const visionStatus = this.vision.getStatus();
        document.getElementById('val-cpu').textContent = 
            AdvancedMath.Statistics.formatNumber(visionStatus.averageTime, 1);
        document.getElementById('val-fps').textContent = 
            AdvancedMath.Statistics.formatNumber(visionStatus.fps, 1);
        
        // Avionics data
        const orientation = this.avionics.getOrientation();
        document.getElementById('val-pitch').textContent = 
            AdvancedMath.Statistics.formatNumber(orientation.pitch, 1) + '°';
        document.getElementById('val-roll').textContent = 
            AdvancedMath.Statistics.formatNumber(orientation.roll, 1) + '°';
        document.getElementById('val-heading').textContent = 
            AdvancedMath.Statistics.formatNumber(orientation.heading, 1) + '°';
        document.getElementById('val-g').textContent = 
            AdvancedMath.Statistics.formatNumber(this.avionics.gForce, 2);
        
        // Tracking information
        const trackerStats = this.tracker.getStats();
        document.getElementById('val-tracked').textContent = trackerStats.activeTracks;
        
        // Analytics data
        document.getElementById('val-active').textContent = this.memory.getActiveObjectCount();
        document.getElementById('val-persons').textContent = this.memory.getPersonDetectionsInLast(5);
        
        const closestPerson = this.memory.getClosestPerson();
        document.getElementById('val-closest-person').textContent = closestPerson ? 
            `~${AdvancedMath.Statistics.formatNumber(closestPerson.distance, 1)}m @ ${AdvancedMath.Statistics.formatNumber(closestPerson.bearing, 0)}°` : 
            '--';
        
        const commonLabel = this.memory.getMostCommonLabelInLast(5);
        document.getElementById('val-top-label').textContent = 
            typeof commonLabel === 'string' ? commonLabel : commonLabel.label;
        
        // Primary target information
        if (this.primaryTarget) {
            document.getElementById('val-target-label').textContent = 
                this.primaryTarget.label.toUpperCase();
            document.getElementById('val-target-dist').textContent = 
                `~${AdvancedMath.Statistics.formatNumber(this.primaryTarget.worldPosition.distance, 1)}m`;
            document.getElementById('val-target-bearing').textContent = 
                `${AdvancedMath.Statistics.formatNumber(this.primaryTarget.worldPosition.bearing.azimuth, 1)}°`;
            document.getElementById('val-target-state').textContent = 
                this.primaryTarget.motionAnalysis.motionState.toUpperCase();
            document.getElementById('val-target-conf').textContent = 
                `${Math.floor(this.primaryTarget.confidence * 100)}%`;
        } else {
            document.getElementById('val-target-label').textContent = '--';
            document.getElementById('val-target-dist').textContent = '--';
            document.getElementById('val-target-bearing').textContent = '--';
            document.getElementById('val-target-state').textContent = '--';
            document.getElementById('val-target-conf').textContent = '--';
        }
        
        // Update system status indicators
        this._updateSystemStatusIndicators();
    }

    /**
     * Update system status indicators
     */
    _updateSystemStatusIndicators() {
        // Camera status
        const camStatus = this.video.srcObject && this.video.readyState === 4 ? 
            'status-ok' : 'status-error';
        document.getElementById('status-cam').className = `status-indicator ${camStatus}`;
        
        // AI status
        const aiStatus = this.vision.isModelLoaded ? 'status-ok' : 'status-error';
        document.getElementById('status-ai').className = `status-indicator ${aiStatus}`;
        
        // Avionics status
        const avionicsStatus = this.avionics.isAvailable ? 
            (this.avionics.isCalibrated ? 'status-ok' : 'status-warn') : 'status-offline';
        document.getElementById('status-gyro').className = `status-indicator ${avionicsStatus}`;
        
        // Tracker status
        const trackerStats = this.tracker.getStats();
        const trackerStatus = trackerStats.activeTracks > 0 ? 'status-ok' : 'status-warn';
        document.getElementById('status-tracker').className = `status-indicator ${trackerStatus}`;
        
        // Memory status
        const memoryStatus = this.memory.events.length > 0 ? 'status-ok' : 'status-warn';
        document.getElementById('status-memory').className = `status-indicator ${memoryStatus}`;
    }

    /**
     * Update system status display
     */
    _updateSystemStatusDisplay() {
        let statusMessage = 'SYSTEM_OPERATIONAL';
        
        if (this.systemState.faultConditions.size > 0) {
            const faults = Array.from(this.systemState.faultConditions);
            statusMessage = `DEGRADED: ${faults.join(', ')}`;
        } else if (!this.systemState.isRunning) {
            statusMessage = 'SYSTEM_STANDBY';
        }
        
        this._updateSystemStatus(statusMessage);
    }

    /**
     * Update boot LED status
     */
    _updateBootLED(ledId, state) {
        const led = document.getElementById(ledId);
        led.className = 'status-led';
        
        if (state === 'active') led.classList.add('active');
        else if (state === 'error') led.classList.add('error');
        else if (state === 'warning') led.classList.add('warning');
        else if (state === 'loading') led.classList.add('loading');
    }

    /**
     * Update system status message
     */
    _updateSystemStatus(message) {
        document.getElementById('status-message').textContent = message;
    }

    /**
     * Handle boot failure
     */
    _handleBootFailure(error) {
        this.systemState.isRunning = false;
        this.systemState.operationalMode = 'FAILED';
        
        // Show error to user
        alert(`SYSTEM BOOT FAILURE: ${error.message}\n\nPlease check permissions and try again.`);
    }

    /**
     * Graceful system shutdown
     */
    shutdown() {
        this.systemState.isRunning = false;
        
        // Stop media streams
        if (this.video.srcObject) {
            this.video.srcObject.getTracks().forEach(track => track.stop());
        }
        
        // Clear resources
        this.trackedObjects = [];
        
        console.log("AdvancedOmegaKernel: System shutdown complete");
    }

    /**
     * Get system diagnostics
     */
    getDiagnostics() {
        return {
            systemState: { ...this.systemState },
            componentStatus: {
                avionics: this.avionics.getStatus(),
                vision: this.vision.getStatus(),
                tracker: this.tracker.getStats(),
                memory: this.memory.getAdvancedAnalytics()
            },
            performance: { ...this.systemState.performanceMetrics }
        };
    }
}

// ============================================================================
// SYSTEM INITIALIZATION AND ENTRY POINT
// ============================================================================

// Initialize the advanced system kernel
const ADVANCED_OMEGA = new AdvancedOmegaKernel();

// Set up initialization with enhanced UX
document.getElementById('btn-init').addEventListener('click', () => {
    // Visual feedback
    const btn = document.getElementById('btn-init');
    btn.textContent = 'INITIALIZING...';
    btn.disabled = true;
    
    // Start system boot
    ADVANCED_OMEGA.boot();
});

// Add enhanced CSS animations
const enhancedStyles = document.createElement('style');
enhancedStyles.textContent = `
    @keyframes pulse {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.7; transform: scale(1.1); }
    }
    
    @keyframes targetLock {
        0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    
    @keyframes alertPulse {
        0%, 100% { opacity: 1; box-shadow: 0 0 20px currentColor; }
        50% { opacity: 0.5; box-shadow: 0 0 5px currentColor; }
    }
    
    .critical-alert {
        animation: alertPulse 0.5s infinite;
    }
`;
document.head.appendChild(enhancedStyles);

// Enhanced event handling for robust operation
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        console.log("OMEGA: System entering background mode");
        // Could implement power saving measures here
    } else {
        console.log("OMEGA: System resuming foreground operation");
    }
});

// Handle page unload for graceful shutdown
window.addEventListener('beforeunload', () => {
    ADVANCED_OMEGA.shutdown();
});

// Global error handling for robustness
window.addEventListener('error', (event) => {
    console.error('Global error:', event.error);
});

window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
});

console.log("OMEGA: Advanced Humanoid Vision System - Aerospace Grade Initialized");
</script>
</body>
</html>
