<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OMEGA: ADVANCED HUMANOID VISION SYSTEM</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>

    <style>
        :root {
            /* Palette: Aerospace / Tactical / Sci-Fi */
            --hud-primary: #00ff41;   /* Matrix Green */
            --hud-secondary: #008f11; /* Dimmed Green */
            --hud-alert: #ff3333;     /* Critical Red */
            --hud-warn: #ffcc00;      /* Warning Yellow */
            --hud-info: #00aaff;      /* Cyan/Blue */
            --bg-dark: #000000;
            --glass: rgba(0, 20, 0, 0.65);
            --glass-border: 1px solid rgba(0, 255, 65, 0.3);
            --font-mono: 'SF Mono', 'Consolas', 'Menlo', monospace;
        }

        /* --- CORE SETUP --- */
        * { box-sizing: border-box; user-select: none; -webkit-touch-callout: none; outline: none; }
        
        body {
            margin: 0; overflow: hidden; background: var(--bg-dark);
            font-family: var(--font-mono); color: var(--hud-primary);
            width: 100vw; height: 100vh;
        }

        /* --- VIEWPORT & LAYERS --- */
        #viewport { position: relative; width: 100%; height: 100%; overflow: hidden; }
        
        /* Video: Object-fit cover ensures full screen, logic handles mapping */
        #camera-feed {
            position: absolute; width: 100%; height: 100%; 
            object-fit: cover; z-index: 0; 
            filter: sepia(0.2) hue-rotate(50deg) contrast(1.1) brightness(0.9) grayscale(0.3);
            opacity: 0.8;
            transform: scaleX(-1); /* Mirror effect for selfie mode feel, remove if rear cam preferred */
        }
        
        #hud-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; inset: 0; z-index: 20; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: max(15px, env(safe-area-inset-top));
        }

        .hud-panel {
            background: var(--glass); border-left: 2px solid var(--hud-primary);
            padding: 6px 10px; margin: 5px; width: fit-content;
            backdrop-filter: blur(4px); pointer-events: auto;
            transition: all 0.2s;
        }
        
        .hud-text { font-size: 11px; letter-spacing: 0.5px; margin-bottom: 2px; text-shadow: 0 0 2px rgba(0,255,65,0.5); }
        .hud-value { font-weight: 700; color: #fff; }
        .hud-sub { color: var(--hud-secondary); font-size: 9px; }

        /* --- RADAR --- */
        #radar-container {
            position: absolute; bottom: 80px; right: 20px;
            width: 120px; height: 120px;
            border-radius: 50%; background: rgba(0, 15, 0, 0.85);
            border: 1px solid var(--hud-primary);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.1);
            overflow: hidden; pointer-events: auto;
        }
        #radar-container::after {
            content: ''; position: absolute; inset: 0;
            background: conic-gradient(from 0deg, transparent 0deg, transparent 270deg, rgba(0,255,65,0.3) 360deg);
            border-radius: 50%; animation: radar-scan 2s linear infinite;
        }
        .radar-blip {
            position: absolute; border-radius: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 4px currentColor; transition: top 0.2s, left 0.2s;
        }
        @keyframes radar-scan { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        /* --- CONTROL PANEL (Overlay) --- */
        #control-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 400px; background: rgba(0, 10, 0, 0.95);
            border: 1px solid var(--hud-primary); padding: 20px;
            z-index: 100; display: none; flex-direction: column; gap: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.2);
            backdrop-filter: blur(10px); pointer-events: auto;
        }
        .panel-header { font-size: 16px; font-weight: bold; border-bottom: 1px solid var(--hud-secondary); padding-bottom: 10px; margin-bottom: 10px; }
        .btn {
            background: rgba(0, 255, 65, 0.1); border: 1px solid var(--hud-primary);
            color: var(--hud-primary); padding: 10px; cursor: pointer;
            font-family: inherit; font-size: 12px; text-transform: uppercase;
            transition: 0.2s;
        }
        .btn:hover { background: var(--hud-primary); color: #000; }
        .btn:active { transform: scale(0.98); }
        .btn-danger { border-color: var(--hud-alert); color: var(--hud-alert); background: rgba(255, 0, 0, 0.1); }
        .btn-danger:hover { background: var(--hud-alert); color: #fff; }
        
        .row { display: flex; gap: 10px; }
        .col { flex: 1; display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 10px; color: var(--hud-secondary); }

        /* --- STATUS BAR --- */
        #system-status {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(0, 0, 0, 0.8); border-top: 1px solid var(--hud-secondary);
            padding: 4px 10px; display: flex; justify-content: space-between;
            font-size: 10px; z-index: 25; pointer-events: none;
        }
        .status-dot { width: 6px; height: 6px; border-radius: 50%; display: inline-block; margin-right: 4px; }
        .bg-ok { background: var(--hud-primary); box-shadow: 0 0 5px var(--hud-primary); }
        .bg-warn { background: var(--hud-warn); box-shadow: 0 0 5px var(--hud-warn); }
        .bg-err { background: var(--hud-alert); box-shadow: 0 0 5px var(--hud-alert); }
        .bg-off { background: #444; }

        /* --- TOAST --- */
        #toast-container { position: absolute; top: 10%; left: 50%; transform: translateX(-50%); z-index: 200; pointer-events: none; }
        .toast { background: rgba(0,0,0,0.8); border: 1px solid var(--hud-primary); color: var(--hud-primary); padding: 8px 16px; margin-bottom: 5px; font-size: 12px; animation: fadein 0.3s; }
        @keyframes fadein { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- BOOT --- */
        #boot-screen {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
    </style>
</head>
<body>

    <div id="viewport">
        <video id="camera-feed" autoplay playsinline muted></video>
        
        <canvas id="hud-canvas"></canvas>
        
        <div id="ui-layer">
            <div style="display:flex; justify-content:space-between;">
                <div class="hud-panel" onclick="OMEGA.ui.toggleControlPanel()">
                    <div class="hud-text">CPU/AI: <span id="disp-ai-ms">0</span>ms</div>
                    <div class="hud-text">AI FPS: <span id="disp-ai-fps">0</span></div>
                    <div class="hud-text">UI FPS: <span id="disp-ui-fps">0</span></div>
                    <div class="hud-sub">[TAP FOR MENU]</div>
                </div>
                <div class="hud-panel" style="text-align:right;">
                    <div class="hud-text">GYRO: <span id="disp-gyro">OFFLINE</span></div>
                    <div class="hud-text">HDG: <span id="disp-hdg">000</span>¬∞</div>
                    <div class="hud-text">PITCH: <span id="disp-pitch">0</span>¬∞</div>
                </div>
            </div>

            <div style="position: absolute; top: 50%; left: 20px; transform: translateY(-50%);">
                <div class="hud-panel" id="primary-target-panel" style="display:none; border-left-color: var(--hud-info);">
                    <div class="hud-text" style="color:var(--hud-info)">PRIORITY TARGET</div>
                    <div class="hud-value" id="pt-label" style="font-size:16px;">UNKNOWN</div>
                    <div class="hud-text">CONF: <span id="pt-conf">0</span>%</div>
                    <div class="hud-text">DIST: <span id="pt-dist">--</span></div>
                    <div class="hud-text">BRNG: <span id="pt-brng">0</span>¬∞</div>
                </div>
            </div>

            <div id="radar-container">
                <div style="position:absolute; top:50%; left:50%; width:1px; height:100%; background:rgba(0,255,65,0.2); transform:translate(-50%,-50%);"></div>
                <div style="position:absolute; top:50%; left:50%; width:100%; height:1px; background:rgba(0,255,65,0.2); transform:translate(-50%,-50%);"></div>
                <div style="position:absolute; top:50%; left:50%; width:33%; height:33%; border:1px solid rgba(0,255,65,0.2); border-radius:50%; transform:translate(-50%,-50%);"></div>
                <div style="position:absolute; top:50%; left:50%; width:66%; height:66%; border:1px solid rgba(0,255,65,0.2); border-radius:50%; transform:translate(-50%,-50%);"></div>
                <div id="radar-blips"></div>
            </div>
        </div>

        <div id="system-status">
            <div>
                <span class="status-dot bg-off" id="st-cam"></span>CAM
                <span class="status-dot bg-off" id="st-ai" style="margin-left:8px;"></span>AI
                <span class="status-dot bg-off" id="st-mem" style="margin-left:8px;"></span>MEM
            </div>
            <div id="sys-msg">INITIALIZING...</div>
        </div>
    </div>

    <div id="toast-container"></div>

    <div id="control-panel">
        <div class="panel-header">OMEGA SYSTEM CONTROL</div>
        
        <div class="row">
            <button class="btn col" onclick="OMEGA.toggleAI()">‚èØ PAUSE AI</button>
            <button class="btn col btn-danger" onclick="OMEGA.shutdown()">‚õî SHUTDOWN</button>
        </div>

        <div style="margin-top:10px;">
            <label>PERFORMANCE PROFILE</label>
            <div class="row">
                <button class="btn col" onclick="OMEGA.setProfile('low')">ECO</button>
                <button class="btn col" onclick="OMEGA.setProfile('balanced')">BAL</button>
                <button class="btn col" onclick="OMEGA.setProfile('high')">MAX</button>
            </div>
        </div>

        <div style="margin-top:10px;">
            <label>CALIBRATION (DEPTH)</label>
            <div class="row">
                <input type="number" id="cal-height" value="1.7" step="0.1" style="width:50px; background:#000; color:var(--hud-primary); border:1px solid var(--hud-primary);"> m (Ref Height)
                <button class="btn col" onclick="OMEGA.calibrateDepth()">SET REF</button>
            </div>
            <div class="hud-sub" style="margin-top:5px;">Align target top/bottom to green box then click SET.</div>
        </div>

        <div class="row" style="margin-top:10px;">
            <button class="btn col" onclick="OMEGA.memory.export()">üíæ EXPORT LOG</button>
            <button class="btn col btn-danger" onclick="OMEGA.memory.clear()">üóë CLEAR MEM</button>
        </div>

        <button class="btn" style="margin-top:10px;" onclick="OMEGA.ui.toggleControlPanel()">CLOSE MENU</button>
    </div>

    <div id="boot-screen">
        <div style="font-size:32px; letter-spacing:8px; font-weight:900; color:var(--hud-primary);">OMEGA</div>
        <div style="font-size:12px; color:var(--hud-secondary); margin-bottom:30px;">ADVANCED HUMANOID VISION</div>
        <button id="btn-init" class="btn" style="padding:15px 40px; font-size:14px; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);">INITIALIZE SYSTEM</button>
    </div>

<script>
/**
 * OMEGA: ADVANCED HUMANOID VISION SYSTEM v2.0
 * Architecture: Event-Driven, Component-Based, Fail-Soft
 * Standards: Aerospace/Robotics Engineering Best Practices
 */

// ============================================================================
// 1. CONFIGURATION & STATE
// ============================================================================
const CONFIG = {
    PROFILES: {
        low: { aiFps: 5, maxDetections: 5, resolution: 0.5 },
        balanced: { aiFps: 15, maxDetections: 10, resolution: 0.75 },
        high: { aiFps: 30, maxDetections: 20, resolution: 1.0 }
    },
    PHYSICS: {
        FOV_DEFAULT: 60, // Degrees (Horizontal)
        REF_HEIGHT_PERSON: 1.7, // Meters
        REF_HEIGHT_CAR: 1.5,
        MAX_DIST_DISPLAY: 50 // Meters
    },
    TRACKING: {
        IOU_THRESHOLD: 0.3,
        MAX_LOST_FRAMES: 30,
        GATING_DIST: 0.2 // Screen space normalized
    },
    MEMORY: {
        AUTOSAVE_MS: 30000,
        MAX_LOGS: 1000
    }
};

// ============================================================================
// 2. MATH & PHYSICS UTILITIES (Hard Science)
// ============================================================================
const MathUtils = {
    // Pinhole Camera Model: Z = (f * H_real) / h_pixel
    estimateDepth: (bboxHeightPx, realHeightM, focalLengthPx) => {
        if (!focalLengthPx || bboxHeightPx <= 0) return null;
        return (focalLengthPx * realHeightM) / bboxHeightPx;
    },

    // Bearing calculation from center
    calculateBearing: (x_center_px, img_width_px, fov_deg) => {
        const x_norm = (x_center_px - (img_width_px / 2)) / (img_width_px / 2);
        const fov_rad = fov_deg * (Math.PI / 180);
        // Approximation: angle = x_norm * (fov/2)
        // Precise: angle = atan(x_px / f)
        return x_norm * (fov_deg / 2);
    },

    // 1D Kalman Filter (Lite version for JS)
    KalmanFilter: class {
        constructor(R = 1, Q = 1, A = 1, B = 0, C = 1) {
            this.R = R; // Noise covariance
            this.Q = Q; // Process covariance
            this.A = A; // State vector
            this.B = B; // Control vector
            this.C = C; // Measurement vector
            this.cov = NaN;
            this.x = NaN; // Value
        }
        filter(z, u = 0) {
            if (isNaN(this.x)) {
                this.x = (1 / this.C) * z;
                this.cov = (1 / this.C) * this.Q * (1 / this.C);
            } else {
                const predX = (this.A * this.x) + (this.B * u);
                const predCov = ((this.A * this.cov) * this.A) + this.Q;
                const K = predCov * this.C * (1 / ((this.C * predCov * this.C) + this.R));
                this.x = predX + K * (z - (this.C * predX));
                this.cov = predCov - (K * this.C * predCov);
            }
            return this.x;
        }
    },

    mapVideoToScreen: (box, vidW, vidH, screenW, screenH) => {
        // Handle object-fit: cover math
        const screenRatio = screenW / screenH;
        const vidRatio = vidW / vidH;
        
        let renderW, renderH, offsetX, offsetY;
        
        if (screenRatio > vidRatio) {
            // Screen is wider: Video cropped top/bottom
            renderW = screenW;
            renderH = screenW / vidRatio;
            offsetX = 0;
            offsetY = (screenH - renderH) / 2;
        } else {
            // Screen is taller: Video cropped left/right
            renderH = screenH;
            renderW = screenH * vidRatio;
            offsetX = (screenW - renderW) / 2;
            offsetY = 0;
        }

        // Scale factors
        const scaleX = renderW / vidW;
        const scaleY = renderH / vidH;

        return {
            x: box.x * scaleX + offsetX,
            y: box.y * scaleY + offsetY,
            w: box.w * scaleX,
            h: box.h * scaleY
        };
    }
};

// ============================================================================
// 3. CORE MODULES
// ============================================================================

/**
 * AVIONICS: Handles Gyroscope/Accelerometer
 * Compliant with W3C DeviceOrientation & DeviceMotion
 */
class Avionics {
    constructor() {
        this.data = { pitch: 0, roll: 0, heading: 0, g: 1.0 };
        this.available = false;
        this.callbacks = [];
    }

    async init() {
        if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response === 'granted') this._bindEvents();
                else console.warn('Gyro permission denied');
            } catch (e) { console.error(e); }
        } else {
            this._bindEvents();
        }
    }

    _bindEvents() {
        window.addEventListener('deviceorientation', (e) => {
            this.available = true;
            this.data.pitch = e.beta || 0;
            this.data.roll = e.gamma || 0;
            this.data.heading = e.alpha || 0;
            // Webkit compass heading correction
            if (e.webkitCompassHeading) this.data.heading = e.webkitCompassHeading;
        });

        window.addEventListener('devicemotion', (e) => {
            const acc = e.accelerationIncludingGravity;
            if (acc) this.data.g = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2) / 9.81;
        });
    }
}

/**
 * VISION ENGINE: Manages TF.js model and inference loop
 */
class VisionEngine {
    constructor() {
        this.model = null;
        this.video = document.getElementById('camera-feed');
        this.isReady = false;
        this.currentProfile = CONFIG.PROFILES.balanced;
        this.lastTime = 0;
        this.metrics = { fps: 0, ms: 0 };
    }

    async init() {
        try {
            await tf.setBackend('webgl'); // Force GPU
        } catch (e) {
            console.warn('WebGL failed, fallback to cpu');
            await tf.setBackend('cpu');
        }
        
        console.log(`Backend: ${tf.getBackend()}`);
        this.model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
        
        // Warmup (FIXED: Use 3D tensor to let model add batch dim automatically)
        const dummy = tf.zeros([224, 224, 3]);
        await this.model.detect(dummy);
        dummy.dispose();
        
        this.isReady = true;
        return true;
    }

    async startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: 1280, height: 720 },
                audio: false
            });
            this.video.srcObject = stream;
            return new Promise(resolve => this.video.onloadedmetadata = resolve);
        } catch (e) {
            throw new Error("CAMERA_ACCESS_DENIED");
        }
    }

    setProfile(profileName) {
        if (CONFIG.PROFILES[profileName]) {
            this.currentProfile = CONFIG.PROFILES[profileName];
            return true;
        }
        return false;
    }
}

/**
 * TRACKER: Object association and state management
 */
class Tracker {
    constructor() {
        this.tracks = []; // Array of active tracks
        this.nextId = 1;
        this.depthFilter = new Map(); // Store Kalman filters per ID
    }

    update(detections, timestamp) {
        // Simple Greedy Association based on IoU
        const activeTracks = this.tracks.filter(t => t.state !== 'removed');
        
        // Predict next position (Simple linear motion)
        activeTracks.forEach(t => {
            t.age++;
            t.framesLost++;
            if (t.framesLost > CONFIG.TRACKING.MAX_LOST_FRAMES) t.state = 'removed';
        });

        detections.forEach(det => {
            // Find best match
            let bestMatch = null;
            let maxIoU = 0;

            activeTracks.forEach(track => {
                if (track.state === 'removed') return;
                const iou = this._calculateIoU(track.box, det.box);
                // Gate: Check label and IoU
                if (iou > CONFIG.TRACKING.IOU_THRESHOLD && iou > maxIoU && track.label === det.class) {
                    maxIoU = iou;
                    bestMatch = track;
                }
            });

            if (bestMatch) {
                // Update Track
                bestMatch.box = det.box; // [x, y, w, h]
                bestMatch.score = det.score;
                bestMatch.framesLost = 0;
                bestMatch.state = 'active';
                bestMatch.lastSeen = timestamp;
            } else {
                // New Track
                this.tracks.push({
                    id: this.nextId++,
                    label: det.class,
                    box: det.box,
                    score: det.score,
                    state: 'new',
                    firstSeen: timestamp,
                    lastSeen: timestamp,
                    framesLost: 0,
                    age: 0
                });
            }
        });

        // Filter dead tracks
        this.tracks = this.tracks.filter(t => t.state !== 'removed');
        return this.tracks;
    }

    _calculateIoU(boxA, boxB) {
        const xA = Math.max(boxA[0], boxB[0]);
        const yA = Math.max(boxA[1], boxB[1]);
        const xB = Math.min(boxA[0] + boxA[2], boxB[0] + boxB[2]);
        const yB = Math.min(boxA[1] + boxA[3], boxB[1] + boxB[3]);
        const interArea = Math.max(0, xB - xA) * Math.max(0, yB - yA);
        const boxAArea = boxA[2] * boxA[3];
        const boxBArea = boxB[2] * boxB[3];
        return interArea / (boxAArea + boxBArea - interArea);
    }
}

/**
 * MEMORY: LocalStorage persistence
 */
class KnowledgeBase {
    constructor() {
        this.key = 'OMEGA_LOGS';
        this.logs = [];
        this.load();
    }

    log(type, details) {
        const entry = { ts: Date.now(), type, details };
        this.logs.push(entry);
        if (this.logs.length > CONFIG.MEMORY.MAX_LOGS) this.logs.shift();
    }

    save() {
        try {
            localStorage.setItem(this.key, JSON.stringify(this.logs));
            return true;
        } catch (e) { return false; }
    }

    load() {
        const data = localStorage.getItem(this.key);
        if (data) this.logs = JSON.parse(data);
    }

    clear() {
        this.logs = [];
        localStorage.removeItem(this.key);
        OMEGA.ui.toast("MEMORY CLEARED");
    }

    export() {
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.logs));
        const anchor = document.createElement('a');
        anchor.setAttribute("href", dataStr);
        anchor.setAttribute("download", "omega_logs.json");
        document.body.appendChild(anchor);
        anchor.click();
        anchor.remove();
    }
}

// ============================================================================
// 4. MAIN KERNEL (CONTROLLER)
// ============================================================================
const OMEGA = {
    // Sub-systems
    avionics: new Avionics(),
    vision: new VisionEngine(),
    tracker: new Tracker(),
    memory: new KnowledgeBase(),
    
    // System State
    running: false,
    calibration: { focalLength: null, refHeight: 1.7 },
    
    // UI Helpers
    ui: {
        canvas: document.getElementById('hud-canvas'),
        ctx: document.getElementById('hud-canvas').getContext('2d'),
        toast: (msg) => {
            const el = document.createElement('div');
            el.className = 'toast'; el.innerText = msg;
            document.getElementById('toast-container').appendChild(el);
            setTimeout(() => el.remove(), 3000);
        },
        toggleControlPanel: () => {
            const p = document.getElementById('control-panel');
            p.style.display = p.style.display === 'flex' ? 'none' : 'flex';
        }
    },

    // Initialization
    async init() {
        document.getElementById('btn-init').innerText = "SYSTEM LOADING...";
        
        try {
            // 1. Avionics
            await this.avionics.init();
            
            // 2. Camera
            await this.vision.startCamera();
            document.getElementById('st-cam').className = 'status-dot bg-ok';
            
            // 3. AI
            const aiReady = await this.vision.init();
            if (aiReady) document.getElementById('st-ai').className = 'status-dot bg-ok';
            
            // 4. Memory
            document.getElementById('st-mem').className = 'status-dot bg-ok';

            // Start Loops
            this.running = true;
            document.getElementById('boot-screen').style.display = 'none';
            
            this.loops.ai();
            this.loops.render();
            
            this.ui.toast("OMEGA SYSTEM ONLINE");
            
        } catch (e) {
            console.error(e);
            document.getElementById('btn-init').innerText = "SYSTEM FAILURE: " + e.message;
            document.getElementById('btn-init').classList.add('btn-danger');
        }
    },

    // Logic Loops
    loops: {
        ai: async () => {
            if (!OMEGA.running) return;
            
            const start = performance.now();
            const { video, model, currentProfile } = OMEGA.vision;

            if (video.readyState === 4 && model) {
                // Detect
                const predictions = await model.detect(video, currentProfile.maxDetections, 0.5);
                
                // Track
                const tracks = OMEGA.tracker.update(predictions, Date.now());
                
                // Physics & Analysis
                OMEGA.processPhysics(tracks);
                
                // Metrics
                const duration = performance.now() - start;
                OMEGA.vision.metrics.ms = Math.round(duration);
                OMEGA.vision.metrics.fps = Math.round(1000 / duration);
            }

            // Adaptive Timing
            const delay = Math.max(10, (1000 / OMEGA.vision.currentProfile.aiFps) - (performance.now() - start));
            setTimeout(OMEGA.loops.ai, delay);
        },

        render: () => {
            if (!OMEGA.running) return;
            const start = performance.now();
            
            OMEGA.draw();
            
            // UI FPS
            const duration = performance.now() - start;
            document.getElementById('disp-ui-fps').innerText = Math.round(1000 / Math.max(1, duration));
            
            requestAnimationFrame(OMEGA.loops.render);
        }
    },

    // Physics Processor
    processPhysics(tracks) {
        const screenW = window.innerWidth;
        const screenH = window.innerHeight;
        const vidW = OMEGA.vision.video.videoWidth;
        const vidH = OMEGA.vision.video.videoHeight;
        
        let primaryTarget = null;
        let maxScore = -1;

        tracks.forEach(t => {
            // 1. Map to Screen Coordinates
            // box is [x, y, w, h] in video frame
            const mapped = MathUtils.mapVideoToScreen(
                {x:t.box[0], y:t.box[1], w:t.box[2], h:t.box[3]},
                vidW, vidH, screenW, screenH
            );
            t.renderBox = mapped;

            // 2. Calculate Bearing
            // Center of box relative to screen center
            const centerX = mapped.x + (mapped.w / 2);
            t.bearing = MathUtils.calculateBearing(centerX, screenW, CONFIG.PHYSICS.FOV_DEFAULT);
            
            // 3. Calculate Depth
            // Use filtered height for stability
            if (!OMEGA.tracker.depthFilter.has(t.id)) {
                OMEGA.tracker.depthFilter.set(t.id, new MathUtils.KalmanFilter(1, 1, 1, 0, 1));
            }
            const filteredH = OMEGA.tracker.depthFilter.get(t.id).filter(t.box[3]);
            
            if (OMEGA.calibration.focalLength) {
                // Absolute Depth (Meters)
                const refH = (t.label === 'person') ? CONFIG.PHYSICS.REF_HEIGHT_PERSON : CONFIG.PHYSICS.REF_HEIGHT_CAR;
                t.depth = MathUtils.estimateDepth(filteredH, refH, OMEGA.calibration.focalLength);
                t.depthStr = t.depth.toFixed(1) + 'm';
            } else {
                // Relative Depth (0.0 - 1.0)
                // Normalize: closer (larger box) -> 0, far -> 1
                t.depth = Math.min(1.0, 100 / filteredH); // Arbitrary scale factor
                t.depthStr = 'REL ' + t.depth.toFixed(2);
            }

            // 4. Primary Target Scoring
            // Score = Confidence(0.3) + CenterBias(0.5) + CloseRange(0.2)
            const centerDist = Math.abs(centerX - screenW/2) / (screenW/2);
            const score = (t.score * 0.3) + ((1 - centerDist) * 0.5);
            
            if (score > maxScore) {
                maxScore = score;
                primaryTarget = t;
            }
        });

        OMEGA.primaryTarget = primaryTarget;
    },

    // Draw HUD
    draw() {
        const ctx = this.ui.ctx;
        const W = this.ui.canvas.width = window.innerWidth;
        const H = this.ui.canvas.height = window.innerHeight;
        
        ctx.clearRect(0, 0, W, H);

        // 1. Artificial Horizon
        if (this.avionics.available) {
            const { pitch, roll } = this.avionics.data;
            document.getElementById('disp-gyro').innerText = "ONLINE";
            document.getElementById('disp-pitch').innerText = pitch.toFixed(0);
            document.getElementById('disp-hdg').innerText = (360 - this.avionics.data.heading).toFixed(0);

            ctx.save();
            ctx.translate(W/2, H/2);
            ctx.rotate(roll * Math.PI / 180);
            ctx.translate(0, pitch * 5); // Pitch scale
            
            // Horizon Line
            ctx.strokeStyle = "rgba(0, 255, 65, 0.4)";
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(-W, 0); ctx.lineTo(W, 0); ctx.stroke();
            
            // Ladder
            ctx.fillStyle = "rgba(0, 255, 65, 0.4)";
            for (let i=-2; i<=2; i++) {
                if(i===0) continue;
                ctx.fillRect(-50, i*50, 100, 1);
                ctx.fillText(i*10, 60, i*50 + 3);
            }
            ctx.restore();
        }

        // 2. Crosshair
        ctx.strokeStyle = "rgba(0, 255, 65, 0.8)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(W/2 - 20, H/2); ctx.lineTo(W/2 + 20, H/2);
        ctx.moveTo(W/2, H/2 - 20); ctx.lineTo(W/2, H/2 + 20);
        ctx.stroke();

        // 3. Targets
        const blipsContainer = document.getElementById('radar-blips');
        blipsContainer.innerHTML = ''; // Clear radar

        if (OMEGA.tracker.tracks) {
            OMEGA.tracker.tracks.forEach(t => {
                const { x, y, w, h } = t.renderBox;
                const isPrimary = (OMEGA.primaryTarget && OMEGA.primaryTarget.id === t.id);
                const color = isPrimary ? '#00ff41' : (t.label === 'person' ? '#ffcc00' : '#00aaff');

                // Box
                ctx.strokeStyle = color;
                ctx.lineWidth = isPrimary ? 2 : 1;
                ctx.shadowBlur = isPrimary ? 10 : 0;
                ctx.shadowColor = color;
                
                // Tactical Corners
                const corner = Math.min(w, h) * 0.2;
                ctx.beginPath();
                ctx.moveTo(x, y + corner); ctx.lineTo(x, y); ctx.lineTo(x + corner, y); // TL
                ctx.moveTo(x + w - corner, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w, y + corner); // TR
                ctx.moveTo(x + w, y + h - corner); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w - corner, y + h); // BR
                ctx.moveTo(x + corner, y + h); ctx.lineTo(x, y + h); ctx.lineTo(x, y + h - corner); // BL
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Label
                ctx.fillStyle = color;
                ctx.font = "bold 10px monospace";
                ctx.fillText(`${t.label.toUpperCase()} [${Math.floor(t.score*100)}%]`, x, y - 5);
                ctx.fillText(`D:${t.depthStr}`, x, y + h + 12);

                // Radar Blip
                // Map bearing (-30 to 30 deg) to x
                // Map depth (0 to max) to y
                if (t.bearing !== undefined) {
                    const radarR = 60; // radius
                    const angleRad = t.bearing * (Math.PI/180);
                    // Normalize dist: assume max display range 50m
                    const distNorm = OMEGA.calibration.focalLength ? 
                                     Math.min(t.depth, CONFIG.PHYSICS.MAX_DIST_DISPLAY) / CONFIG.PHYSICS.MAX_DIST_DISPLAY : 
                                     t.depth; // Already 0-1
                    
                    const bx = 60 + (Math.sin(angleRad) * distNorm * radarR);
                    const by = 60 - (Math.cos(angleRad) * distNorm * radarR);
                    
                    const blip = document.createElement('div');
                    blip.className = 'radar-blip';
                    blip.style.backgroundColor = color;
                    blip.style.width = isPrimary ? '6px' : '4px';
                    blip.style.height = isPrimary ? '6px' : '4px';
                    blip.style.left = bx + 'px';
                    blip.style.top = by + 'px';
                    blipsContainer.appendChild(blip);
                }
            });
        }

        // 4. Update Stats DOM
        document.getElementById('disp-ai-ms').innerText = this.vision.metrics.ms;
        document.getElementById('disp-ai-fps').innerText = this.vision.metrics.fps;

        if (this.primaryTarget) {
            const p = document.getElementById('primary-target-panel');
            p.style.display = 'block';
            document.getElementById('pt-label').innerText = this.primaryTarget.label.toUpperCase();
            document.getElementById('pt-conf').innerText = (this.primaryTarget.score * 100).toFixed(0);
            document.getElementById('pt-dist').innerText = this.primaryTarget.depthStr;
            document.getElementById('pt-brng').innerText = this.primaryTarget.bearing.toFixed(1);
        } else {
            document.getElementById('primary-target-panel').style.display = 'none';
        }
    },

    // User Actions
    shutdown: () => {
        OMEGA.running = false;
        if(OMEGA.vision.video.srcObject) {
            OMEGA.vision.video.srcObject.getTracks().forEach(t => t.stop());
        }
        document.body.innerHTML = '<div style="display:flex;height:100vh;align-items:center;justify-content:center;color:#00ff41;font-family:monospace;">SYSTEM HALTED</div>';
    },

    toggleAI: () => {
        OMEGA.running = !OMEGA.running;
        if(OMEGA.running) {
            OMEGA.loops.ai();
            OMEGA.loops.render();
            OMEGA.ui.toast("SYSTEM RESUMED");
        } else {
            OMEGA.ui.toast("SYSTEM PAUSED");
        }
    },

    setProfile: (mode) => {
        if(OMEGA.vision.setProfile(mode)) {
            OMEGA.ui.toast(`PROFILE: ${mode.toUpperCase()}`);
        }
    },

    calibrateDepth: () => {
        // Assume user aligned the "Primary Target" or generic box
        // To be safe, we create a centered box overlay for them to match
        if (!OMEGA.calibration.isCalibrating) {
            OMEGA.calibration.isCalibrating = true;
            OMEGA.ui.toast("ALIGN TARGET HEIGHT & CLICK SET");
            // Draw a calibration box guide in Draw loop?
            // For now, assume current Primary Target is the reference
            if (OMEGA.primaryTarget) {
                 const h_px = OMEGA.primaryTarget.box[3]; // Raw video height
                 const H_real = parseFloat(document.getElementById('cal-height').value);
                 // Assume distance? No, pinhole needs D.
                 // We will revert to: "Stand at 3 meters" logic or just generic factor
                 // Let's use Focal Length derivation: f = (h_px * Dist) / H_real
                 // Since we don't know Dist, we can't solve exact f without user inputting distance.
                 // Updated Logic: User inputs HEIGHT. User assumed to be at e.g. 2m? 
                 // Let's set a default calibration distance of 2 meters for the setup.
                 const D_ref = 3.0; // Standard calibration distance
                 const f = (h_px * D_ref) / H_real;
                 
                 OMEGA.calibration.focalLength = f;
                 OMEGA.calibration.isCalibrating = false;
                 OMEGA.memory.log('CALIBRATION', { f, H_real });
                 OMEGA.ui.toast("CALIBRATION SAVED");
            } else {
                 OMEGA.ui.toast("NO TARGET FOUND TO CALIBRATE");
                 OMEGA.calibration.isCalibrating = false;
            }
        }
    }
};

// Event Listeners
document.getElementById('btn-init').addEventListener('click', () => OMEGA.init());

// Visibility API for Performance
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        OMEGA.vision.setProfile('low');
    } else {
        OMEGA.vision.setProfile('balanced');
    }
});

console.log("OMEGA v2.0 READY. WAITING FOR INIT.");
</script>
</body>
</html>
