<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORION-AR :: LIVE OBJECT INTELLIGENCE SCANNER</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        #videoContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* Top Status Bar */
        .status-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 3;
            background: rgba(0, 20, 40, 0.85);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
            padding: 12px 20px;
        }

        .status-title {
            font-size: 18px;
            font-weight: 600;
            color: #64c8ff;
            margin-bottom: 2px;
        }

        .status-subtitle {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
        }

        .status-pill {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(100, 200, 255, 0.2);
            border: 1px solid rgba(100, 200, 255, 0.4);
            border-radius: 999px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-pill.idle { background: rgba(100, 200, 255, 0.2); }
        .status-pill.tracking { background: rgba(100, 255, 150, 0.2); border-color: rgba(100, 255, 150, 0.4); }
        .status-pill.lost { background: rgba(255, 100, 100, 0.2); border-color: rgba(255, 100, 100, 0.4); }

        /* Center Overlay */
        .center-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
            pointer-events: none;
        }

        .reticle {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(100, 200, 255, 0.6);
            border-radius: 50%;
            position: relative;
        }

        .reticle::before, .reticle::after {
            content: '';
            position: absolute;
            background: rgba(100, 200, 255, 0.6);
        }

        .reticle::before {
            width: 2px;
            height: 20px;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .reticle::after {
            width: 20px;
            height: 2px;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
        }

        .target-box {
            position: absolute;
            border: 2px solid #64ff96;
            border-radius: 8px;
            background: rgba(100, 255, 150, 0.1);
            box-shadow: 0 0 20px rgba(100, 255, 150, 0.3);
            transition: all 0.3s ease;
            z-index: 3;
        }

        /* Bottom Panel */
        .bottom-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 3;
            background: rgba(0, 20, 40, 0.85);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 20px 20px 0 0;
            padding: 20px;
            max-height: 50vh;
            display: flex;
            flex-direction: column;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        .info-item {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 2px;
        }

        .info-value {
            font-size: 14px;
            font-weight: 600;
            color: #64c8ff;
        }

        .confidence-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #64ff96);
            transition: width 0.3s ease;
        }

        .controls {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .btn {
            flex: 1;
            padding: 10px 16px;
            background: rgba(100, 200, 255, 0.15);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            color: #64c8ff;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: rgba(100, 200, 255, 0.25);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn.muted {
            background: rgba(255, 100, 100, 0.15);
            border-color: rgba(255, 100, 100, 0.3);
            color: #ff6464;
        }

        .event-log {
            flex: 1;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 8px;
            font-size: 11px;
            max-height: 120px;
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
        }

        .log-time {
            color: rgba(100, 200, 255, 0.7);
            margin-right: 8px;
        }

        /* Instructions */
        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 4;
            background: rgba(0, 20, 40, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 16px;
            padding: 24px;
            max-width: 300px;
        }

        .instructions h3 {
            color: #64c8ff;
            margin-bottom: 12px;
        }

        .instructions p {
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 16px;
            line-height: 1.4;
        }

        .close-btn {
            padding: 8px 16px;
            background: rgba(100, 200, 255, 0.2);
            border: 1px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            color: #64c8ff;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="videoContainer">
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
    </div>

    <div class="status-bar">
        <div class="status-title">ORION-AR LIVE SCANNER</div>
        <div class="status-subtitle">Live Object Intelligence Analysis</div>
        <div class="status-pill idle" id="statusPill">IDLE</div>
    </div>

    <div class="center-overlay">
        <div class="reticle" id="reticle"></div>
    </div>

    <div class="target-box" id="targetBox" style="display: none;"></div>

    <div class="bottom-panel">
        <div class="info-grid">
            <div class="info-item">
                <div class="info-label">CATEGORY</div>
                <div class="info-value" id="categoryValue">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">STABILITY</div>
                <div class="info-value" id="stabilityValue">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">MOTION INDEX</div>
                <div class="info-value" id="motionValue">0.00</div>
            </div>
            <div class="info-item">
                <div class="info-label">VIBRATION INDEX</div>
                <div class="info-value" id="vibrationValue">0.00</div>
            </div>
            <div class="info-item">
                <div class="info-label">AUDIO LEVEL</div>
                <div class="info-value" id="audioValue">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">CONFIDENCE</div>
                <div class="info-value" id="confidenceValue">-</div>
                <div class="confidence-bar">
                    <div class="confidence-fill" id="confidenceFill" style="width: 0%;"></div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn" id="lockBtn">LOCK TARGET</button>
            <button class="btn" id="rescanBtn">RE-SCAN</button>
            <button class="btn" id="muteBtn">MUTE VOICE</button>
        </div>

        <div class="event-log" id="eventLog"></div>
    </div>

    <div class="instructions" id="instructions">
        <h3>ORION-AR Scanner</h3>
        <p>Tap anywhere on screen to lock onto a target. The system will track the object and analyze its motion, vibration, and acoustic properties.</p>
        <p>Keep the target in view for continuous analysis.</p>
        <button class="close-btn" id="closeInstructions">BEGIN SCAN</button>
    </div>

    <script>
        // Global Application State
        const app = {
            state: 'idle', // 'idle', 'tracking', 'lost'
            target: {
                x: 0,
                y: 0,
                width: 64,
                height: 64,
                template: null,
                confidence: 0,
                lostFrames: 0
            },
            sensors: {
                motionHistory: [],
                vibrationHistory: [],
                audioLevel: 0,
                lastFrame: null
            },
            ui: {
                voiceMuted: false,
                lastSpeechTime: 0
            },
            config: {
                trackingThreshold: 0.3,
                lostThreshold: 10,
                motionThresholds: { low: 0.05, high: 0.2 },
                vibrationThresholds: { low: 0.02, high: 0.1 },
                audioThresholds: { low: 0.1, high: 0.5 },
                speechCooldown: 3000
            },
            elements: {},
            video: null,
            canvas: null,
            ctx: null,
            audioContext: null,
            analyser: null,
            lastClassification: null
        };

        // DOM Elements
        function initializeElements() {
            app.elements = {
                video: document.getElementById('video'),
                canvas: document.getElementById('canvas'),
                statusPill: document.getElementById('statusPill'),
                targetBox: document.getElementById('targetBox'),
                reticle: document.getElementById('reticle'),
                categoryValue: document.getElementById('categoryValue'),
                stabilityValue: document.getElementById('stabilityValue'),
                motionValue: document.getElementById('motionValue'),
                vibrationValue: document.getElementById('vibrationValue'),
                audioValue: document.getElementById('audioValue'),
                confidenceValue: document.getElementById('confidenceValue'),
                confidenceFill: document.getElementById('confidenceFill'),
                lockBtn: document.getElementById('lockBtn'),
                rescanBtn: document.getElementById('rescanBtn'),
                muteBtn: document.getElementById('muteBtn'),
                eventLog: document.getElementById('eventLog'),
                instructions: document.getElementById('instructions'),
                closeInstructions: document.getElementById('closeInstructions')
            };
            app.ctx = app.elements.canvas.getContext('2d');
        }

        // Camera Initialization
        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' },
                    audio: true 
                });
                app.elements.video.srcObject = stream;
                
                // Initialize audio analysis if available
                try {
                    app.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    app.analyser = app.audioContext.createAnalyser();
                    const source = app.audioContext.createMediaStreamSource(stream);
                    source.connect(app.analyser);
                    app.analyser.fftSize = 256;
                } catch (audioError) {
                    console.warn('Audio analysis not available:', audioError);
                }
                
                return new Promise((resolve) => {
                    app.elements.video.onloadedmetadata = () => {
                        app.elements.canvas.width = app.elements.video.videoWidth;
                        app.elements.canvas.height = app.elements.video.videoHeight;
                        resolve();
                    };
                });
            } catch (error) {
                console.error('Camera initialization failed:', error);
                logEvent('Camera Error', 'Failed to access camera');
                throw error;
            }
        }

        // Event Logging
        function logEvent(event, payload = {}) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${timestamp}]</span> ${event}`;
            
            app.elements.eventLog.appendChild(entry);
            app.elements.eventLog.scrollTop = app.elements.eventLog.scrollHeight;
            
            // Keep only last 10 entries
            while (app.elements.eventLog.children.length > 10) {
                app.elements.eventLog.removeChild(app.elements.eventLog.firstChild);
            }
        }

        // Target Locking
        function lockTarget(x, y) {
            const rect = app.elements.canvas.getBoundingClientRect();
            const scaleX = app.elements.canvas.width / rect.width;
            const scaleY = app.elements.canvas.height / rect.height;
            
            app.target.x = (x - rect.left) * scaleX;
            app.target.y = (y - rect.top) * scaleY;
            
            // Capture template
            captureTemplate();
            
            app.state = 'tracking';
            app.target.confidence = 1.0;
            app.target.lostFrames = 0;
            
            updateStatus();
            logEvent('Target Locked', { x: Math.round(app.target.x), y: Math.round(app.target.y) });
            
            // Initial classification and speech
            updateClassification();
            speakStatus('initial');
        }

        function captureTemplate() {
            const { x, y, width, height } = app.target;
            app.ctx.drawImage(app.elements.video, 0, 0);
            const imageData = app.ctx.getImageData(x - width/2, y - height/2, width, height);
            
            // Convert to grayscale for tracking
            const grayData = new Uint8Array(width * height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                grayData[i/4] = Math.round(
                    imageData.data[i] * 0.299 +
                    imageData.data[i+1] * 0.587 +
                    imageData.data[i+2] * 0.114
                );
            }
            
            app.target.template = grayData;
            app.sensors.lastFrame = grayData.slice();
        }

        // Template Matching (Simplified 2D tracking)
        function matchTemplate() {
            if (!app.target.template) return null;
            
            const { width, height } = app.target;
            const searchRange = 32;
            let bestMatch = { x: app.target.x, y: app.target.y, error: Infinity };
            
            app.ctx.drawImage(app.elements.video, 0, 0);
            const currentImageData = app.ctx.getImageData(0, 0, app.elements.canvas.width, app.elements.canvas.height);
            
            for (let dy = -searchRange; dy <= searchRange; dy += 4) {
                for (let dx = -searchRange; dx <= searchRange; dx += 4) {
                    const testX = app.target.x + dx;
                    const testY = app.target.y + dy;
                    
                    if (testX < width/2 || testX >= app.elements.canvas.width - width/2 ||
                        testY < height/2 || testY >= app.elements.canvas.height - height/2) {
                        continue;
                    }
                    
                    let error = 0;
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const srcIdx = ((testY - height/2 + y) * app.elements.canvas.width + (testX - width/2 + x)) * 4;
                            const gray = Math.round(
                                currentImageData.data[srcIdx] * 0.299 +
                                currentImageData.data[srcIdx+1] * 0.587 +
                                currentImageData.data[srcIdx+2] * 0.114
                            );
                            const templateIdx = y * width + x;
                            error += Math.abs(gray - app.target.template[templateIdx]);
                        }
                    }
                    
                    error /= (width * height);
                    
                    if (error < bestMatch.error) {
                        bestMatch = { x: testX, y: testY, error };
                    }
                }
            }
            
            return bestMatch;
        }

        // Motion Metrics
        function updateMotionMetrics() {
            if (!app.target.template || !app.sensors.lastFrame) return 0;
            
            const { width, height } = app.target;
            let motion = 0;
            
            app.ctx.drawImage(app.elements.video, 0, 0);
            const currentImageData = app.ctx.getImageData(
                app.target.x - width/2, 
                app.target.y - height/2, 
                width, 
                height
            );
            
            // Convert current frame to grayscale and compare with last frame
            for (let i = 0; i < currentImageData.data.length; i += 4) {
                const currentGray = Math.round(
                    currentImageData.data[i] * 0.299 +
                    currentImageData.data[i+1] * 0.587 +
                    currentImageData.data[i+2] * 0.114
                );
                motion += Math.abs(currentGray - app.sensors.lastFrame[i/4]);
            }
            
            motion /= (width * height * 255); // Normalize to 0-1
            
            // Update history
            app.sensors.motionHistory.push(motion);
            if (app.sensors.motionHistory.length > 10) {
                app.sensors.motionHistory.shift();
            }
            
            // Store current frame for next comparison
            for (let i = 0; i < currentImageData.data.length; i += 4) {
                app.sensors.lastFrame[i/4] = Math.round(
                    currentImageData.data[i] * 0.299 +
                    currentImageData.data[i+1] * 0.587 +
                    currentImageData.data[i+2] * 0.114
                );
            }
            
            return motion;
        }

        // IMU/Vibration Metrics
        function initIMU() {
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', (event) => {
                    const acceleration = event.accelerationIncludingGravity;
                    if (acceleration) {
                        const gForce = Math.sqrt(
                            Math.pow(acceleration.x, 2) +
                            Math.pow(acceleration.y, 2) + 
                            Math.pow(acceleration.z, 2)
                        ) / 9.80665;
                        
                        // Calculate vibration as deviation from 1G
                        const vibration = Math.abs(gForce - 1.0);
                        
                        app.sensors.vibrationHistory.push(vibration);
                        if (app.sensors.vibrationHistory.length > 20) {
                            app.sensors.vibrationHistory.shift();
                        }
                    }
                });
            } else {
                console.warn('DeviceMotion not supported');
            }
        }

        function getVibrationIndex() {
            if (app.sensors.vibrationHistory.length === 0) return 0;
            
            // Calculate standard deviation as vibration index
            const mean = app.sensors.vibrationHistory.reduce((a, b) => a + b) / app.sensors.vibrationHistory.length;
            const variance = app.sensors.vibrationHistory.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / app.sensors.vibrationHistory.length;
            return Math.sqrt(variance);
        }

        // Audio Analysis
        function updateAudioMetrics() {
            if (!app.analyser) return 0;
            
            const dataArray = new Uint8Array(app.analyser.frequencyBinCount);
            app.analyser.getByteFrequencyData(dataArray);
            
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            
            const rms = Math.sqrt(sum / dataArray.length) / 255;
            app.sensors.audioLevel = rms;
            return rms;
        }

        // Target State Classification
        function classifyTargetState(motionIndex, vibrationIndex, audioLevel) {
            let category = 'Unknown';
            let stability = 'Unknown';
            let audioDescriptor = 'Quiet';
            let confidence = 0.7; // Base confidence
            
            // Audio classification
            if (audioLevel < app.config.audioThresholds.low) {
                audioDescriptor = 'Quiet';
            } else if (audioLevel < app.config.audioThresholds.high) {
                audioDescriptor = 'Moderate';
            } else {
                audioDescriptor = 'Loud';
            }
            
            // Stability classification based on vibration
            if (vibrationIndex < app.config.vibrationThresholds.low) {
                stability = 'Stable';
                confidence += 0.1;
            } else if (vibrationIndex < app.config.vibrationThresholds.high) {
                stability = 'Mild Vibration';
            } else {
                stability = 'High Vibration';
            }
            
            // Category classification
            if (motionIndex < app.config.motionThresholds.low && vibrationIndex < app.config.vibrationThresholds.low) {
                category = 'Static Surface';
                confidence += 0.2;
            } else if (motionIndex >= app.config.motionThresholds.high && vibrationIndex < app.config.vibrationThresholds.low) {
                category = 'Moving Object';
            } else if (vibrationIndex >= app.config.vibrationThresholds.high) {
                category = 'Vibrating Appliance';
                if (audioLevel > app.config.audioThresholds.high) {
                    category = 'Active Machinery';
                    confidence += 0.1;
                }
            } else if (motionIndex > app.config.motionThresholds.low) {
                category = 'Dynamic Object';
            }
            
            // Adjust confidence based on tracking quality
            confidence *= app.target.confidence;
            confidence = Math.min(1, Math.max(0.3, confidence));
            
            return { category, stability, audioDescriptor, confidence };
        }

        function updateClassification() {
            const motionIndex = updateMotionMetrics();
            const vibrationIndex = getVibrationIndex();
            const audioLevel = updateAudioMetrics();
            
            const classification = classifyTargetState(motionIndex, vibrationIndex, audioLevel);
            
            // Update UI
            app.elements.categoryValue.textContent = classification.category;
            app.elements.stabilityValue.textContent = classification.stability;
            app.elements.motionValue.textContent = motionIndex.toFixed(3);
            app.elements.vibrationValue.textContent = vibrationIndex.toFixed(3);
            app.elements.audioValue.textContent = classification.audioDescriptor;
            app.elements.confidenceValue.textContent = Math.round(classification.confidence * 100) + '%';
            app.elements.confidenceFill.style.width = (classification.confidence * 100) + '%';
            
            // Check for significant state changes
            if (app.lastClassification) {
                const categoryChanged = app.lastClassification.category !== classification.category;
                const stabilityChanged = app.lastClassification.stability !== classification.stability;
                
                if (categoryChanged || stabilityChanged) {
                    speakStatus('update');
                    logEvent('State Change', {
                        category: classification.category,
                        stability: classification.stability
                    });
                }
            }
            
            app.lastClassification = classification;
        }

        // Speech Synthesis
        function speakStatus(type) {
            if (app.ui.voiceMuted) return;
            if (Date.now() - app.ui.lastSpeechTime < app.config.speechCooldown) return;
            
            const synthesis = window.speechSynthesis;
            if (!synthesis) return;
            
            // Cancel any ongoing speech
            synthesis.cancel();
            
            let text = '';
            if (type === 'initial' && app.lastClassification) {
                text = `Target locked. Appears to be a ${app.lastClassification.category.toLowerCase()}. Stability: ${app.lastClassification.stability.toLowerCase()}.`;
            } else if (type === 'update' && app.lastClassification) {
                text = `Update. Target now classified as ${app.lastClassification.category.toLowerCase()}. Vibration level ${app.lastClassification.stability.toLowerCase().includes('high') ? 'high' : 'low'}.`;
            } else if (type === 'lost') {
                text = 'Target lost. Please reacquire.';
            }
            
            if (text) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.9;
                utterance.pitch = 1.0;
                synthesis.speak(utterance);
                app.ui.lastSpeechTime = Date.now();
            }
        }

        // UI Updates
        function updateStatus() {
            app.elements.statusPill.textContent = app.state.toUpperCase();
            app.elements.statusPill.className = `status-pill ${app.state}`;
            
            app.elements.reticle.style.display = app.state === 'idle' ? 'block' : 'none';
            app.elements.targetBox.style.display = app.state === 'tracking' ? 'block' : 'none';
        }

        function renderOverlay() {
            // Clear canvas
            app.ctx.clearRect(0, 0, app.elements.canvas.width, app.elements.canvas.height);
            
            if (app.state === 'tracking') {
                // Draw target box
                const { x, y, width, height } = app.target;
                app.elements.targetBox.style.left = (x - width/2) + 'px';
                app.elements.targetBox.style.top = (y - height/2) + 'px';
                app.elements.targetBox.style.width = width + 'px';
                app.elements.targetBox.style.height = height + 'px';
                
                // Draw confidence indicator
                const confidence = app.lastClassification ? app.lastClassification.confidence : app.target.confidence;
                const hue = confidence * 120; // 0 (red) to 120 (green)
                app.elements.targetBox.style.borderColor = `hsl(${hue}, 100%, 65%)`;
                app.elements.targetBox.style.boxShadow = `0 0 20px hsla(${hue}, 100%, 65%, 0.3)`;
            }
        }

        // Main Tracking Loop
        function updateTracking() {
            if (app.state === 'tracking') {
                const match = matchTemplate();
                
                if (match && match.error < app.config.trackingThreshold) {
                    app.target.x = match.x;
                    app.target.y = match.y;
                    app.target.confidence = 1 - (match.error / app.config.trackingThreshold);
                    app.target.lostFrames = 0;
                    
                    updateClassification();
                } else {
                    app.target.lostFrames++;
                    app.target.confidence *= 0.9;
                    
                    if (app.target.lostFrames > app.config.lostThreshold) {
                        app.state = 'lost';
                        updateStatus();
                        speakStatus('lost');
                        logEvent('Target Lost', { confidence: app.target.confidence.toFixed(2) });
                    }
                }
                
                renderOverlay();
            }
            
            requestAnimationFrame(updateTracking);
        }

        // Event Handlers
        function bindEvents() {
            // Canvas tap for target locking
            app.elements.canvas.addEventListener('click', (e) => {
                if (app.state !== 'tracking') {
                    lockTarget(e.clientX, e.clientY);
                }
            });
            
            // Button handlers
            app.elements.lockBtn.addEventListener('click', () => {
                if (app.state === 'idle') {
                    // Lock to center of screen
                    const rect = app.elements.canvas.getBoundingClientRect();
                    lockTarget(rect.left + rect.width/2, rect.top + rect.height/2);
                }
            });
            
            app.elements.rescanBtn.addEventListener('click', () => {
                if (app.state === 'tracking') {
                    captureTemplate();
                    logEvent('Target Rescanned');
                }
            });
            
            app.elements.muteBtn.addEventListener('click', () => {
                app.ui.voiceMuted = !app.ui.voiceMuted;
                app.elements.muteBtn.classList.toggle('muted', app.ui.voiceMuted);
                app.elements.muteBtn.textContent = app.ui.voiceMuted ? 'UNMUTE VOICE' : 'MUTE VOICE';
                logEvent(app.ui.voiceMuted ? 'Voice Muted' : 'Voice Unmuted');
            });
            
            app.elements.closeInstructions.addEventListener('click', () => {
                app.elements.instructions.style.display = 'none';
                logEvent('Scan Session Started');
            });
        }

        // Application Initialization
        async function initApp() {
            try {
                initializeElements();
                await initCamera();
                initIMU();
                bindEvents();
                updateTracking();
                
                logEvent('ORION-AR System Ready');
                console.log('ORION-AR Scanner initialized successfully');
            } catch (error) {
                console.error('Failed to initialize ORION-AR:', error);
                logEvent('System Initialization Failed');
            }
        }

        // Start the application when loaded
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
