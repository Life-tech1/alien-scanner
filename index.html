<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OMEGA: HEAVY KERNEL SYSTEM</title>
    
    <!-- LIBRARIES -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

    <style>
        /* --- CYBERPUNK UI STYLES (V2) --- */
        :root {
            --primary: #0affc2; --secondary: #008f7a; --accent: #00d2ff;
            --alert: #ff2a6d; --warn: #ffae00; --bg: #000502;
            --glass: rgba(0, 20, 10, 0.85);
            --font-tech: 'Courier New', monospace;
            --font-ui: 'Segoe UI', sans-serif;
        }
        body { margin: 0; overflow: hidden; background: var(--bg); color: var(--primary); font-family: var(--font-ui); }
        canvas { position: absolute; top: 0; left: 0; }
        
        #viewport { position: relative; width: 100vw; height: 100vh; }
        #camera-feed { width: 100%; height: 100%; object-fit: cover; filter: contrast(1.1) brightness(0.8) grayscale(0.2); }
        
        /* LAYERS */
        #layer-3d { z-index: 10; opacity: 0.7; pointer-events: none; }
        #layer-hud { z-index: 20; pointer-events: none; }
        #layer-ui { z-index: 30; position: absolute; inset: 0; padding: 20px; display: flex; flex-direction: column; justify-content: space-between; pointer-events: none; }

        /* FX */
        .scanlines { position: fixed; inset: 0; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 2px, 3px 100%; pointer-events: none; z-index: 900; }
        .vignette { position: fixed; inset: 0; background: radial-gradient(circle, transparent 60%, black 100%); z-index: 901; pointer-events: none; }

        /* PANELS */
        .panel { 
            background: var(--glass); border: 1px solid var(--secondary); border-left: 4px solid var(--primary);
            padding: 15px; margin: 5px; backdrop-filter: blur(10px); pointer-events: auto;
            width: fit-content; min-width: 200px;
            box-shadow: 0 0 15px rgba(10, 255, 194, 0.15);
            transition: transform 0.2s;
        }
        .panel:hover { transform: translateX(5px); box-shadow: 0 0 25px rgba(10, 255, 194, 0.3); }
        .panel-header { font-family: var(--font-tech); font-weight: 900; color: var(--accent); margin-bottom: 8px; letter-spacing: 2px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px; }
        .data-row { display: flex; justify-content: space-between; font-family: var(--font-tech); font-size: 12px; margin-bottom: 4px; color: rgba(255,255,255,0.8); }
        .val { color: var(--primary); font-weight: bold; text-shadow: 0 0 5px var(--primary); }
        .val.alert { color: var(--alert); text-shadow: 0 0 5px var(--alert); }

        /* RADAR */
        #radar-box {
            position: absolute; bottom: 80px; right: 20px; width: 160px; height: 160px;
            background: rgba(0,10,5,0.9); border-radius: 50%; border: 2px solid var(--secondary);
            z-index: 40; overflow: hidden; pointer-events: auto;
        }
        #radar-scan { position: absolute; inset: 0; background: conic-gradient(transparent 270deg, var(--primary)); opacity: 0.3; border-radius: 50%; animation: spin 3s linear infinite; }
        .blip { position: absolute; width: 6px; height: 6px; background: var(--alert); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 8px var(--alert); transition: all 0.2s; }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* BOOT SCREEN */
        #boot-screen {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .loader { border: 4px solid #333; border-top: 4px solid var(--primary); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px; }
        #log-output { font-family: var(--font-tech); font-size: 12px; color: #666; height: 100px; overflow: hidden; text-align: center; }
    </style>
</head>
<body>
    
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div id="viewport">
        <video id="camera-feed" autoplay playsinline muted></video>
        <canvas id="layer-3d"></canvas> <!-- THREE.JS LAYER -->
        <canvas id="layer-hud"></canvas> <!-- 2D HUD LAYER -->
        
        <div id="layer-ui">
            <!-- TOP BAR -->
            <div style="display:flex; justify-content: space-between; width: 100%;">
                <div class="panel">
                    <div class="panel-header">SYSTEM METRICS</div>
                    <div class="data-row"><span>CPU TIME</span><span class="val" id="ui-cpu">0ms</span></div>
                    <div class="data-row"><span>FPS</span><span class="val" id="ui-fps">0</span></div>
                    <div class="data-row"><span>MEMORY</span><span class="val" id="ui-mem">0 MB</span></div>
                    <div class="data-row"><span>OBJECTS</span><span class="val" id="ui-obj">0</span></div>
                </div>
                
                <div class="panel">
                    <div class="panel-header">PHYSICS ENGINE</div>
                    <div class="data-row"><span>ALTITUDE</span><span class="val">1.7m</span></div>
                    <div class="data-row"><span>VELOCITY</span><span class="val" id="ui-vel">0 m/s</span></div>
                    <div class="data-row"><span>HEADING</span><span class="val" id="ui-hdg">0Â°</span></div>
                    <div class="data-row"><span>THREAT</span><span class="val alert" id="ui-threat">NONE</span></div>
                </div>
            </div>

            <!-- BOTTOM -->
            <div style="margin-top: auto;">
                <div class="panel">
                    <div class="panel-header">TACTICAL LOG</div>
                    <div id="tactical-feed" style="font-family: var(--font-tech); font-size: 10px; height: 60px; overflow: hidden; opacity: 0.8;">
                        > SYSTEM INITIALIZED...
                    </div>
                </div>
            </div>

            <div id="radar-box">
                <div id="radar-scan"></div>
                <!-- BLIPS INJECTED HERE -->
            </div>
        </div>
    </div>

    <!-- BOOT OVERLAY -->
    <div id="boot-screen">
        <div style="font-size: 40px; font-weight: 900; letter-spacing: 10px; color: var(--primary); margin-bottom: 20px; text-shadow: 0 0 20px var(--primary);">OMEGA</div>
        <div class="loader"></div>
        <div id="log-output">Loading Modules...</div>
        <button id="btn-start" style="display:none; margin-top: 20px; padding: 15px 40px; background: transparent; border: 2px solid var(--primary); color: var(--primary); font-weight: bold; cursor: pointer; letter-spacing: 2px;">ENGAGE SYSTEM</button>
    </div>

<script>
/**
 * OMEGA: HEAVY KERNEL (RESTORATION)
 * This script restores the complex logic architectures:
 * 1. Physics Engine (Real math)
 * 2. Tracker History (ID Persistence)
 * 3. Three.js Integration (3D World)
 * 4. Advanced State Management
 */

// --- GLOBAL CONFIGURATION (The "Settings" File) ---
const CONFIG = {
    AI: {
        OBJ_CONFIDENCE: 0.6,
        MAX_OBJECTS: 20,
        FACE_MESH: true
    },
    PHYSICS: {
        FOV_H: 60, // Camera Horizontal FOV in degrees
        FOCAL_LENGTH: 800, // Approximate pixel focal length
        EST_PERSON_HEIGHT: 1.7 // Meters
    },
    TRACKING: {
        MAX_LOST_FRAMES: 10, // Keep ID for 10 frames if lost
        IOU_THRESHOLD: 0.4
    }
};

// --- MATH & UTILITIES MODULE ---
const MathUtils = {
    // Intersection over Union for tracking
    getIOU: (box1, box2) => {
        const x1 = Math.max(box1[0], box2[0]);
        const y1 = Math.max(box1[1], box2[1]);
        const x2 = Math.min(box1[0] + box1[2], box2[0] + box2[2]);
        const y2 = Math.min(box1[1] + box1[3], box2[1] + box2[3]);
        const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
        const area1 = box1[2] * box1[3];
        const area2 = box2[2] * box2[3];
        return intersection / (area1 + area2 - intersection);
    },
    // Estimate distance based on pixel height
    getDistance: (pixelHeight) => {
        // Distance = (Real Height * Focal Length) / Pixel Height
        return (CONFIG.PHYSICS.EST_PERSON_HEIGHT * CONFIG.PHYSICS.FOCAL_LENGTH) / pixelHeight;
    },
    // Map 2D screen to 3D world coordinates (Simplified)
    projectTo3D: (x, y, distance, width, height) => {
        const nx = (x - width / 2) / (width / 2);
        const ny = -(y - height / 2) / (height / 2); // Flip Y
        const tanFOV = Math.tan((CONFIG.PHYSICS.FOV_H / 2) * Math.PI / 180);
        return {
            x: nx * distance * tanFOV * (width/height), // Aspect ratio correction
            y: ny * distance * tanFOV,
            z: -distance
        };
    }
};

// --- 3D ENGINE MODULE (THREE.JS) ---
class SceneManager {
    constructor() {
        this.canvas = document.getElementById('layer-3d');
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, alpha: true, antialias: true });
        
        this.initScene();
        window.addEventListener('resize', () => this.resize());
        this.resize();
        
        this.objects3D = new Map(); // Store 3D meshes by Track ID
    }

    initScene() {
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        this.scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0x0affc2, 0.5);
        dirLight.position.set(0, 10, 0);
        this.scene.add(dirLight);

        // Ground Grid (Cyberpunk Style)
        const gridHelper = new THREE.GridHelper(100, 50, 0x008f7a, 0x002211);
        gridHelper.position.y = -2;
        this.scene.add(gridHelper);
    }

    updateEntities(trackedObjects) {
        // Remove stale objects
        const currentIds = trackedObjects.map(t => t.id);
        for (let [id, mesh] of this.objects3D) {
            if (!currentIds.includes(id)) {
                this.scene.remove(mesh);
                this.objects3D.delete(id);
            }
        }

        // Add/Update objects
        trackedObjects.forEach(obj => {
            if (!this.objects3D.has(obj.id)) {
                // Create new Mesh
                const geometry = new THREE.WireframeGeometry(new THREE.BoxGeometry(1, 2, 1));
                const material = new THREE.LineBasicMaterial({ color: 0x0affc2, linewidth: 2 });
                const mesh = new THREE.LineSegments(geometry, material);
                this.scene.add(mesh);
                this.objects3D.set(obj.id, mesh);
            }

            // Update Position based on Physics Engine
            const mesh = this.objects3D.get(obj.id);
            if (obj.worldPos) {
                // Interpolate for smoothness
                mesh.position.lerp(new THREE.Vector3(obj.worldPos.x, -1, obj.worldPos.z), 0.2);
                mesh.rotation.y += 0.02; // Idle animation
            }
        });

        this.renderer.render(this.scene, this.camera);
    }

    resize() {
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
    }
}

// --- TRACKING & PHYSICS KERNEL ---
class TrackerKernel {
    constructor() {
        this.tracks = []; // { id, bbox, label, score, lastSeen, worldPos, velocity }
        this.nextId = 1;
    }

    update(detections, videoWidth, videoHeight) {
        // 1. Prediction Step (Velocity) - Simple Linear Filter
        this.tracks.forEach(t => {
            t.lastSeen++;
            // Predict next position if we had velocity (not implemented fully in this simplified block but structure is here)
        });

        const newTracks = [];

        // 2. Data Association (Hungarian Algorithm simplified to Greedy IOU)
        detections.forEach(det => {
            let bestMatch = null;
            let maxIOU = 0;

            this.tracks.forEach(track => {
                const iou = MathUtils.getIOU(det.bbox, track.bbox);
                if (iou > maxIOU) {
                    maxIOU = iou;
                    bestMatch = track;
                }
            });

            if (bestMatch && maxIOU > CONFIG.TRACKING.IOU_THRESHOLD) {
                // Update existing track
                bestMatch.bbox = det.bbox;
                bestMatch.score = det.score;
                bestMatch.lastSeen = 0; // Reset counter
                bestMatch.label = det.class;
                
                // 3. Physics Calculation
                const distance = MathUtils.getDistance(det.bbox[3]); // Height
                const center = [det.bbox[0] + det.bbox[2]/2, det.bbox[1] + det.bbox[3]/2];
                bestMatch.distance = distance;
                bestMatch.worldPos = MathUtils.projectTo3D(center[0], center[1], distance, videoWidth, videoHeight);
                
                newTracks.push(bestMatch);
            } else {
                // Create new track
                const distance = MathUtils.getDistance(det.bbox[3]);
                const center = [det.bbox[0] + det.bbox[2]/2, det.bbox[1] + det.bbox[3]/2];
                newTracks.push({
                    id: this.nextId++,
                    bbox: det.bbox,
                    label: det.class,
                    score: det.score,
                    lastSeen: 0,
                    distance: distance,
                    worldPos: MathUtils.projectTo3D(center[0], center[1], distance, videoWidth, videoHeight)
                });
            }
        });

        // 4. Persistence (Keep lost tracks for a few frames)
        this.tracks.forEach(t => {
            if (t.lastSeen > 0 && t.lastSeen < CONFIG.TRACKING.MAX_LOST_FRAMES) {
                // Keep it, but mark as stale
                newTracks.push(t);
            }
        });

        this.tracks = newTracks;
        return this.tracks;
    }
}

// --- MAIN SYSTEM CONTROLLER ---
class OmegaSystem {
    constructor() {
        this.video = document.getElementById('camera-feed');
        this.hudCanvas = document.getElementById('layer-hud');
        this.hudCtx = this.hudCanvas.getContext('2d');
        
        this.sceneManager = new SceneManager(); // 3D System
        this.tracker = new TrackerKernel();     // Physics & Logic System
        this.models = { object: null, face: null };
        
        this.state = { isRunning: false, frames: 0, lastTime: 0 };
        this.logger = document.getElementById('log-output');
        
        window.addEventListener('resize', () => this.resize());
        this.resize();
    }

    log(msg) {
        this.logger.innerHTML += `<div>> ${msg}</div>`;
        this.logger.scrollTop = this.logger.scrollHeight;
        
        // Also update tactical feed in UI
        const tacFeed = document.getElementById('tactical-feed');
        if(tacFeed) {
            tacFeed.innerHTML = `<div>> ${msg}</div>` + tacFeed.innerHTML;
        }
    }

    resize() {
        this.hudCanvas.width = window.innerWidth;
        this.hudCanvas.height = window.innerHeight;
    }

    async boot() {
        try {
            this.log("Initializing Neural Networks...");
            this.models.object = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
            
            if (CONFIG.AI.FACE_MESH) {
                this.log("Loading Biometric Mesh...");
                this.models.face = await faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages.mediapipeFacemesh);
            }

            this.log("Accessing Optical Sensors...");
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
            });
            this.video.srcObject = stream;
            
            await new Promise(r => this.video.onloadedmetadata = () => {
                this.video.play();
                r();
            });

            this.log("SYSTEM READY.");
            document.querySelector('.loader').style.borderTopColor = "#0affc2";
            document.getElementById('btn-start').style.display = 'block';
            
        } catch (e) {
            this.log(`CRITICAL ERROR: ${e.message}`);
        }
    }

    start() {
        document.getElementById('boot-screen').style.display = 'none';
        this.state.isRunning = true;
        this.runLoop();
    }

    async runLoop() {
        if (!this.state.isRunning) return;

        const now = performance.now();
        const delta = now - this.state.lastTime;
        this.state.frames++;
        
        // 1. AI DETECTION
        let faces = [];
        const objects = await this.models.object.detect(this.video, CONFIG.AI.MAX_OBJECTS, CONFIG.AI.OBJ_CONFIDENCE);
        
        if (CONFIG.AI.FACE_MESH) {
            faces = await this.models.face.estimateFaces({ input: this.video });
        }

        // 2. PHYSICS & TRACKING UPDATE
        const trackedEntities = this.tracker.update(objects, this.video.videoWidth, this.video.videoHeight);
        
        // 3. 3D SCENE UPDATE
        this.sceneManager.updateEntities(trackedEntities);

        // 4. HUD RENDER
        this.renderHUD(trackedEntities, faces);
        
        // 5. UI & RADAR UPDATE
        this.updateUI(trackedEntities, now);

        this.state.lastTime = now;
        requestAnimationFrame(() => this.runLoop());
    }

    renderHUD(tracks, faces) {
        const ctx = this.hudCtx;
        ctx.clearRect(0, 0, this.hudCanvas.width, this.hudCanvas.height);
        
        // Scale factors
        const sx = this.hudCanvas.width / this.video.videoWidth;
        const sy = this.hudCanvas.height / this.video.videoHeight;

        // Draw Object Brackets
        tracks.forEach(t => {
            if (t.lastSeen > 2) return; // Don't draw ghost tracks

            const x = t.bbox[0] * sx;
            const y = t.bbox[1] * sy;
            const w = t.bbox[2] * sx;
            const h = t.bbox[3] * sy;
            
            const color = t.label === 'person' ? '#ff2a6d' : '#0affc2';

            // High-Tech Corners
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            const L = 15;
            ctx.moveTo(x, y+L); ctx.lineTo(x, y); ctx.lineTo(x+L, y); // TL
            ctx.moveTo(x+w-L, y); ctx.lineTo(x+w, y); ctx.lineTo(x+w, y+L); // TR
            ctx.moveTo(x+w, y+h-L); ctx.lineTo(x+w, y+h); ctx.lineTo(x+w-L, y+h); // BR
            ctx.moveTo(x+L, y+h); ctx.lineTo(x, y+h); ctx.lineTo(x, y+h-L); // BL
            ctx.stroke();

            // Info Block
            ctx.fillStyle = color;
            ctx.font = "10px Courier New";
            ctx.fillText(`ID:${t.id} ${t.label.toUpperCase()}`, x, y - 15);
            ctx.fillText(`DIST:${t.distance.toFixed(1)}m`, x, y - 5);
        });

        // Draw Face Mesh
        if (faces) {
            ctx.fillStyle = '#00d2ff';
            faces.forEach(face => {
                face.scaledMesh.forEach((pt, i) => {
                    if (i % 5 === 0) { // Optimization
                        ctx.fillRect(pt[0] * sx, pt[1] * sy, 1, 1);
                    }
                });
            });
        }
    }

    updateUI(tracks, now) {
        // FPS
        if (this.state.frames % 10 === 0) {
            document.getElementById('ui-fps').innerText = Math.round(1000 / (now - this.state.lastTime));
        }
        
        // Object Count
        document.getElementById('ui-obj').innerText = tracks.length;

        // Threat Level
        const persons = tracks.filter(t => t.label === 'person');
        const threatEl = document.getElementById('ui-threat');
        if (persons.length > 0) {
            const nearest = Math.min(...persons.map(p => p.distance));
            if (nearest < 2.0) {
                threatEl.innerText = "CRITICAL";
                threatEl.className = "val alert";
            } else {
                threatEl.innerText = "CAUTION";
                threatEl.className = "val";
                threatEl.style.color = "#ffae00";
            }
        } else {
            threatEl.innerText = "SAFE";
            threatEl.style.color = "#0affc2";
        }

        // Radar Update
        const radarBox = document.getElementById('radar-box');
        // Clear old blips (keep scanner)
        Array.from(radarBox.getElementsByClassName('blip')).forEach(e => e.remove());
        
        tracks.forEach(t => {
            if (t.lastSeen > 5) return;
            const blip = document.createElement('div');
            blip.className = 'blip';
            
            // Map 3D X/Z to 2D radar (Top down view)
            // Scale: 160px width = 20 meters range
            const range = 20; 
            const scale = 80 / range; // Radius 80px
            
            let rx = (t.worldPos.x * scale) + 80;
            let ry = (-t.worldPos.z * scale) + 80;
            
            // Clamp inside radar
            if (Math.sqrt(Math.pow(rx-80, 2) + Math.pow(ry-80, 2)) < 80) {
                blip.style.left = `${rx}px`;
                blip.style.top = `${ry}px`;
                if (t.label !== 'person') blip.style.background = '#0affc2';
                radarBox.appendChild(blip);
            }
        });
    }
}

// --- INITIALIZATION ---
const OMEGA = new OmegaSystem();
window.addEventListener('load', () => OMEGA.boot());
document.getElementById('btn-start').addEventListener('click', () => OMEGA.start());

</script>
</body>
</html>
