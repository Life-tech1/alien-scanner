<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>OMEGA: LOCK-ON TRACKER</title>

  <!-- AI Core (เดิม) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2"></script>

  <!-- AI Add-on (ใหม่: Scene/Context) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0"></script>

  <!-- 3D Engine (เดิม) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <style>
    /* --- THEME: TACTICAL HUD --- */
    :root {
      --p: #00ff9d; --s: #008f7a; --a: #ff2a6d;
      --bg: #000; --glass: rgba(0, 15, 10, 0.85);
      --font: 'Segoe UI', 'Courier New', sans-serif;
    }

    body { margin: 0; overflow: hidden; background: var(--bg); color: var(--p); font-family: var(--font); }

    #viewport { position: relative; width: 100vw; height: 100vh; touch-action: none; }

    /* LAYERS */
    #camera-feed { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0.8; z-index: 0; }
    #layer-3d { position: absolute; inset: 0; z-index: 5; pointer-events: none; }
    #hud-canvas { position: absolute; inset: 0; z-index: 10; pointer-events: none; }

    /* UI OVERLAY */
    #ui-layer { position: absolute; inset: 0; z-index: 20; padding: 20px; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }

    .panel {
      background: var(--glass); border-left: 3px solid var(--p);
      padding: 10px 15px; margin-bottom: 5px; backdrop-filter: blur(5px);
      pointer-events: auto; width: fit-content; border-radius: 0 5px 5px 0;
      box-shadow: 0 0 15px rgba(0,255,157,0.1);
    }
    .label { font-size: 10px; color: #00a8ff; font-weight: bold; letter-spacing: 2px; }
    .val { font-size: 14px; color: #fff; font-weight: bold; font-family: monospace; }

    /* COMPASS STRIP */
    #compass-bar {
      position: absolute; top: 0; left: 0; width: 100%; height: 40px;
      background: linear-gradient(to bottom, #000, transparent);
      z-index: 15; display: flex; justify-content: center; overflow: hidden;
      border-bottom: 1px solid rgba(0,255,157,0.3);
    }
    #compass-ticks { display: flex; transition: transform 0.1s; width: 2000px; font-family: monospace; font-weight: bold; }
    .tick { width: 50px; text-align: center; border-left: 1px solid var(--s); height: 10px; margin-top: 5px; color: #fff; }
    .compass-marker { position: absolute; top: 0; left: 50%; width: 2px; height: 30px; background: var(--a); transform: translateX(-50%); }

    /* RADAR */
    #radar {
      position: absolute; bottom: 30px; right: 20px;
      width: 120px; height: 120px; border-radius: 50%;
      background: rgba(0,20,10,0.9); border: 2px solid var(--s);
      overflow: hidden; pointer-events: auto; z-index: 25;
    }
    .blip { position: absolute; width: 6px; height: 6px; background: var(--a); border-radius: 50%; transform: translate(-50%,-50%); box-shadow: 0 0 5px var(--a); transition: all 0.2s; }

    /* BOOT SCREEN */
    #boot { position: fixed; inset: 0; background: #000; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; }
    #loader { width: 50px; height: 50px; border: 3px solid #333; border-top: 3px solid var(--p); border-radius: 50%; animation: spin 1s infinite; margin: 20px; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    button { background: transparent; border: 1px solid var(--p); color: var(--p); padding: 10px 30px; font-weight: bold; cursor: pointer; border-radius: 20px; }
    button:hover { background: var(--p); color: #000; }

    /* (เพิ่มใหม่) ปุ่มจิ๋วในธีมเดิม ไม่เปลี่ยนดีไซน์ */
    .mini-btn {
      display: inline-flex; align-items:center; gap:6px;
      padding: 4px 10px; font-size: 11px; border-radius: 12px;
      border: 1px solid var(--s); color:#fff; background: rgba(0,0,0,0.3);
      cursor:pointer; user-select:none;
    }
    .mini-btn.active { border-color: var(--a); box-shadow:0 0 8px rgba(255,42,109,0.4); }
  </style>
</head>
<body>

  <div id="viewport">
    <video id="camera-feed" autoplay playsinline muted></video>
    <canvas id="layer-3d"></canvas>
    <canvas id="hud-canvas"></canvas>

    <!-- COMPASS -->
    <div id="compass-bar">
      <div id="compass-ticks"></div>
      <div class="compass-marker"></div>
    </div>

    <div id="ui-layer">
      <div>
        <!-- เดิม -->
        <div class="panel">
          <div class="label">SYSTEM STATUS</div>
          <div>FPS: <span id="fps" class="val">0</span> | OBJ: <span id="obj-count" class="val">0</span></div>
        </div>
        <div class="panel">
          <div class="label">SENSORS</div>
          <div>HDG: <span id="hdg" class="val" style="color:var(--a)">--°</span></div>
        </div>

        <!-- ใหม่: Primary/Lock panel (ธีมเดิม) -->
        <div class="panel">
          <div class="label">TARGETING</div>
          <div>
            PRI: <span id="pri-class" class="val">--</span>
            | RNG: <span id="pri-dist" class="val">--</span>
            | BRG: <span id="pri-brg" class="val">--</span>
          </div>
          <div style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap;">
            <div id="btn-lock" class="mini-btn">LOCK: <span id="lock-status">AUTO</span></div>
            <div id="btn-voice" class="mini-btn">VOICE: <span id="voice-status">OFF</span></div>
          </div>
        </div>

        <!-- ใหม่: Scene Context AI -->
        <div class="panel">
          <div class="label">CONTEXT AI</div>
          <div>SCENE: <span id="scene-label" class="val">--</span> (<span id="scene-conf" class="val">--</span>)</div>
        </div>
      </div>

      <div id="radar">
        <div style="position:absolute; inset:0; background: conic-gradient(transparent 270deg, var(--s)); opacity: 0.3; animation: scan 3s linear infinite;"></div>
        <style>@keyframes scan{to{transform: rotate(360deg);}}</style>
      </div>
    </div>
  </div>

  <div id="boot">
    <h1 style="color:var(--p); letter-spacing: 5px; text-shadow: 0 0 20px var(--p);">OMEGA</h1>
    <div style="color:#888;">LOCK-ON SYSTEM</div>
    <div id="loader"></div>
    <div style="margin-top:20px;">
      <button id="btn-start" onclick="OMEGA.start()" style="display:none;">INITIALIZE</button>
    </div>
  </div>

<script>
/**
 * OMEGA: LOCK-ON EDITION — SpaceX/Tesla-grade Web Single-file
 * - No design changes, no system removals.
 * - Added predictive multi-target tracking, performance governor,
 *   primary target scoring, tap-to-lock, context AI, voice agent.
 */
(() => {
  "use strict";

  const CFG = {
    AI_CONF: 0.55,
    SMOOTH_FACTOR: 0.2,     // เดิม: ค่ายิ่งน้อยยิ่งหนึบ
    MAX_TRACKS: 15,
    MAX_LOST: 8,
    DETECT_INTERVAL: 120,  // ms — แยก detect loop เพื่อคุมโหลด
    AI_INPUT_W: 640,        // downscale before detect
    AI_MIN_W: 320,
    AI_MAX_W: 960,
    CONTEXT_INTERVAL: 2000, // ms — scene classify
    PHYSICS: { FOV: 60, CAM_H: 1.5 },
    PRIMARY_SCORE: {
      centerW: 0.55,
      areaW:   0.35,
      personBoost: 0.25
    },
    VOICE_COOLDOWN: 1400
  };

  // ---------- Math Utils ----------
  const MathUtils = {
    iou: (b1, b2) => {
      const x1 = Math.max(b1[0], b2[0]), y1 = Math.max(b1[1], b2[1]);
      const x2 = Math.min(b1[0]+b1[2], b2[0]+b2[2]), y2 = Math.min(b1[1]+b1[3], b2[1]+b2[3]);
      const inter = Math.max(0, x2-x1) * Math.max(0, y2-y1);
      const union = (b1[2]*b1[3]) + (b2[2]*b2[3]) - inter;
      return union <= 0 ? 0 : inter / union;
    },
    lerp: (a,b,t) => (1-t)*a + t*b,
    lerpBox: (o, n, t) => [
      MathUtils.lerp(o[0], n[0], t),
      MathUtils.lerp(o[1], n[1], t),
      MathUtils.lerp(o[2], n[2], t),
      MathUtils.lerp(o[3], n[3], t)
    ],
    clamp: (v,min,max)=>Math.max(min,Math.min(max,v))
  };

  // ---------- Track Object ----------
  class Track {
    constructor(det, id, now) {
      this.id = id;
      this.class = det.class;
      this.bbox = det.bbox.slice();  // smoothed box
      this.rawBox = det.bbox.slice();// raw det for IOU next time
      this.center = [det.bbox[0]+det.bbox[2]/2, det.bbox[1]+det.bbox[3]/2];
      this.dist = (1.7 * 800) / det.bbox[3];
      this.lost = 0;
      this.lastSeen = now;

      this.vx = 0; this.vy = 0; this.vw = 0; this.vh = 0; // velocity terms
    }

    predict(dt) {
      if (!dt || dt > 0.2) return; // dt too large, skip prediction
      this.bbox[0] += this.vx * dt;
      this.bbox[1] += this.vy * dt;
      this.bbox[2] += this.vw * dt;
      this.bbox[3] += this.vh * dt;
    }

    updateFromDet(det, dt, smoothBase) {
      const old = this.bbox.slice();
      const newBox = det.bbox;

      // adaptive smoothing: if IOU high -> less smoothing; jitter low -> more smoothing
      const iou = MathUtils.iou(this.rawBox, newBox);
      const t = MathUtils.clamp(smoothBase * (1.2 - iou), 0.08, 0.6);

      this.bbox = MathUtils.lerpBox(old, newBox, t);
      this.rawBox = newBox.slice();
      this.class = det.class;
      this.lost = 0;

      // velocity update (constant velocity model)
      if (dt && dt > 0) {
        this.vx = (this.bbox[0]-old[0]) / dt;
        this.vy = (this.bbox[1]-old[1]) / dt;
        this.vw = (this.bbox[2]-old[2]) / dt;
        this.vh = (this.bbox[3]-old[3]) / dt;
      }

      this.center = [this.bbox[0]+this.bbox[2]/2, this.bbox[1]+this.bbox[3]/2];
      this.dist = (1.7 * 800) / this.bbox[3];
      this.lastSeen = performance.now();
    }
  }

  // ---------- Sticky Tracker V2 (เดิม + predictive) ----------
  class StickyTracker {
    constructor() {
      this.tracks = [];
      this.nextId = 1;
    }

    update(detections, dtSec) {
      const now = performance.now();
      const tracks = this.tracks;

      // predict step
      tracks.forEach(t => t.predict(dtSec));

      const assignedTracks = new Set();
      const newTracks = [];

      // greedy IOU matching (fast & stable for small N)
      detections.forEach(det => {
        let best = null;
        let bestIOU = 0;

        for (const t of tracks) {
          if (assignedTracks.has(t.id)) continue;
          const iou = MathUtils.iou(det.bbox, t.rawBox || t.bbox);
          if (iou > bestIOU) { bestIOU = iou; best = t; }
        }

        if (best && bestIOU > 0.28) {
          best.updateFromDet(det, dtSec, CFG.SMOOTH_FACTOR);
          assignedTracks.add(best.id);
          newTracks.push(best);
        } else {
          // new target
          newTracks.push(new Track(det, this.nextId++, now));
        }
      });

      // ghost tracking for a few frames
      tracks.forEach(t => {
        if (assignedTracks.has(t.id)) return;
        t.lost++;
        if (t.lost <= CFG.MAX_LOST) newTracks.push(t);
      });

      // cap tracks
      newTracks.sort((a,b)=>a.lost-b.lost);
      this.tracks = newTracks.slice(0, CFG.MAX_TRACKS);

      return this.tracks;
    }
  }

  // ---------- HUD Renderer (เดิม + primary/lock highlight) ----------
  class HUD {
    constructor() {
      this.canvas = document.getElementById('hud-canvas');
      this.ctx = this.canvas.getContext('2d');
      this.radar = document.getElementById('radar');
      this.resize();

      this.lastScale = { sx:1, sy:1, vw:1, vh:1 };

      // 3D Scene (เดิม)
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(
        CFG.PHYSICS.FOV,
        window.innerWidth/window.innerHeight,
        0.1, 1000
      );
      this.renderer3D = new THREE.WebGLRenderer({
        canvas: document.getElementById('layer-3d'), alpha:true
      });
      this.renderer3D.setSize(window.innerWidth, window.innerHeight);
    }

    resize() {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      if(this.renderer3D) {
        this.renderer3D.setSize(window.innerWidth, window.innerHeight);
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
      }
    }

    render(video, tracks, heading, primaryId, lockedId) {
      const ctx = this.ctx;
      ctx.clearRect(0,0, this.canvas.width, this.canvas.height);

      // Scale factors
      const sx = this.canvas.width / video.videoWidth;
      const sy = this.canvas.height / video.videoHeight;
      this.lastScale = { sx, sy, vw: video.videoWidth, vh: video.videoHeight };

      const cx = this.canvas.width / 2;
      const cy = this.canvas.height / 2;

      // Crosshair (เดิม)
      ctx.strokeStyle = 'rgba(0, 255, 157, 0.5)';
      ctx.beginPath();
      ctx.moveTo(cx-10, cy); ctx.lineTo(cx+10, cy);
      ctx.moveTo(cx, cy-10); ctx.lineTo(cx, cy+10);
      ctx.stroke();

      tracks.forEach(t => {
        if (t.lost > 0) return;

        const [x,y,w,h] = t.bbox;
        const scrX = x*sx, scrY = y*sy, scrW = w*sx, scrH = h*sy;
        const centerX = scrX + scrW/2;
        const centerY = scrY + scrH/2;

        const isPrimary = t.id === primaryId;
        const isLocked = t.id === lockedId;

        const color = t.class === 'person' ? '#ff2a6d' : '#00ff9d';

        // Lock-on line (เดิม)
        ctx.strokeStyle = color;
        ctx.lineWidth = isPrimary ? 1.8 : 1;
        ctx.setLineDash([2, 4]);
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(centerX, centerY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Sticky corner box (เดิม)
        ctx.lineWidth = isPrimary ? 3 : 2;
        ctx.beginPath();
        const L = scrW * 0.2;
        // TL
        ctx.moveTo(scrX, scrY+L); ctx.lineTo(scrX, scrY); ctx.lineTo(scrX+L, scrY);
        // TR
        ctx.moveTo(scrX+scrW-L, scrY); ctx.lineTo(scrX+scrW, scrY); ctx.lineTo(scrX+scrW, scrY+L);
        // BR
        ctx.moveTo(scrX+scrW, scrY+scrH-L); ctx.lineTo(scrX+scrW, scrY+scrH); ctx.lineTo(scrX+scrW-L, scrY+scrH);
        // BL
        ctx.moveTo(scrX+L, scrY+scrH); ctx.lineTo(scrX, scrY+scrH); ctx.lineTo(scrX, scrY+scrH-L);
        ctx.stroke();

        // subtle lock reticle (ใหม่ แต่โทนเดิม)
        if (isLocked) {
          ctx.strokeStyle = color;
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          const r = Math.min(scrW, scrH) * 0.12;
          ctx.arc(centerX, centerY, r, 0, Math.PI*2);
          ctx.stroke();
        }

        // Info label (เดิม)
        ctx.fillStyle = color;
        ctx.font = "bold 11px monospace";
        ctx.fillText(`${t.class.toUpperCase()} [${t.dist.toFixed(1)}m]`, scrX, scrY - 10);
      });

      this.updateRadar(tracks, video.videoWidth);

      this.camera.rotation.y = THREE.Math.degToRad(-heading);
      this.renderer3D.render(this.scene, this.camera);
    }

    updateRadar(tracks, vw) {
      const old = this.radar.getElementsByClassName('blip');
      while(old[0]) old[0].remove();

      tracks.forEach(t => {
        if(t.lost > 0) return;

        const blip = document.createElement('div');
        blip.className = 'blip';

        const centerObjX = t.bbox[0] + t.bbox[2]/2;
        const angleRatio = (centerObjX / vw) - 0.5;
        const angle = angleRatio * (CFG.PHYSICS.FOV * Math.PI/180);

        const r = Math.min(t.dist * 2, 55);

        const rx = 60 + Math.sin(angle) * r;
        const ry = 60 - Math.cos(angle) * r;

        blip.style.left = rx + 'px';
        blip.style.top = ry + 'px';
        if(t.class !== 'person') blip.style.background = '#00ff9d';

        this.radar.appendChild(blip);
      });
    }

    // convert track center to screen for tap-lock
    trackCenterScreen(t) {
      const {sx, sy} = this.lastScale;
      return [t.center[0]*sx, t.center[1]*sy];
    }
  }

  // ---------- Voice Agent (ใหม่) ----------
  class VoiceAgent {
    constructor() {
      this.enabled = false;
      this.lastSpeak = 0;
      this.synth = window.speechSynthesis || null;
    }
    toggle() { this.enabled = !this.enabled; return this.enabled; }
    speak(text) {
      if(!this.enabled || !this.synth) return;
      const now = performance.now();
      if(now - this.lastSpeak < CFG.VOICE_COOLDOWN) return;
      this.lastSpeak = now;

      const u = new SpeechSynthesisUtterance(text);
      u.lang = "en-US";
      u.rate = 1.02; u.pitch = 1.0; u.volume = 0.9;
      this.synth.cancel();
      this.synth.speak(u);
    }
  }

  // ---------- Main System ----------
  class OmegaSystem {
    constructor() {
      this.video = document.getElementById('camera-feed');
      this.tracker = new StickyTracker();
      this.hud = new HUD();
      this.model = null;
      this.contextModel = null;
      this.heading = 0;
      this.tracks = [];
      this.primaryId = null;
      this.lockedId = null;
      this.voice = new VoiceAgent();

      this.aiCanvas = document.createElement('canvas');
      this.aiCtx = this.aiCanvas.getContext('2d');

      // Compass strip gen (เดิม)
      const strip = document.getElementById('compass-ticks');
      let h = '';
      for(let i=0;i<3;i++){
        for(let d=0; d<360; d+=10){
          let l = d===0?'N':d===90?'E':d===180?'S':d===270?'W':d;
          h += `<div class="tick">${l}</div>`;
        }
      }
      strip.innerHTML = h;

      window.onresize = () => this.hud.resize();

      // Sensors (เดิม)
      window.addEventListener('deviceorientation', e => {
        this.heading = e.webkitCompassHeading || Math.abs(e.alpha - 360);
        document.getElementById('hdg').innerText = Math.round(this.heading) + '°';
        strip.style.transform = `translateX(-${this.heading * 5}px)`;
      }, true);

      // Tap-to-lock (ใหม่)
      const viewport = document.getElementById('viewport');
      viewport.addEventListener('pointerdown', (ev) => {
        const x = ev.clientX, y = ev.clientY;
        const t = this.pickTrackAt(x,y);
        if (t) {
          this.lockedId = (this.lockedId === t.id) ? null : t.id;
          this.updateLockUI();
          if (this.lockedId) this.voice.speak(`Locked on ${t.class}, ${t.dist.toFixed(1)} meters.`);
        } else {
          this.lockedId = null;
          this.updateLockUI();
        }
      });

      // UI buttons
      document.getElementById('btn-lock').onclick = () => {
        this.lockedId = null;
        this.updateLockUI();
      };
      document.getElementById('btn-voice').onclick = () => {
        const on = this.voice.toggle();
        document.getElementById('voice-status').innerText = on ? "ON" : "OFF";
        document.getElementById('btn-voice').classList.toggle('active', on);
        if(on) this.voice.speak("Voice online.");
      };

      this.updateLockUI();
    }

    updateLockUI() {
      const lockStatus = document.getElementById('lock-status');
      const btnLock = document.getElementById('btn-lock');
      if(this.lockedId) {
        lockStatus.innerText = `ID-${this.lockedId}`;
        btnLock.classList.add('active');
      } else {
        lockStatus.innerText = "AUTO";
        btnLock.classList.remove('active');
      }
    }

    async start() {
      const btn = document.getElementById('btn-start');
      btn.innerText = "LOADING CORE...";

      try {
        // Request sensors
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          await DeviceOrientationEvent.requestPermission();
        }

        // Camera
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: {ideal: 1280} },
          audio: false
        });
        this.video.srcObject = stream;
        await new Promise(r => this.video.onloadedmetadata = () => { this.video.play(); r(); });

        // AI detect model (เดิม)
        this.model = await cocoSsd.load({base: 'lite_mobilenet_v2'});

        // Context model (ใหม่) — fail-safe
        try {
          this.contextModel = await mobilenet.load();
        } catch(_err) {
          this.contextModel = null;
        }

        document.getElementById('boot').style.display = 'none';

        // start loops
        this.lastDetectTime = performance.now();
        this.startDetectLoop();
        this.startContextLoop();
        this.renderLoop();

      } catch(e) {
        alert("Error: " + e.message);
      }
    }

    // ---- Performance Governor: downscale input dynamically ----
    drawAIInput() {
      const v = this.video;
      if(!v.videoWidth) return false;

      const targetW = CFG.AI_INPUT_W;
      const scale = targetW / v.videoWidth;
      const targetH = Math.round(v.videoHeight * scale);

      this.aiCanvas.width = targetW;
      this.aiCanvas.height = targetH;
      this.aiCtx.drawImage(v, 0,0, targetW, targetH);
      return true;
    }

    async startDetectLoop() {
      const detectOnce = async () => {
        if(!this.model || !this.video.videoWidth) return;

        const now = performance.now();
        const dtSec = (now - this.lastDetectTime) / 1000;
        this.lastDetectTime = now;

        // input
        if(!this.drawAIInput()) return;

        // detect
        const detections = await this.model.detect(this.aiCanvas, 20, CFG.AI_CONF);

        // scale boxes back to video coords
        const scaleBack = this.video.videoWidth / this.aiCanvas.width;
        detections.forEach(d => {
          d.bbox[0] *= scaleBack;
          d.bbox[1] *= scaleBack;
          d.bbox[2] *= scaleBack;
          d.bbox[3] *= scaleBack;
        });

        // tracking
        this.tracks = this.tracker.update(detections, dtSec);

        // select primary target
        const oldPrimary = this.primaryId;
        this.primaryId = this.selectPrimary(this.tracks);
        if(oldPrimary !== this.primaryId && this.primaryId != null) {
          const t = this.tracks.find(x=>x.id===this.primaryId);
          if(t) this.voice.speak(`Primary target ${t.class}, ${t.dist.toFixed(1)} meters.`);
        }

        // update stats panel
        document.getElementById('obj-count').innerText = this.tracks.length;

        // adaptive AI input based on FPS (simple governor)
        const fps = this.lastFPS || 30;
        if(fps < 18) CFG.AI_INPUT_W = MathUtils.clamp(CFG.AI_INPUT_W - 80, CFG.AI_MIN_W, CFG.AI_MAX_W);
        if(fps > 35) CFG.AI_INPUT_W = MathUtils.clamp(CFG.AI_INPUT_W + 40, CFG.AI_MIN_W, CFG.AI_MAX_W);
      };

      const loop = async () => {
        await detectOnce();
        setTimeout(loop, CFG.DETECT_INTERVAL);
      };
      loop();
    }

    async startContextLoop() {
      if(!this.contextModel) return;
      const loop = async () => {
        try {
          if(!this.drawAIInput()) return;
          const preds = await this.contextModel.classify(this.aiCanvas);
          if(preds && preds[0]) {
            document.getElementById('scene-label').innerText = preds[0].className.split(',')[0];
            document.getElementById('scene-conf').innerText = (preds[0].probability*100).toFixed(0) + "%";
          }
        } catch(_e){}
        setTimeout(loop, CFG.CONTEXT_INTERVAL);
      };
      loop();
    }

    renderLoop() {
      const start = performance.now();

      // render HUD continuously with latest tracks
      if(this.video.videoWidth) {
        this.hud.render(this.video, this.tracks, this.heading, this.primaryId, this.lockedId);
      }

      const dt = performance.now()-start;
      const fps = Math.round(1000/dt);
      this.lastFPS = fps;
      document.getElementById('fps').innerText = fps;

      // update target panel
      this.updateTargetPanel();

      requestAnimationFrame(()=>this.renderLoop());
    }

    updateTargetPanel() {
      const t = this.getPrimaryTrack();
      if(!t) {
        document.getElementById('pri-class').innerText = "--";
        document.getElementById('pri-dist').innerText = "--";
        document.getElementById('pri-brg').innerText = "--";
        return;
      }
      const brg = this.computeBearingDeg(t);
      document.getElementById('pri-class').innerText = t.class.toUpperCase() + `#${t.id}`;
      document.getElementById('pri-dist').innerText = t.dist.toFixed(1) + "m";
      document.getElementById('pri-brg').innerText = (brg>=0?"+":"") + brg.toFixed(0) + "°";
    }

    getPrimaryTrack() {
      if(this.lockedId) return this.tracks.find(x=>x.id===this.lockedId) || null;
      return this.tracks.find(x=>x.id===this.primaryId) || null;
    }

    // primary scoring (ใกล้กลางจอ, ใหญ่, คนได้โบนัส)
    selectPrimary(tracks) {
      if(this.lockedId) return this.lockedId;
      if(!tracks || tracks.length===0) return null;

      const vw = this.video.videoWidth;
      const vh = this.video.videoHeight;
      const cx = vw/2, cy = vh/2;

      let bestId = null, bestScore = -Infinity;
      for(const t of tracks) {
        if(t.lost>0) continue;
        const dx = (t.center[0]-cx)/vw;
        const dy = (t.center[1]-cy)/vh;
        const centerScore = 1 - Math.sqrt(dx*dx+dy*dy); // 0..1
        const areaScore = MathUtils.clamp((t.bbox[2]*t.bbox[3])/(vw*vh)*6, 0, 1);

        let score = centerScore*CFG.PRIMARY_SCORE.centerW + areaScore*CFG.PRIMARY_SCORE.areaW;
        if(t.class==='person') score += CFG.PRIMARY_SCORE.personBoost;

        if(score>bestScore){ bestScore=score; bestId=t.id; }
      }
      return bestId;
    }

    computeBearingDeg(t) {
      // bearing relative to screen center using FOV
      const vw = this.video.videoWidth;
      const ratio = (t.center[0]/vw)-0.5; // -0.5..0.5
      return ratio * CFG.PHYSICS.FOV;
    }

    // pick nearest track on tap
    pickTrackAt(screenX, screenY) {
      let best=null, bestDist=1e9;
      for(const t of this.tracks) {
        if(t.lost>0) continue;
        const [sx, sy] = this.hud.trackCenterScreen(t);
        const d = Math.hypot(sx-screenX, sy-screenY);
        if(d<bestDist && d<90){ bestDist=d; best=t; }
      }
      return best;
    }
  }

  window.OMEGA = new OmegaSystem();
  document.getElementById('btn-start').style.display = 'block';

})();
</script>
</body>
</html>
