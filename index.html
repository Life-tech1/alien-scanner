<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OMEGA: HOLOGRAPHIC AR SYSTEM v4.0</title>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <style>
        /* --- SYSTEM VISUALS (CSS) --- */
        :root {
            --hex-primary: #00ff41;
            --hex-secondary: #008F11;
            --hex-alert: #ff003c;
            --hex-glass: rgba(0, 10, 0, 0.85);
        }

        * { box-sizing: border-box; user-select: none; overflow: hidden; }
        body { margin: 0; background: #000; font-family: 'Courier New', monospace; width: 100vw; height: 100vh; }

        #viewport { position: relative; width: 100%; height: 100%; }

        /* Layer 1: Reality (Camera) */
        #video-feed {
            position: absolute; inset: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: 0;
            filter: contrast(1.2) brightness(0.6) grayscale(0.4); /* Cinematic Look */
        }

        /* Layer 2: Holograms (Three.js) */
        #holo-canvas { position: absolute; inset: 0; z-index: 10; pointer-events: none; }

        /* Layer 3: 2D UI Overlay */
        #ui-layer {
            position: absolute; inset: 0; z-index: 20; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px;
        }

        .panel {
            background: var(--hex-glass); border-left: 2px solid var(--hex-primary);
            padding: 10px; margin: 5px; backdrop-filter: blur(5px);
            color: var(--hex-primary); font-size: 12px; text-shadow: 0 0 5px var(--hex-primary);
            transform: skewX(-10deg); /* Sci-fi aesthetic */
        }

        .loading-screen {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--hex-primary);
        }
        
        .loader-ring {
            width: 50px; height: 50px; border: 4px solid #333;
            border-top: 4px solid var(--hex-primary); border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #btn-init {
            margin-top: 20px; padding: 15px 40px;
            background: transparent; border: 1px solid var(--hex-primary);
            color: var(--hex-primary); font-family: inherit; font-weight: bold;
            cursor: pointer; transition: 0.3s;
        }
        #btn-init:hover { background: var(--hex-primary); color: #000; box-shadow: 0 0 20px var(--hex-primary); }

    </style>
</head>
<body>

    <div class="loading-screen" id="boot-ui">
        <div style="font-size: 40px; letter-spacing: 10px; font-weight: 900;">OMEGA</div>
        <div style="opacity: 0.7; margin-bottom: 20px;">HOLOGRAPHIC CORE v4.0</div>
        <div class="loader-ring"></div>
        <div id="log-text">INITIALIZING KERNEL...</div>
        <button id="btn-init" style="display:none;">ENGAGE SYSTEM</button>
    </div>

    <div id="viewport">
        <video id="video-feed" autoplay playsinline muted></video>
        <canvas id="holo-canvas"></canvas>

        <div id="ui-layer">
            <div style="display:flex; justify-content: space-between;">
                <div class="panel">
                    <div>CPU: <span id="stat-cpu">0</span> ms</div>
                    <div>GPU: <span id="stat-gpu">ONLINE</span></div>
                    <div>OBJ: <span id="stat-obj">0</span></div>
                </div>
                <div class="panel" style="text-align: right;">
                    <div>GYRO-X: <span id="stat-gx">0</span></div>
                    <div>GYRO-Y: <span id="stat-gy">0</span></div>
                </div>
            </div>
            
            <div style="text-align: center; margin-bottom: 50px;">
                <div class="panel" id="target-lock-ui" style="display:inline-block; border-color: var(--hex-alert); color: var(--hex-alert); opacity: 0;">
                    WARNING: TARGET LOCKED
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * ============================================================================
 * OMEGA V4.0 : HOLOGRAPHIC ARCHITECTURE (3D + AI)
 * ============================================================================
 * This system upgrades from 2D Canvas to a full 3D WebGL Scene (Three.js).
 * It maps 2D AI detections into 3D space for true AR visualization.
 * ============================================================================
 */

// --- 1. CONFIGURATION & CONSTANTS ---
const CONFIG = {
    AI: {
        CONFIDENCE: 0.6,
        TICK_RATE: 100, // AI update rate (ms)
        SMOOTHING: 0.2
    },
    HOLO: {
        FOV: 75,
        CAMERA_Z: 5, // Distance of virtual camera
        TARGET_COLOR: 0xff003c,
        SAFE_COLOR: 0x00ff41
    }
};

// --- 2. UTILITIES ---
const Utils = {
    log: (msg) => {
        const el = document.getElementById('log-text');
        if(el) el.innerText = `> ${msg}`;
        console.log(`[KERNEL] ${msg}`);
    },
    map: (val, inMin, inMax, outMin, outMax) => (val - inMin) * (outMax - outMin) / (inMax - inMin) + outMin,
    lerp: (start, end, t) => start * (1 - t) + end * t
};

// --- 3. AVIONICS (SENSORS) ---
class Avionics {
    constructor() {
        this.pitch = 0;
        this.roll = 0;
        this.yaw = 0;
    }

    async init() {
        // Boilerplate for iOS permission
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            await DeviceOrientationEvent.requestPermission();
        }
        window.addEventListener('deviceorientation', (e) => {
            this.pitch = Utils.lerp(this.pitch, e.beta || 0, 0.1);
            this.roll  = Utils.lerp(this.roll, e.gamma || 0, 0.1);
            this.yaw   = Utils.lerp(this.yaw, e.alpha || 0, 0.1);
            
            document.getElementById('stat-gx').innerText = this.pitch.toFixed(1);
            document.getElementById('stat-gy').innerText = this.roll.toFixed(1);
        });
    }
}

// --- 4. HOLOGRAPHIC ENGINE (THREE.JS WRAPPER) ---
class HoloDeck {
    constructor() {
        this.canvas = document.getElementById('holo-canvas');
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(CONFIG.HOLO.FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, alpha: true, antialias: true });
        
        this.targets = new Map(); // Store active 3D target objects
        this.grid = null;
        
        this.initScene();
    }

    initScene() {
        // Setup Renderer
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.camera.position.z = CONFIG.HOLO.CAMERA_Z;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(0, 10, 5);
        this.scene.add(dirLight);

        // Sci-fi Grid Floor (Holographic Floor)
        const gridHelper = new THREE.GridHelper(50, 50, 0x00ff41, 0x003300);
        gridHelper.rotation.x = Math.PI / 2; // Rotate to face camera
        gridHelper.position.z = -10;
        this.scene.add(gridHelper);
        this.grid = gridHelper;

        // Handle Resize
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // Creates a cool sci-fi target bracket
    createTargetMesh() {
        const group = new THREE.Group();
        
        // Material
        const material = new THREE.LineBasicMaterial({ color: CONFIG.HOLO.TARGET_COLOR, transparent: true, opacity: 0.8 });
        
        // Create Corners
        const s = 0.5; // size
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            -s, s, 0,  -s*0.5, s, 0, // Top Left
            -s, s, 0,  -s, s*0.5, 0,
            s, s, 0,   s*0.5, s, 0,  // Top Right
            s, s, 0,   s, s*0.5, 0,
            -s, -s, 0, -s*0.5, -s, 0, // Bot Left
            -s, -s, 0, -s, -s*0.5, 0,
            s, -s, 0,  s*0.5, -s, 0,  // Bot Right
            s, -s, 0,  s, -s*0.5, 0
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        
        const lines = new THREE.LineSegments(geometry, material);
        group.add(lines);

        // Inner rotating circle
        const ringGeo = new THREE.RingGeometry(0.2, 0.22, 32);
        const ringMat = new THREE.MeshBasicMaterial({ color: CONFIG.HOLO.TARGET_COLOR, side: THREE.DoubleSide });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        group.add(ring);
        
        group.userData = { ring: ring }; // Reference for animation
        return group;
    }

    updateTargets(predictions, screenW, screenH) {
        const activeIds = new Set();

        predictions.forEach((pred, index) => {
            // Generate a stable ID (in a real app we'd track properly, here we use index for simplicity in demo)
            const id = `target-${index}`; 
            activeIds.add(id);

            // 1. Convert 2D BBox to 3D Coordinates
            // Normalized Device Coordinates (NDC): -1 to +1
            const bbox = pred.bbox;
            const centerX = bbox[0] + bbox[2]/2;
            const centerY = bbox[1] + bbox[3]/2;

            const ndcX = (centerX / screenW) * 2 - 1;
            const ndcY = -(centerY / screenH) * 2 + 1; // Invert Y for 3D

            // Calculate depth based on object size (larger = closer)
            // Primitive estimation
            const sizeFactor = Math.max(bbox[2], bbox[3]) / screenW;
            const depth = Utils.map(sizeFactor, 0.1, 0.8, -20, 0); 

            // Project NDC to 3D World Position
            const vector = new THREE.Vector3(ndcX, ndcY, 0.5); // 0.5 is arbitrary z for unproject
            vector.unproject(this.camera);
            
            const dir = vector.sub(this.camera.position).normalize();
            const distance = -depth + CONFIG.HOLO.CAMERA_Z; // Adjust for camera
            const pos = this.camera.position.clone().add(dir.multiplyScalar(distance));

            // 2. Create or Update Mesh
            let targetGroup = this.targets.get(id);
            
            if (!targetGroup) {
                targetGroup = this.createTargetMesh();
                this.scene.add(targetGroup);
                this.targets.set(id, targetGroup);
            }

            // Smooth Movement (Lerp)
            targetGroup.position.lerp(pos, CONFIG.AI.SMOOTHING);
            
            // Dynamic Scaling based on distance
            const scale = Utils.map(distance, 5, 20, 1, 4);
            targetGroup.scale.setScalar(scale);

            // Rotate inner ring
            targetGroup.userData.ring.rotation.z -= 0.1;
            targetGroup.userData.ring.rotation.x += 0.05;
        });

        // Remove lost targets
        this.targets.forEach((mesh, id) => {
            if (!activeIds.has(id)) {
                this.scene.remove(mesh);
                this.targets.delete(id);
            }
        });

        document.getElementById('stat-obj').innerText = activeIds.size;
        
        const alertUI = document.getElementById('target-lock-ui');
        if (activeIds.size > 0) {
            alertUI.style.opacity = 1;
        } else {
            alertUI.style.opacity = 0;
        }
    }

    animate(avionics) {
        // Parallax Effect based on Gyro
        if(this.grid) {
            this.grid.rotation.z = avionics.roll * 0.05; // Tilt grid
            this.grid.rotation.x = (Math.PI / 2) + (avionics.pitch * 0.05);
        }

        // TWEEN updates
        TWEEN.update();

        this.renderer.render(this.scene, this.camera);
    }
}

// --- 5. AI KERNEL ---
class NeuralCore {
    constructor() {
        this.model = null;
    }
    
    async init() {
        Utils.log("LOADING NEURAL NET...");
        await tf.ready();
        this.model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
        Utils.log("NEURAL NET ONLINE");
        return true;
    }

    async detect(video) {
        if (!this.model) return [];
        return await this.model.detect(video, 10, CONFIG.AI.CONFIDENCE);
    }
}

// --- 6. MAIN SYSTEM (OMEGA) ---
class OmegaSystem {
    constructor() {
        this.video = document.getElementById('video-feed');
        this.avionics = new Avionics();
        this.holo = null;
        this.ai = new NeuralCore();
        this.isRunning = false;
        this.lastAiTick = 0;
    }

    async boot() {
        try {
            // A. Init Sensors
            await this.avionics.init();
            Utils.log("SENSORS CALIBRATED");

            // B. Init Camera
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: {ideal: 1280}, height: {ideal: 720} },
                audio: false
            });
            this.video.srcObject = stream;
            await new Promise(r => this.video.onloadedmetadata = r);
            this.video.play();
            Utils.log("OPTICAL FEED SECURE");

            // C. Init AI
            await this.ai.init();

            // D. Init Holographics
            this.holo = new HoloDeck();
            Utils.log("HOLOGRAPHIC DECK READY");

            // E. Engage
            document.querySelector('.loader-ring').style.display = 'none';
            const btn = document.getElementById('btn-init');
            btn.style.display = 'block';
            btn.addEventListener('click', () => {
                document.getElementById('boot-ui').style.display = 'none';
                this.start();
            });

        } catch (e) {
            Utils.log("CRITICAL ERROR: " + e.message);
        }
    }

    start() {
        this.isRunning = true;
        this.loop();
    }

    async loop() {
        if (!this.isRunning) return;

        const now = performance.now();
        requestAnimationFrame(() => this.loop());

        // 1. 3D Rendering Loop (High FPS)
        this.holo.animate(this.avionics);

        // 2. AI Logic Loop (Throttled for Performance)
        if (now - this.lastAiTick > CONFIG.AI.TICK_RATE) {
            const startCpu = performance.now();
            
            if (this.video.readyState === 4) {
                const preds = await this.ai.detect(this.video);
                // Pass detection data to Holographic Engine
                this.holo.updateTargets(preds, this.video.videoWidth, this.video.videoHeight);
            }

            const endCpu = performance.now();
            document.getElementById('stat-cpu').innerText = (endCpu - startCpu).toFixed(1);
            this.lastAiTick = now;
        }
    }
}

// --- LAUNCH SEQUENCE ---
const OMEGA = new OmegaSystem();
OMEGA.boot();

</script>
</body>
</html>
